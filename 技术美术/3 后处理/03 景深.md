

# 一、什么是景深

维基百科是这样描述的：

景深(Depth of fielf,DOF) 景深是指相机对焦点前后相对清晰的成像范围。在光学中，尤其是录影或是摄影，是一个描述在空间中，可以清楚成像的距离范围。虽然透镜只能够将光聚在某一固定的距离，远离此点则会逐渐模糊，但是在某一段特定的距离内，图像模糊的程度是肉眼无法察觉的，这段距离称之为景深。当焦点设在超焦距处时，景深会从超焦距的一半延伸到无限远，对一个固定的光圈值来说，这是最大的景深。

下图是景深的示例：

![[200af730bdfb929c1bf8c2d83201b996_MD5.png]]

可以看到上图中间的蝴蝶部分是清晰的，而其它都是模糊的。

那么为什么画面中特定的部分是清晰的，而另一些则是模糊到几乎无法辨认？

有一个概念叫离散圈，能够帮助我们理解为什么照片的特定部分是清晰的，而其它部分是模糊的，离散圈是指在准确对焦的时候，场景中的一个点会被完美还原出来，就是指下图的合焦状态，而在对焦错误的情况下，这个点会在画面中形成一个错误的圆形。

![[dfcc2a17d25ec361f7e7f5e0ae977b37_MD5.png]]

# 二、景深的作用

景深的作用：

选择性的突出或者强调画面中的一部分，例如某个物体或者某个人物，吸引观察者的注意力到画面中清晰对焦的部分，而忽略其它的模糊部分的细节。

强调所拍摄场景的深度，增加画面的层次立体感。

艺术意境的表达。摄影师可以利用景深效果，营造处虚幻、梦境、或者神奇等意境。

表示主观的视线。在电影学中，通过调节浅景深的镜头，使之对焦在不同的位置上，来表示某个人的主管视线的转移。

交代人物的关系。在电影学中，通过景深聚焦位置的变化，来表达前景和背景人物之间的关系。

下面是景深的视频示例：

![[0dab50c41b20041175f6ea14ee362cfd_MD5.gif]]

# 三、移动端景深效果实现

景深的效果是在后处理阶段完成的：

![[689171c4cb2b36f8e9d5414255d98dff_MD5.png]]

它的制作思路这样的，先制作景深mask，然后对场景进行模糊，之后再和正常场景插值合并。

![[d749dc8507cd6b3d29b1c70a63018aee_MD5.png]]

# 四、高级景深效果思路拓展

景深渲染中出现的三种情况的示意图以及相对应的滤波核。下面a图中p点在背景区域，b图中p点在前景区域，c图中p点在聚焦区域。

![[e46c548cc474a08feee40504ab307d28_MD5.png]]

颜色泄露的缺陷：

![[02b58d43b99d917943acef0d17b7a661_MD5.png]]

对焦区域的颜色糊在了背景中。

解决方案：调整模糊的扩散范围。

模糊的不连续缺陷：

![[b57f2b5c45d619b4c63b57fd562091b2_MD5.png]]

前景区域的模糊不连续问题。

解决方案：前景拆开单独计算，用一个Mask去融合背景。

散景的模拟：

![[fad50d8fa2012a1d7cba6ec06f566764_MD5.png]]

# 五、作业

实现景深效果

景深这里实现的基本和课堂的一致。

对应Shader代码如下：

![[e7f58f2a081066d9247abacee23bf105_MD5.png]]

这里分了两个Pass，一个是模糊，一个是做景深效果的插值混合。

两个Pass对应的片元着色器代码：

![[ec1a0634c76d2d2ba5848054fde53abe_MD5.png]]

这里为了让模糊和原图过渡部分不那么生硬，加了Smoothstep做一个过渡。

对应的C#代码：

![[e9f93c6d13cc6125718f8e75c34bd87a_MD5.png]]

模糊就是正常的降采样+升采样模糊，模糊完成之后与原图做景深的插值运算。

场景就是使用官方的，调整景深距离对应的效果图：

![[22b4105621ef625c9450dbdb0c7b7a4f_MD5.gif]]

这里也看到很明显的不连续的模糊效果。

接着看看这个景深的插值Mask的效果图：

![[6d390903c6a5a935c4cfa2c31aa334ca_MD5.gif]]

URP中自带的景深效果分析

它这里是有两种景深效果，一种是高斯模糊的，一种是散景模糊的。

高斯模糊景深

先来看看高斯模糊的动图：

![[e42c5dca520556acbd0a2c87a0fcf9cb_MD5.gif]]

可以看到它的模糊效果有点淡，不过没有了那种模糊不连续的情况。

先来看看它的参数：

![[b0fe7a57fdc9ae895954d6c651ab9c3f_MD5.png]]

Mode就是景深的方式，Start就是景深的初始位置，End就是景深的结束位置，Max Radius是模糊扩散范围，High Quality Sampling顾名思义是高质量采样的意思。

高斯模糊的景深这里是有5个Pass，跟着它的每个Pass的渲染顺序来分析下它的思路。

首先是第一个Pass和执行前初始化信息

对应代码截图:

![[120f8fcbf296ebcd27946acda2bbcf01_MD5.png]]

在1处主要是获取并设置它的材质参数，包括我们在后处理面板上的参数以及降采样的信息。

在2处是对临时RT的资源分配。

在3处主要是设置降采样后的分辨率信息，对应的PostProcessUtils.SetSourceSize的代码如下图：

![[1109214cdac1efacc37124eb82944807_MD5.png]]

在4处是直接执行Shader的第一个Pass，它对应的片元代码如下图：

![[15ac72270d94da880656a25364e22361_MD5.png]]

它这里的采样方式通过分辨率的坐标采的样，然后类似深度雾那样弄了个和深度相关的Mask，当FarStart、FarEnd不变时，深度越大这个值也就越大，当FarStart不变，而FarEnd改变时，这个输出值随FarEnd的增大而变小，然后通过帧调试器看看这个Mask的值的变化：

![[c2def9522e4df5119686ef42d68d7976_MD5.gif]]

这个值应该和后面的混合计算相关，不过这个过渡确实更加的融洽。

第二个Pass

对应代码截图:

![[35850d7220d5446d8fa240d0a7136d5e_MD5.png]]

这里它是设置两个颜色的多重的渲染目标，而且还设置了一个深度缓冲的渲染目标，接着就是它相关的Shader代码：

![[9e2c5ea0478ba5a3abf069cae475bbfc_MD5.png]]

它这里是有两个分支逻辑的，一种对应我们面板的High Quality Sampling，先来看看不勾选它的情况。

很明显不勾选的话，这里输出了两个对象，一个是第一个Pass计算的Mask，另一个就是返回采样的源颜色与Mask相乘的值了，帧调试器内容如下图：

RT0：

![[6d8efae9713ec8544a51ae0954b5b33f_MD5.png]]

RT1：

![[f7a167585ce37e259d721a6f565306cd_MD5.png]]

这里也是看到两个渲染目标都是经过降采样的操作，这是在初始化分配RT时，它的大小就决定了。

接着我们再来看看勾选High Quality Sampling的情况，代码如下图：

![[c299ba90f2f520463c02cf36fcd70005_MD5.png]]

看代码它其实是对两个渲染目标做了模糊过滤的操作，这个模糊算子是那种旋转的十字形的模糊算子。

看看他们的模糊对比：

经过模糊操作的RT0：

![[2f168be08eafd41664c36473641b7eea_MD5.png]]

未经模糊操作的RT0：

![[0818b7f9c37f964a2a13c9b844008725_MD5.png]]

老实说不放大仔细看感觉两种差别不大。

模糊Pass

对应的代码如下图：

![[7a25efda028a3041fc9ad9ba4fc9ed59_MD5.png]]

Shader中对应的Pass:

![[5c3302280654e153f7f4734eee06ccca_MD5.png]]

看名称大概也知道一个是水平模糊，一个是垂直模糊。

接着就是模糊Pass的代码：

![[976bd223839f53c889f18e76592f7086_MD5.png]]

在1处就是指水平模糊和垂直模糊的片元方法。

在2处就是先采样之前计算的Mask的值，然后再计算卷积时对应的偏移量，可以看到如果对应Mask的灰度值越大，那么这里模糊扩散的范围也就越大。

在3处接着就是进行对应的滤波计算，它的偏移量和卷积和代码如下图：

![[f4ad8d301c9c1335dc77099dace35668_MD5.png]]

值得注意的是最后累加的时候还增加了权重值的计算。对于这里我的理解是如果扩散采样Mask的灰度值比当前片元采样的灰度值要小的话，那么权重也就越小，说白了就是在Mask中某像素周围灰度值变化越大的地方(即深度差比较大的地方)，使它的模糊权重也就越小。那么试试把这个权重值和权重值为1有什么区别？

默认的权重值：

![[ec019798eadff133b7600c25be36a046_MD5.png]]

权重值为1：

![[503eaac1668a458eac2cc2baf54dd931_MD5.png]]

对应的Mask图：

![[997160cf814911771a43417cb0485683_MD5.png]]

感觉对比效果不明显，不过按理说权重值越小的话，那么它就会呈现越接近当前片元对应的原本的源纹理的颜色。

不仅如此，代码中还加了premultiply这个值再一步地控制总的权重信息，如果premultiply这个值为true的话，那么是对于整体颜色，它是提亮了的，即sampCoC这个值越小，卷积结果越大，这里水平模糊Pass默认是开启了的，而垂直Pass是关闭了的，不过为什么这么做呢？可以试下将premultiply都为false和都为true的模糊结果图对比。

premultiply都为false ：

![[0973d216fdac3742c2aef36c6f030fbd_MD5.png]]

premultiply都为true ：

![[69d1e16e65e46e3df629f9a04ef63209_MD5.png]]

再来看下对应的Mask：

![[997160cf814911771a43417cb0485683_MD5.png]]

结果确实和想的一样，premultiply的作用应该就是将清晰的地方的颜色各通道灰度值增加。

合并Pass

对应代码截图:

![[a80a213c6daad4df7b86e1e7da5b1f4b_MD5.png]]

Shader代码：

![[56ad0ad93fb296284a67e16b2fd9d7fd_MD5.png]]

在1处，主要就是把需要计算地信息给取出来，baseColor就代表着最初的源纹理的颜色，coc代表着之前的Mask灰度值，farColor表示之前的模糊纹理颜色，我们需要通过这三个信息计算最后的结果。

在2处就是具体的计算方式了，当coc等于0时，直接输出源颜色，当coc大于0时，按照 baseColor * dstAlpha + dstColor 这种方式输出最后的结果，baseColor代表着源颜色，dstAlpha = saturate(1-sqrt(coc*TWO_PI)),dstColor=farColor*saturate(sqrt(coc*TWO_PI))。

其实这里的公式换算过来和Lerp(farColor,baseColor,插值)是一样的，这个插值即dstAlpha等于 saturate(sqrt(coc * TWO_PI)),虽然不知道里面为什么要乘以TWO_PI和加个根号，不过猜测是为了提升模糊颜色占比的一种做法，因为模糊RT本身就是不均匀的模糊，Mask灰度值越小的地方模糊效果越弱，提升插值占比也可以。

最后来总结下URP自定的高斯模糊的景深效果的优化：

1、它的插值Mask是通过深度雾的那种计算方式，再加上可对Mask本身再做一次滤波操作，进一步减弱了模糊不连续的问题。

2、再做模糊操作时，模糊扩散范围和Mask灰度值相关，灰度值越小扩散值越小，使得模糊RT的模糊效果变得不均匀。

3、同样在Mask灰度差比较大的像素，它在模糊的结果方面会一定程度上往灰度值小的像素颜色靠近，也是为了凸显景深效果的同时，使两者过渡更加平滑。

4、在模糊RT中，一个像素中的周围像素对应Mask灰度值越小的地方，那么会对整体的颜色灰度值有提亮的表现，也是为了凸显景深效果。

散景景深模糊

后面有时间再弄。。。。

PostProcessing插件中的景深效果分析

这里直接用的测试抗锯齿的场景，先来测试每个参数的大致作用。

调整Focuse Disance参数的动图：

![[d3372f550a79721e50271eb511e75212_MD5.gif]]

调整Aperture参数的动图：

![[89e7efe38e507926cb4ab949ebb4075a_MD5.gif]]

调整Focal Length的动图：

![[62deea589217c519c988c52b0649e807_MD5.gif]]

修改Max Blur Size的动图如下：

![[87da2fcc15e84c4f52d3044147eae7c3_MD5.gif]]

接着看它的属性：

![[b8ec9c6eea2b4e78acb6fb6b1cc311fa_MD5.png]]

通过测试和参数命名可以大致推断每个参数作用：

Focuse Disance：指景深位置。

Aperture：光圈，值越大看的越清晰，感觉这里是和真实意义上的光圈反着来的。

Focal Length：焦距，值越大越模糊。

Max Blur Size：修改模糊的方式，枚举越往下模糊的程度越大。

接着同样按照它的代码的执行顺序来理清思路。

材质参数设置

对应的代码截图如下：

![[0015d994dd9610e5f305eeeb6b3ac827_MD5.png]]

在1处设置颜色和景深Mask的RT的格式。

在2处计算它所需要的传递的参数信息，在这之前先看参数的取值范围：

![[63f72da3b62083f0f4b30ee7a862edf9_MD5.png]]

其中scaledFilmHeight计算的是0.024(k_FilmHeight是固定值)乘以相机画面的高度再除以1080，假设相机画面的高度值与1080比较接近，那么scaleFilmHeight就可以暂时把它当作是0.024。

f是参数面板中的focal Length的千分之一，对应取值范围为(0.001,0.3]。

s1是指 f和参数面板中的focusDistance取最大值，从取值范围看这里一般大概率返回focusDistance，反之那就是比较小的值，感觉就是计算景深距离，不过加了一个小的Clamp值。

aspect就是屏幕的宽高比。

coeff这里比较复杂，这里也做个假设，就是focus Distance比f要大很多的话，就可以把s1-f看成是focus Distance，最后计算出来也就是coeff约等于(focal Length的平方)/（aperture * Foucs Distance * 48000)，这个值也不知道干啥用的，后面在Shader计算中再看看。

maxCoC是通过屏幕高度计算出来的，对应函数代码：

![[27aeca05a49d6d0774cb5a57fc61e409_MD5.png]]

这里指的是根据我们选的模糊程度而定的指定像素宽度与屏幕高度的比值，且最小Clamp值为0.05，这里是指弥散圆的直径。看注释这是经验推导出来的。。。。

在3处的sheet可以理解为对材质中属性块的抽象，它的API意义跟Material往Shader传递参数的意义差不多。

它这里传递了景深距离、coeff、maxCoc、maxCoc的倒数、宽高比的倒数。

景深范围Mask的Pass计算

对应的代码截图如下：

![[2a371b295bdc1ecf331fb20d1d687d8e_MD5.png]]

对应的Shader代码如下图：

![[c2fcee6c2bcc93c87b8ec18147879170_MD5.png]]

对于这里的片元计算可以这样看，coc中的(depth-_Distance)/max(depth,1e-4)可以看成1-_Distance/depth，不过depth有比较小的clamp值，而且这个函数值可能具有正负性，最大不超过1，最小为无穷小(因为_Disance没有限制最大值)，我们结合函数图像来看：

![[682299dab92dafb6bb2ca7f6f9076601_MD5.png]]

上图中的函数1-2/x，x可以表示depth，2表示一个距离值的话，那么可以看到在红框部分，也就是函数值约等于0的部分，就是景深区域，大于0的地方表示后景，小于0的地方表示前景，它使用这个函数的目的就是划分这三个区域。

再结合返回结果来看，这里想做的主要还是尽量把它((depth-_Distance)/max(depth,1e-4))缩放到一定范围再做偏移，最后再做saturate操作，从这里可以推测，最后的灰度值(0,0.5)代表前景，0.5左右就代表景深位置，(0.5,1)代表着后景。

对于_LensCoeff这个值，也就是之前算出来的约值，即(focal Length的平方)/（aperture * Foucs Distance * 48000)，可以看出来这个值正常情况下是比较小的，主要作用还是为了调控coc这个值的正负范围大小(主要还是缩小负值的范围)，也就是我们的景深范围，这也解释了为什么之前测试focal Length和aperture这个参数都能调控景深的范围，而_RcpMaxCoC的作用也是一样的，主要也是调整它的负值的范围(主要是扩大负值的范围)，而且这个值正常情况下是大于1的，模糊的程度越大，那么_RcpMaxCoC这个值就越小。

接着我们测试调整Aperture和Focal Length所对应的景深Mask的改变：

调整Aperture的动图：

![[4c70c7d9528ec484cb28d1ac9bb396aa_MD5.gif]]

可以看到aperture越大时，景深Mask整体越灰，与之对应的就是最后的渲染画面越清晰，而当aperture很小时，才会有那种黑白分明的效果，与之对应的就是景深区域很小。

调整Focal Length的动图：

![[07e62f513dbd490258d90ed4c955cd10_MD5.gif]]

可以看到，它和aperture参数是反着的，这个值越大，黑白越分明。

通过测试我们可以通过调整Aperture和Focal Length来改变景深的范围，从公式上看的话，修改Aperture这个值的可控性会更高些，还有就是这里的Mask颜色越接近于0.5，说明就越靠近景深的范围内。

开启TAA时对Mask进行过滤操作

对应的代码截图如下：

![[1c4ed1dbb617b9b1d1236884f18c2ca5_MD5.png]]

看注释的话应该是当TAA开启时，对景深的Mask进行过滤操作。这里的TaaParams传递的是当前的抖动量、运动片段的混合系数。

对应的Shader代码：

![[2d7b822deaf70edec13173e0696ad87e_MD5.png]]

在1处是采样Mask以及它周围呈十字形像素的信息。

在2处是从上一步骤中采样的几个像素中找到Mask灰度值对应最小的那个像素信息。

在3处是从上一步骤取得的像素中先取得对应运动矢量RT中的矢量信息，然后再从上次的Mask中采样带运动偏移的信息，就是图片中命名的cocHis。

在4处它先是把cocHis做一个Clamp值，限定到当前十字采样中像素的灰度值最小和最大之间，最后再用TAA中自带的混合系数对当前帧的景深Mask做插值混合。

总的来说，这里的操作也是为了考虑到景深Mask因为TAA带来的抖动问题而去兼容它。

这里再来测试下不加这段代码和加上的运动画面对比：

有TAA的判断处理：

![[523be508961b77461fa8dfb6d35be161_MD5.gif]]

无TAA的判断处理：

![[756b5b3a39cd7db19ded32416f757521_MD5.gif]]

很明显，上图中不加TAA判断处理时的草抖动的噪点更加明显。

降采样和预过滤Pass

对应的代码截图如下：

![[73c17d2be3396dde0f283f104288a881_MD5.png]]

这里就是分配了临时RT来充当渲染目标，不过宽高度变成了屏幕的一半。

接着看看Shader代码：

![[e9508aaacddf8bc775f20549f07c8882_MD5.png]]

在1处，它在当前周围像素对源纹理做了个田子形的采样，采样源纹理颜色分布为c0、c1、c2、c3。

在2处，它对景深Mask也做了周围像素的田字形采样，但是这里确是把这个采样值从[0,1]范围映射到[-1,1]，得到coc0、coc1、coc2、coc3。

在3处，它需要对四个像素做混合平均运算，先算每个像素颜色权重值，再算最后的混合结果，这里的混合计算感觉应该是提高模糊区域的对比度。

在4处，它先是取得了在coc0、coc1、coc2、coc3中绝对值最大的数，然后用这个数的绝对值乘以之前的_MaxCoc，这里是计算弥散圆的直径，这里也可以知道弥散圆的直径是跟之前Pass得到的Mask相关，那么如果把之前0.5的景深的灰度值代入过来，那么这里coc就等于_MaxCoc。

在5处，主要对之前的混合结果乘以smoothstep的系数，这个系数的大小其实主要和coc的值相关，如果景深Mask中的周围像素灰度值越接近0.5,那么我们最终得到的颜色值的灰度是很低的，最后就是判断Unity设置是否是Gama空间来转颜色了，估计后面要在线性空间进行颜色的计算。这里还要注意一个地方，就是这个渲染目标的alpha返回的是coc。

我们先来看看经过混合的源纹理和直接采样输出的源纹理的渲染目标效果对比。

经过混合的：

![[1f5d9c8f3d328aab758e67f27469f409_MD5.png]]

因为项目设置的是Gama空间，转化到线性空间变暗了。

放大图：

![[fdd5c354ddf97373ef133484e1050363_MD5.png]]

直接采样输出的(把混合代码注释掉)：

![[ba5ca810ba3e11f01437da8fc7afb137_MD5.png]]

对应的效果图：

![[8c5f563734a265de50c10481e28f50db_MD5.png]]

放大看感觉对比度好像是不一样。

那同样地，调整一下景深参数看下对应效果：

![[c9b65965c579a75d3277dc1df77dee08_MD5.gif]]

这里的输出结果有这个特点，弥散圆直径越小的地方，即越靠近景深的地方颜色越暗。

接着再来看看它的alpha值，也就是coc，如下图：

![[f5fa2a6c5765dea58d56d20549468900_MD5.png]]

一片死黑，估计是alpha数值比较小的原因，因为代码中coc乘以了_MaxCoC，把这个值乘以100看看，如下图：

![[b87578bfa2104369b68177ebd5c649f1_MD5.png]]

![[decb7647b8a74c1e3d5105532542dd94_MD5.png]]

因为coc 也可能为负数，把它乘以-100看看，如下图：

![[e99a57afef634dc9b42fa0a8e71445dd_MD5.png]]

![[c5a57981417047f6d586cc3bef5d5e35_MD5.png]]

从这里我们大概知道coc为正值时，大致是描述远景的区域，coc为负值时，描述近景的区域，而为0的区域也就是景深的区域。

模糊Pass

对应的代码截图如下：

![[753d14ea7631dab2f94e2886e9679b6e_MD5.png]]

与之对应的Pass：

![[f1df42dba325ec8bbb340ecf15d52291_MD5.png]]

可以看到，虽然这些Pass的顶点和片元方法一致，但是声明了宏定义来区分。

这里再来找下对应宏定义的引用代码：

![[f4e33021f6b42a162f0366dc1b4a6f3b_MD5.png]]

展开其中两个：

![[0a9e71efc51d2af121a4cd17b1497c94_MD5.png]]

另外两种模糊也是kDiskKernell这个数组的不同，模糊程度越大数组数量也越多。不过从肉眼来看这个数组里的位置布局像是这种形状，就是逆时针画圈且随着角度增大的同时，它的离散点也离中心越远，很符合散景模糊的算子特征。

接着看它的模糊操作代码：

![[1b5714190d49d8ea9db8ffa741601d99_MD5.png]]

总体上来看它应该是做了两个模糊平均颜色处理的，不过两者中的组成颜色所占的权重值不一样，这里形容的一个是前景的模糊，一个是后景的模糊，最后把这两个模糊平均颜色做一个插值计算返回最后的结果，不过从它的插值的数值上来看，它后景所占的颜色成分是更大的。

在1处它采样了上个Pass的输出结果，rgb通道为之前的过滤后场景颜色，a通道为Coc。

在2处处于模糊的迭代中，它先算出当前UV的偏移量后，对上个Pass的输出结果进行采样。

在3处在当前片元的Coc和偏移采样的Coc中计算最大的Coc，并给一个0的Clamp值，这个值用于后景模糊的权重计算。

在4处这里主要就是计算两种模糊采样的权重了，加个margin看注释时为了更好地做一个平滑地效果。

在5处，为了减少对景深区域的影响，这里加了个小技巧，也就是当前景的coc的绝对值大于一个像素的高度占比时，才进行有效权重的计算，离景深太近的前景区域权重直接设置为0。

在6处，对每个迭代中计算的结果进行累加。

在7处，对结果求平均。

第8处，计算远景结果的a通道数值，不过数值好像没有引用，是个无效代码。。。。。

第9处，就是计算最后的Lerp数值，并进行插值运算，不过这个Lerp值是在求前景a通道的迭代平均值的基础上还乘以了个PI/模糊数量，看它的注释是把它归一化，感觉可能是个trick，因为不这样的话它的alpha会比较大，可以看一下alpha的输出结果：

![[e4e3602f9fdd4064d19866315ce9e14b_MD5.png]]

这个白色区域，反映了前景所占的权重信息，后面Pass的计算会有用到这个值。

最后这里再来对比下在这个Pass中前景和后景的模糊图以及插值后的结果。

后景的模糊图：

![[f533ae52e3a14844e46c46b048c9bb77_MD5.png]]

前景的模糊图：

![[4bd2b65aebd247f4340a59c6e3ce0c83_MD5.png]]

最后两者的插值模糊：

![[399ba337391d11a07ca4bc220d859b47_MD5.png]]

可以看到这个模糊Pass是在进行不均匀的模糊，位于景深处模糊效果就很弱，这么做的原因估计就是为了让模糊效果更加具有连续性。

Postfilter pass

c#代码：

![[84ffdb09fb8fea46cb722febfdb2e07c_MD5.png]]

对应片元着色器代码：

![[9378973848f261388c29208675c09d47_MD5.png]]

这里对_MainTex又做了次田字形的模糊，不过感觉效果不是很明显。估计是为了让景深模糊的连续性更好一点吧。

接着看下前后对比：

模糊前：

![[8b5e03398055a07d445b69dc82ba5ec4_MD5.png]]

模糊后：

![[7824cbbfb5bfc258751b63fb7060956c_MD5.png]]

需要放大仔细对比才能看得出差别。

合并Pass

c#的代码：

![[2c65a50af192b4a1cbce038609495650_MD5.png]]

对应Shader中片元着色器的代码：

![[0172a3b7691007801ccfc3e147abc94f_MD5.png]]

在1处先是采样了上个Pass计算的模糊图，然后再采样景深Mask的值，接着再对这个Mask值做操作，再这之前先回顾这个Coc的计算方式，如下图：

![[383367c6c70682a60626a16bd5b50c7e_MD5.png]]

如果再和这里的值结合起来，某种意义可以看出后面计算的coc = (depth - _Distance) * _LensCoeff / max(depth, 1e-4) ，只不过是带了一定Clamp值，让这个Coc约束在[-_MaxCoC,_MaxCoc]之间，Coc约等于0时代表景深区域，大于0表示后景区域，小于0表示前景区域。

在2处这里主要就是把coc进行smoothstep运算，从填充的最小和最大值看，属于后景的一部分区域ffa才会大于0，即越往后ffa越大，这个值某种意义上感觉是指后景的纵深程度，不过这是非线性的，也是为了有更好的平滑效果。

在3处主要是采样源纹理的颜色，并把这个颜色转到线性空间去以备进行相关运算。

在4处先计算lerp的插值，然后进行最终的插值运算。不过对于其中alpha的运算，感觉好像是无效的运算，因为这里也没设定相关的混合模式，后面的Pass也没有找到对这个渲染目标a通道的引用。。。对于lerp值的话，可以看成是lerp(1,ffa,dof.a)，其中ffa已经说了表示后景的那部分，而dof.a则表示近景的权重，看得出来片元不管是在前景还是后景，这个lerp值就结果而言，都是大于0的，而当片元位于景深位置，这个插值的数值才会趋近于0这里，才会越靠近源颜色。

我们输出这个插值看看：

![[ead2aa3487019cad29c8ec8c16423dd2_MD5.gif]]

看的出来这个插值的过渡方面效果还是不错的。

最后还有个问题，为什么这个景深后处理的颜色都要在线性空间下计算？难道这和物理的真实性有关系？最后注释下一些代码来对比下。

转到线性空间计算的结果：

![[89799a49ce55b91c550fabcb91f21d9d_MD5.png]]

不做线性空间的转换结果：

![[6886e77a6367cfa9487be1d649061802_MD5.png]]

感觉好像是有些不太一样地方，线性空间转化后的画面中模糊区域的颜色好像更亮了些。

对于插件的景深效果总结

1、这里的画面总体被划分了三个区域，即后景、前景、景深，景深依旧有修改位置和调整范围的参数，而对于前景和后景，也有相对应的处理，主要体现在模糊上，对于源纹理的模糊是不均匀的散景模糊，即前景和后景的模糊结果的混合模糊，也是考虑到模糊的连续性以及颜色泄露的问题。

2、这个插件的景深后处理为TAA抗锯齿做了兼容处理。

3、进行模糊操作时，它并不是直接对源纹理进行模糊的，而是先对源纹理进行了降采样、过滤操作所生成的RT基础之上进行模糊的。这里的过滤先是增加了模糊区域的颜色对比度，然后再降低景深区域颜色的灰度值。

4、在模糊操作之后，接着对模糊RT又是进行田子形的模糊，也是为了模糊的连续性。

5、最后对模糊和源纹理的合并插值计算中，这个插值是从第一个Pass计算的Mask值的基础之上进行不断的映射、过滤、平滑，之后由前景、后景分段插值计算得到，这个东西太讲究trick了。

参考链接

[景深概念及计算 (xitek.com)](https://www3.xitek.com/book/optical/depthoffield.htm)

[(16条消息) 高品质后处理：十种图像模糊算法的总结与实现_【浅墨的游戏编程Blog】毛星云（浅墨）的专栏-CSDN博客](https://blog.csdn.net/poem_qianmo/article/details/105350519)