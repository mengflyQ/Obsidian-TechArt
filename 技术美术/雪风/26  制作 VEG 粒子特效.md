![[ee6d27d89db518f8982e92e34c68a34c_MD5.webp]]

小特效尝鲜

GIF

![[40c72798fd58c9c54a510736bfd259ff_MD5.webp]]

示例图

        为了后面更好学习 Compute Shader，这篇文章就换个口味做点小特效，VEG 是 unity 最新推出的 GPU 粒子系统，它和 compute shader 紧密相关，但是它是使用了连连看方式，非常适合我们美术去制作特效，目前在 URP,HDRP,BuildIn 三大管线都支持，包括 URP 管线的安卓移动端也是支持（安卓设备需支持 compute shader）。为了方便说明，后文中把 VEG 粒子就简称 V 粒子（老的 particle system 简称 P 粒子）。  

         先创建一个 v 粒子（基本的配置安装可以看看官方的教程），然后在初始化里创建一个圆环初始位置（类型为 volume position），单次发射模式发射 100 个，总计 100 个，输出一个 line 的 output，然后在粒子的 Transform 组件上旋转的 x 轴旋转 90 度（因为 circle position 不支持旋转）。

![[145cfb086753813025ca992eec29d540_MD5.webp]]

        然后我们把 lineOutPut 的目标偏移设置为当前位置的 - 10 倍，就神奇得发现所有的线都聚集到一起了。

![[e0e2b02ec7c96fb0dfcebab2746ff143_MD5.webp]]

        这里 TargetOffset 是设置当前线的朝向的。当我们把当前位置的倍数设置为 1 时，

![[0d89c5d79f3558a7e04a7a9b7f02f32c_MD5.webp]]

        就表示以当前起始点 A 为向量起点，OA 向量为步长的一个线条，但是实质上只有 AB 段，这是因为 VEG 默认的粒子长度是 0.1 米，也就是以 A 为起点，OA 的 0.1 倍为终点的线段，也就是 AB 段。VEG 默认的长度为 0.1 米，是非常重要的一个特点，很多时候的单位，比例问题都是我们忽略它引起的。  

![[ba4e7d8efd12a86f58ad72f3c42df6c6_MD5.webp]]

        所以，当我们把当前位置的倍数设置为 - 10 时，就会让线段的末端朝向原点（0，0，0）。得到任何位置的线段都朝向中心点。

![[49befd2fa8cbee96080665339113dc85_MD5.webp]]

![[25757f2ee74a679f9c4fdae22b3c20e4_MD5.webp]]

        然后我们再去偏移这个目标点，就可以随意控制这些线段的目标位置。比如我们把目标点的位置的 Z 方向偏移 10，也就是 1 米的时候：

![[f4cd23f3ecfc4be2396df97451d649a6_MD5.webp]]

聚集中心点就会形成锥体，锥体高度为 1 米 (对比 1 米长的 box），如果去偏移 x 和 y 也有同等效果，读者可以自己试试。

![[907ae89dcc8b3cb59643eace6d9d9df6_MD5.webp]]

        然后我们把它暴露到外面成一个 vector3 的名为 position 属性，但是直接暴露出来会有比例问题所有需要乘 10，因为旋转了 90 度需要调换 yz 轴并反向 z 轴。

![[58b879773ba5f31b1c3dc483fa9dc237_MD5.webp]]

然后在外面我们创建一个小的 cube 去绑定了 v 粒子的 position 属性。之后就随便拖动 cube，就可以随意去控制这些线的目标点位置了。

![[764f8d49d5b236f723782bac46ca2579_MD5.webp]]

然后我们在添加一个 Cube 的 OutPut，随便丢一张贴图上去，如下图所示。

![[da6c55693258275773765a6e78d8fb9c_MD5.webp]]

仔细观察线，有些地方的叠加模式不正常，如下图所示，我们把线的模型设置为 opaque，就没问题了。

![[08d6873a009e13e34e1e665beb9a3bc9_MD5.webp]]

修改混合模式前后

        然后我们在 update 里加一个 set  position 来实时更改粒子位置，这里我们只想修改 z 的位置，所以 x 和 y 还是取的原粒子的位置，而使用了一个 1D 的培林噪波去偏移 Z，1D 的培林噪波的 x 和 y 的 coord 是采样的粒子的本身的 x 和 y 的值，再加上一个 time 进行时间的偏移，然后粒子就开始上下起伏动了起来，这个本质是和 shader 里的噪点使用方式一致，非常好理解。

![[ddb08d5707faa2b601298ac36b3bd9a0_MD5.webp]]

        cube 虽然动了起来，但是我们想要的是 cube 只是顶部在上下起伏运动，而底部是全部在一个水平线上整整齐齐。但是我们加了 set scale，缩放 z 为 4 时，就发现 cube 不仅缩放了，而且是轴心上下均匀缩放：我们想要的是 cube 轴心上面不缩放，而轴心下面，所有的 cube 都平齐，我们使用以下 2 步去解决它：

![[86c84054e17e964168fdfcf32a94b748_MD5.webp]]

默认是上下均匀缩放

        第一步，先修改 cube 的轴心位置，我们在缩放之前，把轴心位置的 z 偏移 0.5 个单位（也就是 0.05 米），把轴直接移动到最上面的面，然后进行缩放，就会发现缩放就是以 cube 的上表面为底而进行的缩放，这样上表面的问题就解决了。

![[c6262ecf1fa25806485941e3a93caf08_MD5.webp]]

        第二步，就是解决下表面的平整问题，让所有的粒子的下表面都完全整齐，其实这个也非常简单，用一个小的数学技巧即可解决，效果如下图所示，所有的底面都平齐了。

![[afa1dbf0588286d15ca76a1d498a644f_MD5.webp]]

        这里来解释一下其中的数学原理。如下图所示，设 a 为 cube 的原本长度，x 为缩放倍率，noise 为之前的 1D 培林噪波值，则可以推导出 x 和 a 的函数关系式。

![[cb65651f8a5cde9f335b1795261de1b4_MD5.webp]]

        然后我们使用一个 set scale 去设置 a，即让 cube 的长度为 0.1*a 米；下面那个 multi scale 就是 x，拿去缩放，是使用上面推导的关系式得到的 x，在计算中要使他们的单位一致，所以要乘 0.1

![[63ed07ff6ca73a86b02fe84bc663010e_MD5.webp]]

这样，他们的底部就完全整齐，只有上表面随着噪点的滚动而滚动。

![[81be88a580d356054b24385607579e25_MD5.webp]]

然后加一点细节，调整一下颜色和粒子，我们就完成了！

![[e61ef58fd876f9d4afb946c025f5028d_MD5.webp]]

顶部的 cube 可以随意更改，（如果你觉得丑的话可以替换成其他特效），柱子的高度也可以暴露出来调整，这里就交给读者去完成了。

![[f6acd5ae660964236e62cb47f219aca2_MD5.webp]]

V 粒子系统整体来说可玩性非常高，它的内容有很多和 compute shader 是相互关联的，这个算学习 compute shader 前的一个开胃菜，但是可惜的是官方一直没有出节点说明文档，说是 2020 出你倒是出啊。今天 2020 年 7 月 13 日了，打个卡，官方啥时候出，我就啥时候深入研究，做一些特效来玩，最后附完整节点图，不知道 B 站专栏对大图的支持是否友好.......

![[45b07ff2702a5213d2ab7c78b2555398_MD5.webp]]