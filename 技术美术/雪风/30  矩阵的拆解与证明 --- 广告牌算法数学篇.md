注：本篇为纯数学推导。

有时候我们会遇到这种需求，如何在 shader 里获取到缩放值？答：这太简单了，直接 C# 传一个 float3 给 shader 不就行了么？但是这种方式总感觉说不上来的怪怪的，明明我们都能在 shader 里获取到各个坐标系的转换矩阵了，区区一个缩放值怎么会不能直接拿到？还需要 C# 远程助攻一波？  

 随后，我在这篇文章（https://forum.unity.com/threads/can-i-get-the-scale-in-the-transform-of-the-object-i-attach-a-shader-to-if-so-how.418345/）里找到了我的答案，答案是有了，但是怎么推导出来的? 我这次打算从头开始推导一遍这个结论。


![[![[e78eb9d6615f7b2be09ad850c024bbc4_MD5.webp]]]]

空间变换矩阵 M，它是一个 4x4 的矩阵，包含了旋转（rotate），缩放（scale），平移（translation）三种算法，unity 里我们约定它们的顺序是先缩放矩阵（Ms），在旋转矩阵（Mr），再平移矩阵（Mt）也就是如下的公式：

**M=**Mt Mr Ms****

注意在 unity 里的我们常用列向量来表示，故计算矩阵的顺序是从右往左，计算顺序不要搞混淆，后文的整个推导全是以点的坐标作为对象，不是以向量作为对象。

 平移矩阵 Mt，假设我们在 x，y，z 方向上分别偏移了 a，b，c 个单位，则它的表达式如下：

![[6c7a58e0184d4d86b88a4bded7953d97_MD5.webp]]

平移矩阵

        **缩放矩阵 Ms**，假设我们在 x，y，z 方向上缩放了 kx，ky，kz 倍，也就是 Transform 组件的 scale 值，这个值，也就是我们需要自己计算得到的值。

![[135b7859c0924574a4bffc89a4f0430d_MD5.webp]]

该矩阵的表达式：

![[19f61caa866e28110e3e212b35cbf5c1_MD5.webp]]

缩放矩阵

        **旋转矩阵 Mr**，最复杂的矩阵了，不过在[之前的文章](https://www.bilibili.com/read/cv6640445)里我推导过一个 2D 的旋转矩阵，这个比较简单，这里再说一遍：

下图是一个 2 维坐标，旋转向量 a 的模长为 r，它旋转θ角度后得到新向量 a‘。

![[c4aa27f6b66d508ef49edeac7b02acc5_MD5.webp]]

对于向量 a 和 向量 a‘，他们分布有如下等式

x=r*cos（α）

y=r*sin（α） 

x’=r*cos（α+θ） 

y‘=r*sin（α+θ）

将 x’和 y‘的三角函数展开 

x’=r*（cos（α）cos（θ）-sin（α）sin（θ）） 

y‘=r*（sin（α）cos（θ）+cos（α）sin（θ）） 

 并将 x 和 y 带入 x’和 y‘，消掉α和 r，可得 

 x’=cos（θ）x-sin（θ）y

y’=sin（θ）x+cos（θ）y 

![[8c5dadb11ee79c5d12f5d488c6d47365_MD5.webp]]

这样，我们就推导出了我们想要的 2 维旋转矩阵 M 的公式。

然后我们把它拓展到 3 维坐标系下，得到了分别绕 x 轴，绕 y 轴，绕 z 轴的旋转矩阵：

![[cb068c66da21e4d48b629e9a3fc6e4a0_MD5.webp]]

绕 X 轴旋转 x 度

![[8ac9af32153ba6dd31a00d3c97a3516c_MD5.webp]]

绕 Y 轴旋转 y 度

![[ad6431ad9044037e0cf3a8ff623e3180_MD5.webp]]

绕 Z 轴旋转 z 度

上面 3 个矩阵的推导非常好理解：比如绕 X 轴旋转 x 度，本值就是 x 轴上的值不变，把 y 和 z 当成 2 维度平面去套二维矩阵；同理可以得到 y 和 z 的旋转矩阵。

在 unity 里面，我们约定旋转顺序是先 z 轴（Mrz），在 x 轴（Mrx），最后 y 轴（Mry），这个和其他引擎的顺序不一样，请读者注意。故旋转矩阵 Mr 的计算公式（顺序从右到左）可得：

**Mr=Mry Mrx Mrz**

但是上式是错误的！！！！

由于参考系的变化，按照顺序进行旋转的同时，模型本身的坐标系也被旋转了，这会导致计算出来的结果是错误的，而当我们把顺序反着写，就能修正这种错误（为什么？读者可以自己推算一遍），故我们需要反着写旋转顺序：

**Mr=Mrz Mrx Mry**

以上，旋转矩阵我们也搞定了！ 

正式推导：几个基础矩阵完成了，那就可以正式推导我们的空间变换矩阵 M 了，他的公式如下：

**M=Mt** **Mrz Mrx Mry Ms**

把式子代入可得）：

![[930b99063f4e3dee010f9b9bb93be741_MD5.webp]]

然后按照从右往左的顺序进行矩阵计算，先计算缩放矩阵和旋转 Y 轴矩阵

![[8082fea6a4d810c96a45158e8f6fbde1_MD5.webp]]

然后计算旋转 X 轴矩阵

![[bddaf1c2f3945cc74b0c263301cfc5b0_MD5.webp]]

然后计算旋转 Z 轴矩阵

![[b4829cb09fdb6f7c0fa588db6fd46e08_MD5.webp]]

在计算平移矩阵，得到 M 的最终表达式

![[6a295815fafa0033989dab2133ad0a24_MD5.webp]]

计算过程是本人纯手算完成后在电脑上重新输入的一遍，因为写得太潦草索性还是在电脑上用 word 码了一遍（word 输入矩阵不太友好，读者有更好的数学工具望在底下留言）

![[434d54fd90b42482f2b826e68cbbcc3a_MD5.webp]]

写得潦草，随后全部重新在电脑端输入了一遍

然后我们最终得到了空间变换矩阵 M 的表达式了，这时候如果计算该矩阵第一列 4 个元素的平方和：

![[3a6cc541c51933a9962726cdf2739f8f_MD5.webp]]

算出来的结果为 x 轴的缩放值 kx 的平方，也发现旋转矩阵的影响已经被消去了，即如果直接取矩阵 M 的第一列元素组成的向量计算模长（也就是对上式结果开平方），其值恰好为 kx，也就是下式的结果值为 kx。

![[d995e85aba582e76c1ab4ca358b0f31f_MD5.webp]]

同理，我们计算第二列的 4 个元素的平方和，看看是否也有如此结论：

![[e5074475827db16b7c2d9994b40c30f7_MD5.webp]]

惊奇的是，其值亦为 ky 的平方，满足上面的结论，则我们可以得知下式的结果，其值就是 ky

![[3dcd926a36f2d8f23cfda1f1385ca194_MD5.webp]]

对于第三列的 4 个元素，进行同样的计算：

![[f41fd062d6cab8185b467a01daa12566_MD5.webp]]

得到了 z 轴的缩放值 kx 的平方，即如果直接把第三列的 4 个元素当成一个向量，计算该向量模长，就得到了 z 轴的缩放值，如下式结果就是 z 轴的缩放值 kz。

![[d16a8216939e08223ad0ee622fbdc8de_MD5.webp]]

这样子，我们就完全把他的数学原理推导了一遍，顺便把《入门精要》的矩阵部分也复习了一下。下一篇里，将会实现一个 colin 大大开源的广告牌算法，其效果会比《入门精要》里介绍的广告牌好得多，其中关键的一点会用到该篇文章的结论。

GIF

![[86896f25b2b25e47a05ee0eef2fd0635_MD5.webp]]

Colin 开源广告牌效果

额外话题，既然我们通过转换矩阵 **M**，可以得到三个缩放系数 Kx，Ky，Kz，也就是缩放矩阵 **M**s，那旋转矩阵 Mr 可以不可以得到呢？答案是肯定的，而且相当简单！观察我们的上图，发现了什么？转换矩阵 **Mr**（即 **Mrz Mrx Mry**）可以直接通过转换矩阵 **M** 的前 3 列向量除以缩放系数 Kx，Ky，Ky 得到，发现了么？

![[7b54b4beb0d7af5affc1b8436af2fe81_MD5.webp]]

这里 Colin 大神给了一张图，如果我们已知一个空间变换矩阵 M，那么我们可以直接得出平移矩阵，旋转矩阵，缩放矩阵。这样就意味着只要我们拿到矩阵 M，就可以直接拆解！

![[f69615aef6431a56fcf7aa4e329c4820_MD5.webp]]

这张图的所有结论已经在上文里通过数学推导直接或间接证明，所以请放心大胆得使用吧！本次推导也帮我更加透彻理解了矩阵变换的过程，希望对读者有帮助！