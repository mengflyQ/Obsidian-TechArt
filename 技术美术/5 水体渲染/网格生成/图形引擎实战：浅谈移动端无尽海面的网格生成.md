国内手游市场发展如火如荼，各类手游开发项目层出不穷，在这之间，不乏一些需要制作海洋效果的项目。说到海洋模拟，笔者脑海中立刻蹦出一些关键词，“Vertex Displacement”、“FFT”、“Gerstner Waves”等，这些都是讨论 “如何让海面起伏更真实” 会涉及到的话题，大家在网络上一搜，可以很容易找到各路大佬的分享，笔者也从这些文章中收益匪浅，但是今天，笔者想分享的并不是上述的主题，而是想跟大家讨论一下“在**移动端**如何让**无穷无尽**的海面网格**细密**以支持复杂起伏” 的问题。

无尽海面的网格生成虽不像海浪起伏模拟一样涉及很多高深的数学、巧妙的优化，却也是制作海洋效果不可或缺的第一环。特别是当我们把运行平台限制在 “移动端” 之后，基于性能与兼容性的考虑，要求我们在这一问题上投入更多的关注。因此，笔者基于曾经的项目经验，在本文中就这一话题针对一些典型的实现方式进行简单讨论，如有错误的地方，请大家不吝赐教。文中涉及的代码与场景演示工程，请从文后链接下载。

### 简单网格片

当我们进行游戏场景搭建的时候，会将做好的模型放置到具体的位置，使用模型自带的 UV 信息进行贴图采样，这样就保证了模型不管在哪里，除了光照效果外，其他外表都是不变的。那么我们应该如果制作海洋的模型呢？难道需要提前做一个无限大的片再放置到场景中吗？答案是——不需要。

因为不管海洋有多大，我们能看到的总是眼前视锥体之内有限的一块区域，因此让海洋无限大的最简单的方式，是创建一个片模型，让其保持 Y 轴高度（海面高度）不变的情况下，跟随摄像机进行 XZ 平面的位移，这样玩家就仿佛永远也走不出海洋了。但是这样会引出第二个问题，模型的 UV 不会变，模型片一直跟着玩家水平位移，那岂不是和摄像机永远相对静止（就像下面视频所示）？


![[db801315dc447a632b0744b3db4061f7_MD5.jpg]]


要解决这一问题，我们肯定不能再使用模型 UV 去进行贴图采样了，取而代之的应当使用世界空间水平坐标（WorldPosition.xz）进行一定的缩放以及时间变换后作为采样 UV，这样能保证同一空间位置的采样结果是稳定的（就像下面视频所示）。使用世界空间水平坐标作为采样 UV 是绝大部分海洋模拟方案采用的一个方式。

![[b5cd93baa5eede8e474b1b1778fdd70f_MD5.jpg]]


从上图中可以发现，我们所使用的模型非常简单，因此无法应用复杂的顶点动画从而产生波浪，但是却不影响通过叠加多层法线扰动产生假波动（如下图所示）。这种方式可以很好地满足不要求真实顶点波动的海洋需求，性能消耗点全在 Fragment Shader 中。

![[9e54f5df1dd76f683879ce03395f128b_MD5.jpg]]

那么问题来了，当我们需要表现非常复杂的海浪时，该怎么办？

### 基于曲面细分

复杂的顶点运动，必然需要细密的网格支持，而我们一般都希望摄像机前的效果最好，随着距离增加可以逐渐淡化细节。针对这一需求特点，我们首先会想到 **Tessellation（**曲面细分）。使用曲面细分，我们很容易让眼前区域的水片模型顶点变得细密，同时按距离逐渐恢复到模型原始细密度。在 Unity 中可以这样实现：首先声明使用曲面细分

![[53c2a8ed0781b9304f51ad55eaec0962_MD5.png]]

在 Shader 中进行细分计算，下图演示的是在 minDist 与 maxDist 之间，根据距离的大小进行细分，tess 的值控制细分的粒度。

![[1b57877358bec6fe0c6cf7ac938aeb5c_MD5.png]]

其效果如下图所示。

![[6d1325d747f7ff52b0edaa2b7423a5d1_MD5.jpg]]


曲面细分很好用，但是当我们想用在移动设备上时，可能会有些犹豫。从兼容性上说，从 OpenGLES3.2 开始支持曲面细分，可以认为现在用户手里绝大部分安卓手机都是可以使用这一特性的，但是不排除某些特立独行的机型或者安卓模拟器存在特殊情况。**从实际操作上来说，目前也确实基本上没见过在手游项目中使用曲面细分的案例**。不过笔者使用上述演示 Demo 在 XiaoMi9SE 设备上测试运行是没问题的。

实际使用的话，我们可能需要考虑这个问题：使用类似于 FFT 技术生成拟真度非常高的波浪时，需要极细密的网格密度，同时，在 Vertex Shader 中的计算（需要做顶点置换操作）也会非常复杂，这种情况下，海面顶点数可能成为性能消耗瓶颈，然而使用曲面细分加密网格是在一个 Mesh 上操作的，结果是整个网格全部会走一遍复杂的 Vertex Shader。假设在视野中看到的海面网格部分需要 8 万个顶点才能满足密度要求，以 FOV=60 为例，那细分后的整个网格大概是 48 万顶点，对于手游来说或许有些高了。要避免这个问题，我们可以把思路放到**如何在渲染之前就对海面看不见的部分进行剔除**上，也可以想办法**让海面动态地仅生成在当前视野中**。

### Lod 模型拼接

渲染管线在实际开始渲染前，会做一步视锥剔除的操作，目的是将不被当前视野看到的对象排除出去，进而减轻后面渲染管线的工作负担。因此如果我们生成的海面是由多块 Mesh、多个游戏对象组合而成，那么渲染管线就可以自动为我们剔除看不见的区域了，同时，我们手动控制海面的组合，也方便进行 LOD 控制，我们可以让离摄像机近的区块网格密度高，而离摄像机越远，网格密度逐渐减小。

一种典型的海面 LOD 模型拼接方式如下图所示。

![[9eea6baeed0038c40e9a7b86a7523eed_MD5.png]]

海面网格中间核心位置最密，每往外一层，网格密度减少一半，由于模型大小一直不变，很容易将这些对象组合到一起。

具体的实现细节，我们首先根据自己的需要确定 LOD 层数，以及每一层级对应的网格密度，并将需要的 Mesh 创建好。下面的案例代码将所有 LOD 的 Mesh 大小限制为 1（-0.5~0.5），方便设置对象缩放。

![[2d978bf4ee54396a5a997444ffab6abb_MD5.png]]

![[24460393b2310a58aeea9757e1c091a4_MD5.png]]

使用生成的各级 Lod 模型，我们直接通过两层循环创建最后放到场景中水块对象即可。

![[33936e626df2468ea2f198e0760846cd_MD5.png]]

最终效果如下面所示。

![[f26949589ea4db0aaff82bde5835de6b_MD5.jpg]]


通过这种拼接方式，每帧我们只会渲染出现在视野中的水块，很好地解决了我们优化顶点数量的需求，但是同时也带来了两个新的问题：

（1） 海面由几十上百个对象组成，导致渲染批次增加；

（2） LOD 不同级别结合处由于顶点没有完全重合，在顶点置换过程中，很容易出现裂缝，如下图所示。

![[13d50a368ffc295013f295833d2fce10_MD5.png]]

对于问题（1），我们可以通过使用 GPU Instancing 的方式合并批次，案例中 7 级 LOD 拼接成的水面渲染批次占用 5 个，因此只要 Lod 级别合适，并且没有太多与水块数量相关的功能渲染，批次问题不大。对于问题（2），如果在具体项目中瑕疵不大，可以通过一个非常简单的方式解决，那就是让外围 LOD 对象逐级下沉一定的高度，来让裂缝被高一级的 LOD 遮挡从而不容易观察到，就像这样：

![[3da73baac7e508aee71d827b0bbd3355_MD5.png]]

但是如果想要完美解决裂缝问题，那就需要用上别的方法了……

### 无缝 Lod 模型拼接

一如前面所说，海面 Mesh 出现裂缝是由于 LOD 结合处存在不重合的顶点导致，那么显而易见，消除这一裂缝的办法，那就是消除结合处不重合顶点。根据这一思路，我们这里介绍一种典型的无缝 LOD 拼接方案 [1]。

该方案的解决思路是让 LOD 之间的顶点在 Vertex Shader 中进行基于距离的位置偏移，从而达到 LOD Mesh 之间的自然过渡。为了达到该目的，首先我们创建的 Mesh 结构需要做些变化，不再是斜着的三角形划分，而是交叉式的三角形划分，如下图所示。

![[0019a5dde25b0d7b74c92eed9cc111d1_MD5.png]]

这种结构可以很容易从当前密度向下一 LOD 级别过渡，主要是让多出来的顶点向交叉斜线四周偏移直至与剩余顶点重合，下图是其过渡的动画过程。

![[328a6e8500a88a92ea94797c4813591b_MD5.jpg]]

<video src="blob:https://zhuanlan.zhihu.com/2ff17ab0-d884-4dfb-9179-79e036d9edb4" control></video>

00:00

/ 00:07

下载

播放速度

画中画

视频信息

镜像画面

循环播放

[X]

DeviceId

:

web_602715683CAFDEED

PlayerVersion

:

1.0.27

SessionId

:

721624a2-b723-459d-976d-8dc92d1bcd01

StreamHost

:

vdn6.vzuu.com

Res

:

mse mp4 h264 416x404@25.00

Color

:

(tv gbr/unknown/reserved)

Codec

:

avc1.64001f/mp4a.40.5

Frames

:

0/0 4/0

VideoBuffered

:

7920 ms

AudioBuffered

:

7917 ms

Speed

:

0.00 KB/s

TotalReceive

:

157.06 KB

GPU

:

ANGLE (NVIDIA, NVIDIA GeForce RTX 3070 Ti Laptop GPU Direct3D11 vs_5_0 ps_5_0, D3D11)

播放 (k)

00:00 / 00:07

倍速

2.0x1.5x1.25x1.0x0.75x0.5x

画中画 (p)

网页全屏 (t)

全屏 (f)

![[328a6e8500a88a92ea94797c4813591b_MD5.jpg]]

00:07

根据这一规律，我们可以在 shader 中利用顶点的 WorldSpacePosition 计算其在当前 LOD 级别应该要应用的过渡值，并进行世界空间偏移。具体的 Shader 计算过程与注释如下面代码所示。

![[5be73fed0dfbf52433aa1696de479ff1_MD5.png]]

最终呈现出来的 Mesh LOD 拼接过渡效果：

![[5e41ba01497a9e5afe058bc1da8ccec6_MD5.jpg]]

<video src="blob:https://zhuanlan.zhihu.com/1fa296b4-224b-437c-b859-a62027265dea" control></video>

00:00

/ 00:19

下载

播放速度

画中画

视频信息

镜像画面

循环播放

[X]

DeviceId

:

web_602715683CAFDEED

PlayerVersion

:

1.0.27

SessionId

:

ded50b20-945d-4d80-9431-905ddb1ce61d

StreamHost

:

vdn6.vzuu.com

Res

:

mse mp4 h264 1176x644@25.00

Color

:

(tv gbr/unknown/reserved)

Codec

:

avc1.640032/mp4a.40.5

Frames

:

0/0 4/0

VideoBuffered

:

19360 ms

AudioBuffered

:

19341 ms

Speed

:

0.00 KB/s

TotalReceive

:

2433.35 KB

GPU

:

ANGLE (NVIDIA, NVIDIA GeForce RTX 3070 Ti Laptop GPU Direct3D11 vs_5_0 ps_5_0, D3D11)

播放 (k)

00:00 / 00:19

倍速

2.0x1.5x1.25x1.0x0.75x0.5x

高清

高清 720P 清晰 480P

画中画 (p)

网页全屏 (t)

全屏 (f)

![[5e41ba01497a9e5afe058bc1da8ccec6_MD5.jpg]]

00:19

### 投影网格

以上所介绍的海面 Mesh 生成方式，都是将海洋作为场景中的固定物体，所有顶点经历正常的空间变换最终进行片元渲染，但是大家有没有想过，难道所有物体的渲染都需要走这样固定的过程吗？

当然不是！只要我们想，我们甚至可以构造顶点位置处于屏幕空间范围的三角面，并在 Vertex Shader 中直接输出进行渲染。本节要介绍的海面 Mesh 动态生成方法——投影网格 [2] 就是类似的思路，其核心点在于，事先构造一个屏幕空间（-1~1）的网格，进入 Vertex Shader 后，首先利用一个特殊的反投影矩阵，计算一条起点在反投影摄像机近裁剪面，终点在反投影摄像机远裁剪面的射线，然后计算这条射线与海平面（高度固定的水平面）的交点，这个交点就是实际的海平面上世界空间顶点位置，然后使用这个位置进行正常的摄像机空间变换和投影变换就可以正常渲染了。也就是说，实际构造的网格保存的是屏幕位置信息。如下图所示，红色网格是我们事先构造的 Mesh，蓝色射线是计算的世界空间射线（从反投影摄像机近裁剪面指向远裁剪面），A 点则是与高度为_WaterHeight 的水平面交点，因此整个黑色的网格就是当前视角下的海面世界空间网格。

![[e10bba8c9249780ce0d57e7e3977b520_MD5.png]]

上述计算在 Shader 中表示为：

![[0aed64ab8f12e07b822e9a786cd2623d_MD5.jpg]]

这一步计算只要理解了还是比较简单的，难点在于反投影矩阵（_MatrixVPInverse）的确定。要计算正确的反投影矩阵，我们首先在世界空间构建一个投影器 Projector。我们对投影器的要求是其始终朝向水面并且完全覆盖主摄像机视野范围内的水面波动，具体如下图所示。

![[acaee224a92450bff70999c15946a105_MD5.png]]

因为海面是上下起伏的，所以使用 baseUp 与 basedown 分别表示海面波动的上界与下界，投影器需要覆盖从 basedown 到 baseUp 与主摄像机视锥体空间的交集，我们使用主摄像机视线方向一定距离的点在水平面上的投影点作为投影器的注视点，来保证投影器始终朝向水面。

![[92b55bd2b1b9f8e5e3843f8a768e3af3_MD5.png]]

并以此确定投影器空间矩阵。

![[55ccf9c8916c9d405b3c2b0d7bb606b8_MD5.png]]

接着，我们计算视锥体 12 根线段分别与 baseUp 平面、basedown 平面的交点，以及处于 basedown 到 baseUp 空间内的视锥顶点，加入一个待处理的列表。下图代码中 lineIndices 数组为 {0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7}，表明视锥体的 12 根线段，IntersectionWithPlane 函数用来求线段与某一高度水平面的交点。

![[3812150701be732805d4268fce9c3def_MD5.png]]

将获得的 visibleFrustumList 列表中的点投影到海面上之后，再使用当前 Projector 视图矩阵和主摄像机投影矩阵进行投影变换，获得投影的最大最小值。因为是对前文所描述的覆盖区域进行投影的原因，投影结果将不会处于 [-1,1] 之间，而是比该范围大，我们使用这些值构造一个 “扩大变换” 矩阵，来对原始投影矩阵进行校正，获得最终我们需要的反投影矩阵 matVPInverse。

![[a4889f7ccbcecd14e2e57cb5948cda14_MD5.jpg]]

![[b833615ee312fefd0b01a8badc609e9d_MD5.png]]

最终网格动态效果如下面所示。

![[bcf6fb7c6546b9d0bcfe66bb39d995b4_MD5.jpg]]

<video src="blob:https://zhuanlan.zhihu.com/f7e80f56-d568-49d9-a709-02a78bd8dc54" control></video>

00:00

/ 00:44

下载

播放速度

画中画

视频信息

镜像画面

循环播放

[X]

DeviceId

:

web_602715683CAFDEED

PlayerVersion

:

1.0.27

SessionId

:

9b9a9c1c-a66c-4a8c-b685-188fa34bc4c0

StreamHost

:

vdn6.vzuu.com

Res

:

mse mp4 h264 1176x628@25.00

Color

:

(tv gbr/unknown/reserved)

Codec

:

avc1.640032/mp4a.40.5

Frames

:

0/0 4/0

VideoBuffered

:

29640 ms

AudioBuffered

:

29629 ms

Speed

:

0.00 KB/s

TotalReceive

:

2048.00 KB

GPU

:

ANGLE (NVIDIA, NVIDIA GeForce RTX 3070 Ti Laptop GPU Direct3D11 vs_5_0 ps_5_0, D3D11)

播放 (k)

00:00 / 00:44

倍速

2.0x1.5x1.25x1.0x0.75x0.5x

高清

高清 720P 清晰 480P

画中画 (p)

网页全屏 (t)

全屏 (f)

![[bcf6fb7c6546b9d0bcfe66bb39d995b4_MD5.jpg]]

00:44

从视频可以看出，投影网格的方式是对海面顶点的极致控制，它存在典型的特点：

（1） 使用固定数量的顶点生成比主摄像机当前视野稍大一点的网格，最大限度利用了顶点；

（2） 由于投影的特性，生成的网格自带近处细密，越远越稀疏的 LOD 特征。

因此，投影网格是一种非常简洁的海面生成方案。

### 总结

本文简单介绍了在移动端生成无限海面网格的几种典型方式及其具体实现，希望能对大家实际工作带来一些帮助。演示案例请从这里下载——>[Example.rar_免费高速下载 | 百度网盘 - 分享无限制 (baidu.com)](https://pan.baidu.com/s/1sQYCY4q-bl4J-F25vY5i5A?pwd=35fi)

[1] Crest: Novel ocean rendering techniques in an open source framework, SIGGRAPH 2017

Real-time water rendering Introducing the projected grid concept, Claes Johanson,2004

欢迎加入我们！

感兴趣的同学可以投递简历至：CYouEngine@cyou-inc.com