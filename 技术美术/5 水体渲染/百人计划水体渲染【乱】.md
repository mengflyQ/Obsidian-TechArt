笔记

分为物理部分和渲染部分
![[Pasted image 20230810152315.png]]

# 物理相关
![[Pasted image 20230810152344.png]]
## 1 控制方程与无散流场

### 1. 流体的描述方法

1. **朗格朗日方法：** 把流体看作一个个粒子，跟踪每个流体质点，记录物理量随时间的变化

![[2b6b54d1f21544a5455739ff0485fbf2_MD5.png]]
2. **欧拉方法：** 把流体想象成一个个固定的网格（形状不变，但其中包含的信息会变化，可以把网格想象成一个结构体，结构体不变，但是成员变量的值会变化），给出每个时刻每个空间点上的物理量

![[1061ccebd38012aaa54bb87c17803c02_MD5.png]]

![[0234de8c423e2bd56a36823e3526ccf4_MD5.png]]

**CFD（计算流体力学） 方法：**
- 计算网格不动，求解 NS 方程：欧拉方法
- 计算网格跟踪流体质点：拉格朗日方法

### 2. 控制方程（N-S 方程）

控制方程是基于欧拉方法的，利用三大守恒定律（质量、动量、能量），将流体看作一块块区域进行。

**控制方程（即 N-S 方程）：控制体质量（动量、能量）的增加量 = 穿过控制面流入的静质量（动量、能量）**

![[Pasted image 20230810153522.png|450]]

对于一小块区域内

![[8723163208f1ddad46e5192f04f748a4_MD5.png]]
>动量 $P=mv$ 

控制体质量/动量/能量的增加=穿过控制面流入的净质量/动量/能量，就有下面的式子。

![[80a3002264a05ee292ab8bc22d07d1fa_MD5.png]]

   物理含义：通量的变化（散度）导致净通量
![[Pasted image 20230810154216.png]]
![[c69cf82899ca2fe6622a73cbcef9004b_MD5.png]]

   我们就可以得到最终的控制方程（N-S方程）

   方程的含义：质量/动量/能量的变化=外接输入的净质量/动量/能量

   对于下图的理解可以横着看第一排，就是表示质量的等式。实际上就是将前文提到的式子改写成矩阵形式

![[a1de755689fe983822aec72f906842dc_MD5.png]]

对于X轴进行物理含义说明 单位时间内流经x轴单位面积屏幕的无粘流通量F1（U）

![[a1de755689fe983822aec72f906842dc_MD5.png]]

单位时间内流经垂直于x轴单位面积平面的粘性流通量G1（U）

![[e05cde62e921deb49cf63f6eca4db52b_MD5.png]]

**无量纲**：例如1m和120cm 将他们的m和cm去掉，化作1和1.2或100和120就叫无量钢化，其中最后选取的参考量m或者cm为就叫特征量。

NS方程和储藏间的无量纲形式如下

![[d3c3278fe41b1072d55aa996de3dcf33_MD5.png]]

### 雷诺数
![[Pasted image 20230810154638.png]]
前面方程中一些系数影响着流体性质，将这些系数单独拿出来就有了雷诺数

因为Re的特征量是我们自己选的 所以最后Re的数值可能有较大差异但表示同一个情况

所以在对比雷诺数的时候，要没明确特征速度和特征尺度

- 当层流（流动平缓，各个层不容易交换）时候，Re 就较小。
- 当湍流（流动距离，各个层很容易交换）时候，Re 就较大层流到湍流的过渡，就是 Re 增大的过程（即 Re 到达一定量就会形成湍流）。

![[a4a0c76cc8a662c186c9f27a5651c1e7_MD5.png]]

其中卡门涡街就是Re变化导致

![[9ec0f92902d7c47d1e4a41805ab52d6a_MD5.png]]

### N-S 方程的简化（无散流场）
![[Pasted image 20230810155206.png]]


## 2 工具
### 卷积

**系统**：系统本身也就相当于一个函数，将一个函数映射到另一个函数
![[Pasted image 20230810160117.png]]
- **阶跃函数（有一个突变点）**
- **冲激函数（阶跃函数的导数，在突破点导数是无穷大，所以只能用一个箭头表示，冲激函数的面积为 1）**

![[2133c564f0c48b7b94be8d1b2140a207_MD5.png|470]]

- **冲激响应** 当系统的输入函数为冲激函数，那么他输出函数就为冲激响应
![[Pasted image 20230810160054.png]]
- **卷积的作用**：将输入函数和冲激响应进行卷积就可以得到输出函数
![[Pasted image 20230810160224.png]]


### 傅里叶变换与拉氏变换

#### **系统的时域分析**

**描述一个连续系统**：连续系统输入输出函数就可以用两个微分形式表示，求解系统的表达式=解微分方程

![[Pasted image 20230810160411.png]]

**描述一个离散系统**：离散系统相较于上面就是**把微分改为了差分**,求解系统表达式=解差分方程

![[a979e7115124f6419dbf6f6dfb12fe1d_MD5.png]]

**连续系统的频域分析**：对于一个函数 $f(t)$写成基础函数的求和的形式

![[d467cac66fa9b86875a86e8e6e063630_MD5.png]]

其中Fn为下式（T为周期）

![[9f1801d5b52d5b5a734c8b00b87d30b9_MD5.png]]

当函数为非周期性，就可以认为T趋向无穷大，就可以将有T的地方换为无穷大，就得到了傅里叶变换.通过傅里叶变换就可以把时域函数f(t)映射到频域函数F（jω）

![[44fa7a000bde643c731cd7b72eda61b4_MD5.png]]


c.**连续系统的 S 域分析**：傅里叶变换有一个局限，当 f 这个函数在积分下不收敛的时候就没有傅里叶变换，这个时候就可以乘一个收敛因子让其收敛，乘完之后的就叫拉式变换

![[b7566abc6eaca6a1965881d5b744583c_MD5.png]]

### Z变换与DFT
![[Pasted image 20230810160757.png|350]]
a.离散系统的z域分析

![[2a6e20065d1d3794169a58c5be2ba611_MD5.png]]

实现了拉氏变换的离散化

### DFT离散傅里叶变换

傅里叶变化中，如果时域为离散的，那么频域就是周期的。 如果时域为周期的，频域就是离散的。

![[6593ba2cc414dd0d73ba4f2dc85abe13_MD5.png]]

但计算机只能处理离散数据，所以我们想要把离散的提出来，让他时域和频域都离散

![[e6307a2e0f615f5e96f86ccef4370c25_MD5.png]]

对DFT的任何处理都是先把序列值周期延拓后再作响应处理，然后取主值序列后，处理的结果都隐含周期性，即在DFT讨论中，有限长序列都是作为周期序列的一个周期表示。

（5）工具-FFT ,IFFT

FFT:快速傅里叶变换就是一个快速计算DFT的算法。

利用W的共轭对称性，周期性，可约性，可以将DFT运算中的一些项进行合并，将长序列DFT分解为段系列DFT

快速傅里叶变换算法分两大类DIT和DIF

下面分析按时间抽取（DIT）的基-2FFT算法

a.算法原理

1. 基-2FFT:N为2的整数次幂的FFT N=2
2. 对于N长序列x（n）按n的奇偶把x（n）分解为两个N/2点的子序列

![[b3cffeea9f63be1d67f38f2b047b8708_MD5.png]]

b. 计算过程

![[b145ac93e8088375218259330f57b666_MD5.png]]

其中X1（k）为偶数，X2（K）为奇数，W为旋转因子

![[9b6bdb035a39b60c67c7c5068ad0c5ab_MD5.png]]

![[41a55bc397ca28e5d3ea95b9195fb7d5_MD5.png]]

当不足2的次幂时，就需要补0（对结果吴映香），否则无法使用

接下来点接着拆成2点

c. 倒位序 为了分开奇偶，可以使用倒位序的实现：通过变址运算实现。

![[e6b240744ac6d5b79d16e67e35cddc0a_MD5.png]]

（6）应用-FFT

a.FFT解泊松方程

1.构建泊松方程

2.将泊松方程的过程华为解线性系统 3.使用FFT解线性系统

![[ae402d814383ca656f5c5c67ca714bba_MD5.png]]

b.FFT海洋模拟

![[e5a08d5dfd1e0cff295861d19be8364d_MD5.png]]

h（x,t）是波浪的高度（wavehegiht），其中x是位置

![[070300a59b256bbfa42c70fd1d098c2d_MD5.png]]

Ph(k)表示WaveSpectrum，有很多种，常用于模拟风造成波浪的是PhillipsSpectrum

（7）应用-拉格朗日/欧拉方法

![[f5bf133a9c8774d4c6aacdb4373e4c65_MD5.png]]

对于之前式子的求解，我们将其拆为两部分

![[e7b6742bc5c37e2102898f3dac9e54d5_MD5.png]]

advection表示一个粒子随波逐流，他流到哪里是不受限制的

projection就是把它拽回来

拉格朗日方法比较擅长做advection，做projection时候需要把周围的粒子加权求和来做

欧拉方法做advection就比较复杂，在projection时候就很方法，直接查周围格子

对于我们要解的泊松方程，他的边界条件

例如对于一杯水，他的上边界接触空气压强已知，边界条件叫做Dirichlet condition

他的左右碰到杯壁，压强是未知的，边界条件叫做Neumann condition

# 2.渲染
![[Pasted image 20230810162004.png]]

## LOD

1. **GeometryClipmaps**
![[Pasted image 20230810162047.png]]
水LOD与Terrain的LOD基本通用
以摄像机为中心去做 LODMesh，但注意曲面细分在手机端要 es3.2 以上（骁龙 835 以上机型）

2. **渲染性能优化**
![[Pasted image 20230810162149.png]]
水体会随着深浅有颜色变化，还有能看到水底的变化。我们可以将水体分为两部分：

第一部分是 transparent version，这部分用完整的 shader 渲染折射反射之类的，但仅用于浅水。 
第二部分是opaque version，这一部分的渲染就当做不透明处理，不进行折射或反射等处理，这样就可以在广阔的水域达到一个比较好的效果

## 高光

### Minimalist Cook-Torrance*
对于原始 original Cook-Torrance，它拥有 D,F,G 项

![[d1121b96d8badfeaed83eabaf0afe05f_MD5.png]]

**而一个简化版的 Cook-Torrance 模型 Minimalist Cook-Torrance 则有以下项**

·法线分布函数D：normalized Blinn-Phong distribution

·菲尼尔项F：Schlick approximation

·visibility项V: 是UE中的一个做法，将G项（几何函数）和原始的分母部分进行合并

·漫反射比例kd:diffuse reflectance

·镜面反射比例ks；specular reflectance 最终得到的就是

![[9fb7fb16e578e1dc5aaccaba4175c1d4_MD5.png]]

### URP
![[Pasted image 20230810162535.png]]
![[Pasted image 20230810162545.png]]
在URP中想要只输出高光，就可以手动修改InitializeBRDFData各个属性，让其只输出高光和光滑度，这样在之后的DirectBRDF函数中就能保证只输出高光

## 渲染流程

**Foam白沫**
主要思路是通过waveHeight，当它离水平面比较远的时候就标记为白沫，然后用白沫贴图混上去，实现浪尖的效果。同时也要根据水面与水底距离产生岸边白沫。

**次表面效果**

首先有一个根据深度的颜色（线性或指数都行）查找，得到一个水的基本颜色，在此的基础上再添加一个扰动颜色，并且根据waveHeight进行混合mix，达到一种体积效果

当泡沫移动时候，颜色会随着波浪和泡沫滚动而发生变化，所以可以取泡沫纹理的一个通道在深度着色和扰动着色之间混合

**法线 normal**

除了水体本身的GeometricNormal之外 还需要一个BumpedNormal去扰动表面，增加细节

**refraction 和 reflection**

通过F项（fresnel term）去混合折射refraction和反射reflection，可以在0-1均等采样一个值，当他大于frenelterm时候就让他参与反射，其余就折射。

同时水体的折射也取决于水的深度

**流动Flow 可以通过向量场（flowmap）来实现滚动法线贴图uv**

![[ecfacf022d84c9d6fbbcdb0a5e8e9f42_MD5.png]]

## 反射reflection

a.**菲涅项**

对于反射夹角越小反射越明显，可以使用菲涅项项来做，也可以使用简化的ndotv来做

b.**扰动jitter**

反射的扰动可以通过贴图扰动水面的法线来实现。

通过法线贴图的RG通道值对mesh法线x和z进行扰动

## 折射refraction和焦散caustic

**GPUGens焦散的模拟方案**

其中的一个假设为太阳在正上方，这样我们通过n向量通过折射定理计算入射光线v，

再计算v和n向量的的夹角，也就是与太阳夹角得到发射自太阳的密度

![[cdbbc266b5042a07be6ad81e35f5e2f9_MD5.png]]

**PhotonMapping模拟焦散**

常用于离线的无偏焦散，不做过多讨论

### 白沫 foam        

**白沫又分为浪尖白沫和岸边白沫**
1. **浪尖白沫**

在GPUGems2中提出的方案中，通过一个基准高度对白沫的透明度进行计算
![[Pasted image 20230810163144.png]]
   白沫纹理可以做成序列帧表示产生和消散过程，序列帧可以美术做也可以程序化生成

   再结合一个噪声图就有很真实的表现

   
**b.岸边白沫
![[Pasted image 20230810163224.png]]
 白沫的贴图可以根据密集程度分为三个贴图分别存放于 RGB 通道，并且分别通过一个 ramp 控制，这样 artist 控制效果就很方便

![[2e9c1700aa937006d11ba93b11f8884d_MD5.png]]

   这样比如取 0.1 就只有稀疏的白沫，中等和稠密几乎没有

   当取 0.8 的时候中等和稀疏完全体现，同时还有部分稠密部分



## 次表面散射

**a.BSSRDF**
![[Pasted image 20230810163329.png]]
![[02d75d43685118544355af7d43ec3c6a_MD5.png]]

主要分为两部分漫反射项和单次散射项singleScattering

![[fce5d52e7ce5aa9a07f9daf6ecbba6ad_MD5.png]]

其中漫反射项由一个反射部分和两个菲涅耳项组成

**b.基于深度的查找表**
![[Pasted image 20230810163346.png]]
根据水体的深度来改变水体的颜色达到伪次表面，同时可以在其基础上加上一个扰动

**c.快速次表面 来自于EA的一个分享**

![[1fd5028dfd8c41041c675ebe22ae1514_MD5.png]]
![[Pasted image 20230810163410.png]]
# 作业-FFT海洋

1.前置知识与环境搭建

1. computeShader在Unity中简单使用

一个简单的computeShader是如下这种形式

![[d10cb1f518e49ac4566403b19e1c7947_MD5.png]]

并且在c#中是通过如下形式调用

![[f2e94c0cab3afe44c36c4984ca4d910e_MD5.png]]

下面进行简单说明

<1>ComputeShader中至少要有一个kernel才能够被唤起。声明方法即为：#pragma kernel functionName。这样就声明了一个核函数

<2>每个核函数需要定义一个线程组（Thread Group）,他是中可以被执行的线程（Thread）总数量，格式如下：numthreads(tX, tY, tZ)

<3>在c#中Dispatch定义用多少线程组（gXgYgZ）来处理这个核函数。

<4>参数uint3 id : SV_DispatchThreadID)表示当前线程在所有线程中id 取值为（0,0,0）到（gx*tx-1，........）,除此之外还有

int3 SV_GroupID（线程组ID 000-gx-1....），

int3 SV_GroupThreadID（线程ID 000-tx-1....），

int SV_GroupIndex（线程组下标0- tx*ty*tz-1）可以传入

<5>在c#中使用时候需要先使用FindKernel找到目标核函数的下标，之后再dispath时候需要用到该下标，对于参数的传入使用.SetXXX方法就可以。

2.环境搭建

本次主要用到的文件有3个

FFTOceanCS.compute 用于计算

WaterRender.Shader      渲染shader

FFTOcean.cs 用于调用computeshader，并将结果给材质进行渲染

2.FFT物理模拟

主要步骤就是下面这张图，

1.计算海面的高度频谱

2.根据高度频谱扩展到xz方向频谱

3.进行快速傅里叶变换得到置换贴图

4.根据置换贴图得到法线泡沫等贴图

![[afa5c67155f1f4f5b4ed0e8e8340b134_MD5.png]]

下面我们会分开进行说明

1. h（x，t）与D

对于海面高度，主要公式如下

![[5e12660a0f144a60626fba35b8075f6d_MD5.png]]

<0>两个工具函数

![[6bda1f7e39fd6ff21b71a79e00adc82c_MD5.png]]

<1>高斯随机数的计算

   使用Box-Muller算法，高斯随机数可以由均匀随机数得到

   均匀随机数可以使用Xorshift算法

Xorshift需要一个随机种子，可以使用WangHash或者其他方法（忘记实际写的时候用的哪个了）

可以在cs中写出

![[942e4056fcaf1e820c7d5fe95cf02679_MD5.png]]

此时我们就得到了一张高斯随机数

![[24c74ddd46dffa17b155060192cd2d49_MD5.png]]

<2>菲利普频谱Phillips spectrum 上述公式已经非常清晰，这里就不过多说明，但注意方向函数没用公式中的，用的Donelan-Banner定向传播（这个传播函数照着抄就完了）

![[5f28f37c19f178e16366935e4b636d17_MD5.png]]

<3>高度频谱 跟着上述公式写

![[7657847d29b5516637ff2894dbddee88_MD5.png]]

可以得到如下效果

![[589722d926fff007220f831ff3be4997_MD5.png]]

<4>XZ方向 根据最开始的公式对高度频谱进行变换

![[85e1dc1a8a383aa44ba8bcdc3d25e5f6_MD5.png]]

![[64a91ee14450b8ea76c162224d2bb463_MD5.png]]

至此  我们已经集齐了三个方向的频谱

2. fft变换

对于上述公式的最后一步 需要求和k次，开销很大，所以引入了fft的计算方法

详细的原理键杨超大佬的解析https://zhuanlan.zhihu.com/p/64726720

此处只说明几个关键点 最终得到的结论就是下图，可以进行拆分之后计算

![[69b0112780c5c448a6e6aaf888abb6bc_MD5.png]]

这里注意输入的输出的顺序是反序（二进制依此首位调换）的，需要调整一下

最终得到fft变换代码如下

![[8fd00b4f57406ec326cdae03d96aa57c_MD5.png]]

![[9e32a6ec7e16e6249921e7872e04a279_MD5.png]]

得到如下结果

![[5252fb23116004d728073d8f96953778_MD5.png]]

c.计算各类贴图

<1>置换贴图 因为我们计算出来的是复数，所以在计算贴图时候取其长度（只取实部会有接缝问题）

![[79ee43de80438c6357a1b9b26b5c7037_MD5.png]]

![[ea14ff32b20fbfa8f3913eb912234d9f_MD5.png]]

<2>法线贴图

采用差分近似，取周围的8个点算出两个法线再取平均。 通过左右两点和上下两点得到两个向量，再通过叉乘得到法线方向。然后再取斜着的重复

![[7fc9ae9446349490cd7c9cb24484423e_MD5.png]]

得到的法线贴图如下

![[ea91fb61b92a967b10a4996ca9ece606_MD5.png]]

<3>泡沫贴图

可以通过雅克比行列式得到，推导见这位大佬[https://zhuanlan.zhihu.com/p/64414956](https://zhuanlan.zhihu.com/p/64414956)

![[5d474245d1024990fda1870d14a15f70_MD5.png]]

D就是我们之前求得另外两个方向的置换贴图 当发生碰撞穿刺时，面元有向面积变为负值，通过二元函数可以得到

![[5dcb88250df98cd6ea49e7cb64359ee0_MD5.png]]

最后可得下列代码

![[5d224da519364b178784b74f43c77e89_MD5.png]]

得到泡沫贴图如下

![[0e6487312847ee2124c27835019d8b85_MD5.png]]

至此 我们就集齐了所有渲染所需的贴图，准备开始进行渲染

3.Shader渲染

渲染主要被拆分为了基础色，折射，反射，焦散，泡沫

1. 置换 利用置换贴图再vert里面操作即可

![[7529d91a5bfe20d44862fa51a24c956d_MD5.png]]

![[b749ba2a53a36f11ae0805e9ae655b35_MD5.png]]

2.深度

   海水的渲染与深度脱不开关系，所以我们第一步要先拿到海水深度图

   需要把queue=transparent确保得到的cameraDepthTex正确

我们的screenPos.w就是当前平面的深度，而我们的cameraDepthTex就是场景中除去海平面的深 度，两者之差就是海水深度        因为之后折射会需要扰动，所以我这里同时也做了一个扰动之后的海水深度。

![[6d195ac284769ca252f808b2770ec54c_MD5.png]]

得到下图

![[482cb7da9a3a651d9285dfbe116e5029_MD5.png]]

3.基础色

这部分我通过深度颜色查找图+快速次表面散射的方法共同完成 首先先利用之前得到的深度对LookupTable得到海水颜色，再放入快速次表面中计算

![[8a889017d5bcdbad3ddd68879e968500_MD5.png]]

得到如下效果

![[78941e86acea9e3b71716b798811bb03_MD5.png]]

4.折射

折射部分直接使用GrabPass{_RefractionTexture}获取当前场景图

然后采样即可

![[13f4086bb6c0e4585f1b4a3d3034eeb4_MD5.png]]

5.反射

反射部分需要通过c#脚本创建一个关于水面的对称相机渲染得到反射图之后传入shader 效果如下

![[b54e398ef772ce81486023c2adc0d8d9_MD5.png]]

6.泡沫 泡沫除了我们计算出来的海洋本身的碰撞之外，还要添加上近岸的泡沫，可以通过深度图轻松实现

![[031c768a97c734ffd8f3b1bba2209b4a_MD5.png]]

![[d2af28a2b0ede00650a62cffd08ca3c6_MD5.png]]

7.焦散

![[16347b62e747bf05d56077da560a9e2c_MD5.png]]

简单来说就是计算水波法线与太阳（假设在正上）的夹角，但夹角很小（小于0.53时候）就出现焦散的效果 此处我直接用当前水波的波形，效果不是很明显，如果想要明显效果可以对于焦散使用另外单独的波形计算，或者直接加个贴图啥的

![[6ac611676c63c7a14a33dde4ba0087ae_MD5.png]]

实际效果约等于没有QAQ

![[b0a97a863a9feabb5e9364c7f0aead20_MD5.png]]

8.混合

![[4f44ab3142f8ab27e025ce9315211ed3_MD5.png]]

大功告成！

![[119e34fe2a940074fc39a7df68aef913_MD5.png]]

4.最终效果展示

![[421f2067af672b08d37b1120fafd7403_MD5.gif]]

后言：

本来想要在UE里面实现，但是太过于高贵根本用不懂，最终选择到Unity实现

这个还是有很多地方需要完善，比如网格的LOD,阴影等都没有实现，但到考试季(寄)，还要复习就先这样了。

参考资料：

https://www.bilibili.com/video/BV1Vg411o76E?p=2

https://zhuanlan.zhihu.com/p/95917609

https://zhuanlan.zhihu.com/p/31670275

https://zhuanlan.zhihu.com/p/96811613

http://dljz.nicethemes.cn/news/show-321967.html

https://zhuanlan.zhihu.com/p/60374372

https://zhuanlan.zhihu.com/p/67481306

https://blog.csdn.net/m0_66201040/article/details/123953110

https://zhuanlan.zhihu.com/p/64414956

https://zhuanlan.zhihu.com/p/64726720