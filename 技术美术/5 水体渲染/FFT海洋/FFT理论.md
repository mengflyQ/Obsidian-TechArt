---
title: FFT理论
aliases: []
tags: []
create_time: 2023-08-10 15:09
uid: 202308101509
banner: ""
---


# 1 理解空间域、频域、(逆) 傅里叶变换

>注：频域（Frequency Domain），空间域（Space Domain），时域（Time Domain）。**其中空间域和时域在数学上是一个意思，不同仅在于自变量用 x 还是 t**。图像处理领域，用空间域说法更恰当。

在这我们需要简单的了解空间域、频域、傅里叶变换和逆傅里叶变换。像我们上面说的那样，对于一个非常复杂的波形，我们可以使用非常多的正弦波叠加来逼近他。像下图所描述的那样。

![[08960014330ea3bb69124bc2d6964581_MD5.jpg]]

图截取自 Heinrich 大佬的文章 [Heinrich：傅里叶分析之掐死教程（完整版）更新于 2014.06.06](https://zhuanlan.zhihu.com/p/19763358)

空间域图像就是我们所叠加出来的波形，中间的波就是我们进行叠加的正弦波，将他们叠加起来就是空间域图像 (最后的海浪波形)。
**将这些正弦波按照频率大小依次展开，他们的振幅所形成的图像就是频域图像 (也被称为频谱)**。下面的一个动图可以更清楚的看到空间域和频域之间的关系，取自 [wiki](https://en.wikipedia.org/wiki/File:Fourier_series_and_transform.gif)

![[b6d5d5d4d7783d02ab3bbcddca93b609_MD5.gif]]

好的，知道这些有用什么用呢。其实空间域和频域之间是可以相互转换的。

- **将空间域转换成频域被称为傅里叶变换**
- **将频域转换成空间域被称为逆傅里叶变换**

聪明的我们已经察觉到了，如果我们想要实现一个复杂的波浪，我们只需要生成一个频域图像 (也被称为频谱)，然后对其进行逆傅里叶变换就可以了。

# 2  理解傅里叶变换公式

> [!NOTE] 傅里叶逆变换与海面模拟的关系
> 如果将开放海域的波浪高度看作定义在 XZ 平面上的空间域信号 $h(x,z)$ ，根据经验，这个信号天然地就很接近大量正弦信号的叠加。如果我们知道了其频谱 $\tilde{h}(\omega_{x},\omega_{z})$ ，则使用傅里叶逆变换，就可以求出 $h(x,z)$ ，即得到海面的高度场。
>
由于计算机不能处理连续或无限的事物，所以海面模拟里用的傅里叶逆变换是离散傅里叶逆变换（Inverse Discrete Fourier Transform（IDFT)）。注：周期信号的频谱必定是离散的，但未必有限。
![[8e572af1a14c01e95ef231e9068ecadc_MD5.jpg]]

在计算机中只能处理离散的点，我们所说的也都是离散的。
- 离散傅里叶变换 (Discrete Fourier Transform，缩写为 DFT)
- 逆离散傅里叶变换 (Inverse Discrete Fourier Transform, 缩写为 IDFT)
## 离散傅里叶变换 DFT
我们先来看下 DFT 的公式, 如果 $f(x)$ 为一个长度为 $N$ 的数字序列，则其 DFT $F(\mu)$ 为

$F(\mu)=\sum_{x=0}^{N-1}{f(x)}e^{-i\frac{2\pi\mu x}{N}}$

这只是第一个公式，差点就有点接受不住。先来看下每个参数的含义， $F(\mu)$ 为转换后的频域函数， $\mu$ 是**频率**。**可以看上面的图，我们将一个复杂的波形展开成多个正弦波，在将正弦波按照频率大小依次排列，频率和振幅就组成了频域图像。** 频域图像的横坐标为频率，纵坐标为振幅。

$f(x)$ 是我们空间域的函数， $e^{-i\frac{2\pi\mu x}{N}}$ 是一个复指数，i 为虚数单位。

这样还是什么都看不懂，我们将后面的复数用欧拉公式展开

$e^{ix} = cos(x) + isin(x)$

你可以看 b 站上 [如何用傅里叶级数绘制出任意图像来? 双语](https://www.bilibili.com/video/av49238862) (在 15 分钟..) 这个视频来理解欧拉公式。

$F(\mu)=\sum_{x=0}^{N-1}{f(x)}cos(\frac{2\pi\mu x}{N})-i\sum_{x=0}^{N-1}{f(x)}sin(\frac{2\pi\mu x}{N})$

啊! 看似变得更复杂了，其实并不然，这更有助于我们理解。我们需要从另一个方向切入，抛开这个公式，我们想如何将空间域转换到频域。

在此之前我们需要知道另一个比较重要的东西，**三角函数的正交性**。组成三角级数的函数系 $1,cosx,sinx,cos2x,sin2x,...,cosnx,sinnx$ ，其中任意两个不同的函数之积，在他们的公共周期内的积分等于 0

这是非常重要的，**我们想将空间域转换成频域，也就是根据空间域的函数，来计算出在频域上各个频率正弦波的振幅**。**空间域图像是由很多不同频率的正弦波叠加而成，所以我们再求某一个频率分量的振幅时需要把其他频率的波给过滤掉。**

可以构造一个检波器，称检波器 A。

![[c5d9ac6d245fb67b5425f8089b8bbdef_MD5.jpg]]

图截取自 [傅里叶变换就是这么简单，你学会了吗?](http://k.sina.com.cn/article_6367168142_17b83468e001004j89.html?sudaref=graph.qq.com&display=0&retcode=0) ，额... 本部分都截取自那....

检波器由一个乘法器和一个积分器构成，乘法器的一个输入为一个已知频率 f(我们想要求的频率) 的单位振幅正弦波 (正弦信号 f)，另一个输入为待变换信号，也就是我们的空间域。通过两个信号相乘并求积分，根据三角函数的正交性，空间域中其他频率的信号会被过滤掉，**最后只会留下和频率 f 有关的一个量，这个量等于待变换信号中 f 分量与标准正弦信号 f 的乘积的积分。**

我们还需要另一个检波器 (检波器 B), 因为我们并不知道待变换信号 (空间域)中各个分量的初始相位，因为当相位刚好差 $\pi/2$ 时, $sin(x+\frac{\pi}{2})=cos(x)$ , 以可看到频率为 1，初始相位为 $\pi/2$ 时，检波器 A 也会检测不到。所以我们还要在构造个检测余弦信号的

![[2ff60e50f9d1bdd87104fc587096464e_MD5.jpg]]

这样通过两个检波器的过滤，最后就会输出我们想要频率的分量, 检波器 A 和检波器 B 输出信号的幅值的方和根就等于频率为 f 分量的幅值。

**通过这两个检波器，我们只需要输入待变换信号 (空间域)，以及一个想要求的频率，就可以得到该频率的振幅，完成空间域到频域的转换。**

好了现在在回过头来看那个 DFT 的公式，一切都那么简单明了了。

$F(\mu)=\sum_{x=0}^{N-1}{f(x)}cos(\frac{2\pi\mu x}{N})-i\sum_{x=0}^{N-1}{f(x)}sin(\frac{2\pi\mu x}{N})$

输入想要求的频率，空间域 $f(x)$ 会进行两个检波器的检测， $\sum_{x=0}^{N-1}{f(x)}cos(\frac{2\pi\mu x}{N})$ 代表着检波器 B, 在离散处理中积分就是累加。可以看到我们到**最后得到了一个复数，复数的模就是我们想要频率的振幅**。
>由于 $e^{i\omega x}$ 是复数，所以频谱 $F (\mu)$也是复数。

你也可以看 b 站上这个视频来理解 [离散傅里叶变换零基础入门 - 中文 1（针对工科生，无需连续傅立叶变换知识）](https://www.bilibili.com/video/av44600709?from=search&seid=17408625534542082014)


## 逆离散傅里叶变换公式 IDFT
**逆离散傅里叶变换公式 IDFT, 可以由 DFT 推导得到**

$f(x)=\frac{1}{N}\sum_{\mu=0}^{N-1}{F(\mu)}e^{i\frac{2\pi\mu x}{N}}$
**频域转空间域**


# 3 FFT 海洋公式

通过上面的讲述我们应当知道了，如果我们想要得到一个复杂的海面，**我们需要生成一个频谱 (也就是上面的频域)，然后在通过逆离散傅里叶变换 (IDFT)，我们就可以得到由很多不同频率、振幅的波所叠加出来的复杂海面 (也就是上面的空间域)**。频谱直接决定了我们的海面形状，那么频谱的生成就变得尤为重要。

在这之前我们先来看下论文Simulating Ocean Water-Jerry Tessendorf 中所提到的**海洋公式**。
## 高度公式
**高度公式 $h$ 可以直接给我们返回在时间 $t$ 时， $\vec{x}$ 处的海面高度：**

$h(\vec{x},t)=\sum_{k}{\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

可以看到这个式子和我们上面公式给出的逆离散傅里叶变换那么的像，其实就是将 $\tilde{h}(\vec{k},t)$ 来进行 IDFT。

- $\vec{x}=(x,z)$ 是我们水平方向的坐标（**空间域/空间域坐标**）
- $t$ 是时间
- $\tilde{h}(\vec{k},t)$ 为频谱
    - 这里频谱 $\tilde{h}(\vec{k},t)$ 较前文多了个参数 t，表示此频谱会随时间变化，相应地高度函数 $h(\vec{x},t)$ 就也变成随时间变化的了，所以也加参数 t。
- $\vec{k}$ 为**频域坐标**，定义为 $\vec{k}=(k_{x},k_{z})=(\frac{2\pi n}{L_{x}},\frac{2\pi m}{L_{z}})$
    - $k_x, k_z$ 均为频率
    - $L_{x}$ 和 $L_{z}$ 是海平面的大小（**对应我们的 RT 大小**）
    -  $-\frac{N}{2}\leq n <\frac{N}{2}$，$-\frac{M}{2}\leq m <\frac{M}{2}$，nm（**nm 对应像素 id. xy**）
    - $N$ 和 $M$ 是我们采样离散点的数量。当然 $N$ 和 $M$ 取值越大我们得到的波形就更加细节 (叠加的波就更多)，当然计算时间也会大大的增加。
    - 求和是对所有频域坐标点 $\vec{k}$ 进行。
- 另外注意 $e^{i\vec{k}\cdot \vec{x}}$ 中 $\vec{k}$ 与 $\vec{x}$ 是点乘，即 $e^{i(k_{x}x+k_{z}z)}$ ，表示：固定 z，只让 x 变化时频率为 $k_{x}$ ；固定 x，只让 z 变化时频率为 $k_{z}$ 。

---

$\vec{k}$ 在频率平面上以原点为中心每隔 $\frac{2\pi}{L}$ （L 为海面 patch 尺寸）取一个点，共 $N\times N$ 个点：

-  $k_x=\frac{2\pi n}{L}，n \in{\{-\frac{N}{2},-\frac{N}{2}+1,...,\frac{N}{2}-1\}}$
-  $k_z=\frac{2\pi m}{L}，m \in{\{-\frac{N}{2},-\frac{N}{2}+1,...,\frac{N}{2}-1\}}$

$\vec{x}$ 在 xz 平面上以原点为中心每隔 $\frac{L}{N}$ 取一个点，也是共 $N\times N$ 个点：

-  $x=\frac{uL}{N}，u \in{\{-\frac{N}{2},-\frac{N}{2}+1,...,\frac{N}{2}-1\}}$
-  $z=\frac{vL}{N}，v \in{\{-\frac{N}{2},-\frac{N}{2}+1,...,\frac{N}{2}-1\}}$

下图红点为频域点，蓝点为空间域点：
![[3942578c6c95cd10e0b16718165be066_MD5.jpg]]

**对于游戏而言，通常取 N=64 就够用了**，即 64^2=4096 个频率点，亦即 4096 个不同频率正弦信号叠加，这个叠加数量比一般 gerstner wave 多多了，所以细节更丰富。

另外可以验证，在 N 为偶数的情况下，以上所有频率值 k 对应的周期 T= $\frac{2\pi}{k}$ 均为 L 的约数，所以 $h(\vec{x},t)=\sum_{\vec{k}}^{}{\tilde{h}(\vec{k},t)e^{i\vec{k}\cdot\vec{x}}}$ 横向和纵向均以 L 为周期，也就是说**海面 patch 是可以无缝 tiling 的**。
## 高度频谱公式

**我们只需要计算出频谱然后按照 $h(\vec{x},t)$ 函数就可以得到我们初始海面的高度（t=0 时的振幅）, 现在我们来看一下频谱公式 $\tilde{h}(\vec{k},t)$**

$\tilde{h}(\vec{k},t) =\tilde{h}_{0}(\vec{k})e^{i\omega(k)t}+\tilde{h}^{*}_{0}(-\vec{k})e^{-i\omega(k)t}$

1. $\tilde{h}^{*}_{0}$ 是 $\tilde{h}_{0}$ 的共轭复数
2.  $k$ 是 $\vec{k}$ 的模，即**波长（波的周期）**
3.  $\omega(k)$ 是角频率 $\omega$ 和波长 $k$ 的弥散 (Dispersion) 关系，这个关系取决于重力、海洋深度和其他物理参数。这里只给出了深水的关系，其他的可以去 Simulating Ocean Water 上找到
    -  $\omega^2 = gk$
    -  $\omega(k) = \sqrt{gk}$
    -  $g$ 是重力加速度 $=9.8m/sec^2$
4. $\tilde{h}_{0}(\vec{k})=\frac{1}{\sqrt{2}}(\xi_{r}+i\xi_{i})\sqrt{P_{h}(\vec{k})}$
    - $\xi_r$ 和 $\xi_i$ 是两个相互独立服从均值为 0，标准差为 1 的正态分布（高斯分布）随机数。随机数的生成方法：[[FFT相关推导#生成服从标准生成分布的随机数]]
    - $P_{h}(\vec{k})$ 是通常采用**菲利普斯频谱（Phillips spectrum）****，一般描述为 $S(\omega,\theta)$
        - 方向频谱 $S(\omega,\theta)$ 是非定向频谱 $S(\omega)$ 和方向拓展函数 $D(\omega,\theta)$ 的乘积 $S(\omega,\theta)=S(\omega)D(\omega,\theta)$
        - $\omega$ 是我们前面提到的角频率
        -  $\theta$ 是波矢量相对于风向的角度
        - 在 Simulating Ocean Water-Jerry Tessendorf 中使用到的非定向频谱为 $A\frac{e^{-1/(kL)^2}}{k^4}$ , 而方向拓展函数为 $\left| \vec{k}\cdot\vec{\omega} \right|^2$ , **他们的乘积就是** $P_{h}(\vec{k})=A\frac{e^{-1/(kL)^2}}{k^4}\left| \vec{k}\cdot\vec{\omega} \right|^2$
            - $L=\frac{V^2}{g}$ （注意，这个 L 不是上一节使用的代表海平面大小的 L）
            -  $V$ 是风速
            -  $\vec{\omega}$ 是风向
            - **在我们的实现中风向拓展函数使用的不是** $\left| \vec{k}\cdot\vec{\omega} \right|^2$ ，而是 **Donelan-Banner 定向传播**，**Donelan-Banner 方向拓展公式为**
            ![[d061062eb3c228ae4517ec9af942c048_MD5.jpg]]
            图截取自 Empirical Directional Wave Spectra for Computer Graphics，  $\omega$ 角频率
             $\theta$ 是波相对于风的角度
             $\omega_p$ 是峰值频率 $=0.855g/U$ 
             $g$ 是重力加速度
             $U$ 是平均风速。

- 非定向能量波谱 (Energy Spectrum) $S(\omega)=A\frac{e^{-1 /(k L)^2}}{k^4}$ ，由海洋统计分析得出，其描述了具有特定频率的波浪有多凶猛，与波的方向无关
- **方向扩展函数** (Directional Spread) $D(\omega, \theta)=|\vec{k} \cdot \vec{\omega}|^2$ ，体现的是风向对波最终幅值的贡献，很明显：垂直于风向的波浪几乎不易察觉，而方向与风向一致的波浪往往异常凶猛

## 水平偏移频谱公式

$\vec{D}(\vec{x},t)=\sum_{k}{-i\frac{\vec{k}}{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

可以看到这和我们的高度函数基本一样，只是我们需要把高度频谱进行改变一下。这是对 $x$ 和 $z$ 总体的描述，**我们将高度频谱拆开就可以得到对 $x$ 和 $z$ 单独的描述**

$D_x(\vec{x},t)=\sum_{k}{-i\frac{k_{x}}{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

$D_z(\vec{x},t)=\sum_{k}{-i\frac{k_{z}}{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

中间的其实就是两个复数相乘。

## 法线
用 IDFT 得到海面高度以后，用差分就可以求法线，但那样求出来的不是很精确。最精确的方法是直接推出法线的解析式。

**推导结果如下：**

空间梯度 ：$\nabla h(\vec{x},t)=\sum_{k}{i\vec{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

$\vec{N}=normalize((0,1,0)-(\nabla h_x(\vec{x},t),0,\nabla h_z(\vec{x},t)))$

$=normalize(-\nabla h_x(\vec{x},t),1,-\nabla h_z(\vec{x},t))$

[[FFT相关推导#法线的解析式推导]]


## 浪尖泡沫
泡沫的计算可以使用**雅可比列行列式**得到

在 gerstner wave 中，为了表现波峰尖角，使用下面公式在 xz 平面内进行挤压（红框中部分）：

![[46e4202e2b55209453431d647a793bbb_MD5.jpg]]
此处 IDFT 海面，同样需要类似挤压操作，公式为：

$\vec{D}(\vec{x},t)=\sum_{\vec{k}}^{}{-i\frac{\vec{k}}{k}\tilde{h}(\vec{k},t)e^{i\vec{k}\cdot\vec{x}}}$

$\vec{x}^{,}=\vec{x}+\lambda \vec{D}(\vec{x},t)$

不难看出，两者虽然写法不同，含义是一样的：**即对 sin 波进行 cos 挤压，对 cos 波进行 sin 挤压。**

**当 xz 平面内挤压过头时，就会出现刺穿（如图所示）。恰好对应浪尖破碎形成泡沫的区域。**

![[544cbe481f20abfeeedfbcd9777dea24_MD5.jpg]]

当发生刺穿时，局部发生翻转，表现在数学上，即面元有向面积变为负值。

**那么如何求面元有向面积呢？** 二重积分换元法->雅可比行列式 

推导结果如下：

$J(\vec{x})=\begin{vmatrix} J_{xx} &J_{xz} \\ J_{zx} & J_{zz} \end{vmatrix}$

$J=J_{xx}J_{zz}-J_{xz}J_{zx}$

$J_{xx}=1+\lambda\frac{\partial D_x(\vec{x},t)}{\partial x}$

$J_{zz}=1+\lambda\frac{\partial D_z(\vec{x},t)}{\partial z}$

$J_{xz}=\lambda\frac{\partial D_x(\vec{x},t)}{\partial z}=J_{zx}$

-  $J$ 为雅各比行列式
- 当 $J<0$ 时代表波浪重叠，生成泡沫。
-  $\lambda$ 是我们海洋的偏移程度 (挤压程度)，这里的偏导也可以像我们求法线那样求出。

[[FFT相关推导#浪尖泡沫推导]]

# 4 公式的计算流程

如果想要得到一个海面 (也就是空间域、海面高度、海面波形)分三步。

**生成频谱 $\rightarrow$ 逆离散傅里叶变换  $\rightarrow$ 生成高度图、渲染等**

![[081c29e7b614f0b355443056a51a1646_MD5.jpg]]

1. **首先根据高度频谱公式生成菲利普斯频谱（phillips Spectrum），这并不难直接套用公式就可以。然后在计算两个相互独立服从均值为 0，标准差为 1 的高斯分布随机数。然后根据公式结合，就完成了第一步，我们得到了一个初始的频谱 ${h}_{0}(\vec{k})$。**

这个频谱只需要计算一次就好，因为并没有时间去影响他，有的只有风。如果你的风每帧的是变动的话，那他就需要每帧计算了，但是随机数只需要计算一次就好。
游戏中我们不太可能每帧去改变风向，因此风向 $\vec{\omega}$ 也可以视作常量（由美术或策划去配置），**在这种情况下** $P_h(\vec{k})$ **的计算理论可以离线或者只在风向改变时做一次，不需要每帧去重复计算**

![[1cb3d14ab4d525fb3ef01250b0409cc5 1.png]]
**我们拿到菲利普斯频谱 ${h}_{0}(\vec{k})$ 后，就可以使用他来计算高度频谱 $\tilde{h}(\vec{k},t)$ , 使用高度频谱就可以轻易的计算出两个偏移频谱 $D_x(\vec{x},t)$ 和 $D_z(\vec{x},t)$ 。然后第一步生成频谱就结束了，是不是很简单。**

2. 当我们**拿到这些频谱后，分别对他们进行 IDFT**，就会得到水平 $x$ 、 $z$ 以及高度 $y$ 的偏移图 (注意上图中的 $z$ 为高度)。第二步就此结束。

3. 我们将拿到的图放到一起就会得到一个偏移纹理，**通过这个偏移纹理我们可以计算法线和泡沫纹理**，这样我们所有的纹理就都拿到了，接下来对其进行渲染就可以了。
   - 偏移纹理用于在顶点着色器中偏移顶点，生成波形
   - 法线贴图用于计算光照
   - 泡沫贴图用于计算泡沫

---

什么？你感觉第二步比较简单，只要进行相乘累加就可以了。确实，如果是直接进行计算的话，他并不复杂。但是那样的效率太低了。

首先我们来看直接进行计算效率为什么会非常低。首先看我们的海洋公式

$h(\vec{x},t)=\sum_{k}{\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

这是一个二维的 IDFT，对于计算二维的 IDFT 其实就是拆解成两个一维的 IDFT，首先横向进行 IDFT，然后对得到的结果进行纵向 IDFT。

我们将 $h(\vec{x},t)$ 进行展开

$h(x,z,t)=\sum_{m=-\frac{M}{2}}^{\frac{M}{2}-1}\sum_{n=-\frac{N}{2}}^{\frac{N}{2}-1}{\tilde{h}(\frac{2\pi n}{L_{x}},\frac{2\pi m}{L_{z}},t) e^{i(\frac{2\pi n}{L_{x}}x+\frac{2\pi m}{L_{z}}z)}}$

这里的展开并不难，只需要把 $\vec{x}$ 和 $\vec{k}$ 带进去就可以得到。可以看到当我们只计算一个位置的海面时，时间复杂度是 $O(NM)$ ，如果是串行计算所有位置的海面时，时间复杂度是 $O(N^2M^2)$ , 可见我们计算一个海面就要在每帧执行 $N^2M^2$ 次 for 循环，这是什么概念呢，如果我们要计算一个 512x512 的海面，我们需要执行 $512^4$ ,680 多亿次 for 循环, 电脑会被气炸的... 所以我们要优化这个算法。
# 5 FFT 推导
IDFT 如果用暴力求和的方法来计算会卡成翔，需要使用 FFT 来搞。

**快速傅里叶变换 (Fast Fourier Transform, 简称 FFT)，是计算 DFT 的快速方法，可以高度进行并行运算，而且能在 gpu 上实现。**
>注意：我们实际用的是**快速傅里叶逆变换 (IDFT)**, 然而我们一般都会说 FFT 海洋啥的，这里 FFT 主要指的是算法思想，并不是指的正变换。

## 递归形式的 FFT 算法及复杂度
对于如下标准 DFT：

$X(k)=\sum_{n=0}^{N-1}{x(n)e^{-i\frac{2\pi k}{N}n}},k\in{\{0,1,...,N-1\}}$

可以看作是 N 个输入和 N 个输出的电器元件（N point DFT calculator），如图：

![[d298c92acb3550bf819c3cf47c960fb9_MD5.jpg]]

如果直接按 DFT 定义式暴力计算，每一个输出都需要计算 N 次乘法，故 N 个输出共需乘法 $N*N$ 次，即算法复杂度为 $O (N*N)$，是比较高的。

快速傅里叶变换则是使用**分治思想**对 DFT 进行计算，可有效降低算法复杂度。
>**注：FFT 只用于计算 N 为 2 的幂的 DFT。**

考虑如何用两个 N/2 point DFT calculator 去构造出一个 N point DFT calculator（N 为 2 的幂）。
如果将序号为偶数的输入给到第一个 N/2 point DFT calculator，序号为奇数的输入给到第二个 N/2 point DFT calcuator，如下图所示：
![[d10163011519a4bcd8b6c396c47e8b72_MD5.jpg]]
则有：

$G(k)=\sum_{n=0}^{\frac{N}{2}-1}{g(n)e^{-i\frac{2\pi k}{\frac{N}{2}}n}}=\sum_{n=0}^{\frac{N}{2}-1}{x(2n)e^{-i\frac{2\pi k}{\frac{N}{2}}n}},k\in{\{0,1,...,\frac{N}{2}-1\}}$

$H(k)=\sum_{n=0}^{\frac{N}{2}-1}{h(n)e^{-i\frac{2\pi k}{\frac{N}{2}}n}}=\sum_{n=0}^{\frac{N}{2}-1}{x(2n+1)e^{-i\frac{2\pi k}{\frac{N}{2}}n}},k\in{\{0,1,...,\frac{N}{2}-1\}}$

如何用 G (k) 和 H (k) 得到 X (k) 呢？

结论是：

$X(k)=\left\{\begin{matrix} G(k)+W_{N}^kH(k) &,k\in{\{0,1,...,\frac{N}{2}-1\}} \\ G(k-\frac{N}{2})+W_{N}^kH(k-\frac{N}{2}) & ,k\in{\{\frac{N}{2},\frac{N}{2}+1,...,N-1\}} \end{matrix}\right.$

根据上面 X 与 H、G 的关系，可补全电路图如下：

![[6d847cbec5e094e4924d8765717e4400_MD5.jpg]]

至此完成了用两个 N/2 point DFT calculator 构造 N point DFT calculator。

以上就是递归形式的 FFT 算法。但递归形式一般效率不佳，尤其是不适合在 gpu 上实现，所以**经典的 FFT 算法并不是采用这种形式，而是采用展平的形式，所谓蝶形网络（见下一节）。**
无论是递归形式还是蝶形网络，算法复杂度的量级是一样的。算法复杂度为 $O(N*log_2N)$ 。

## 蝶形网络（butterfly diagram）

用上一节的递归电路计算 4 point DFT，完整展开如下图所示：

![[42c5dfc1b5db553f865d115d6393bd0d_MD5.jpg]]

简化得：

![[da56d42a6d926f9ba6992c87ae359ef7_MD5.jpg]]

此即 4 point FFT 的蝶形网络。

另外可以利用公式 $W_{N}^{k+\frac{N}{2}}=-W_N^k$ 对蝶形网络权重作如下变形：

![[65a63a5edecffd23525808aeef1eab0f_MD5.jpg]]

得：

![[4e7bbf0ee22e22e1fa188f27f8d72a7c_MD5.jpg]]

这是 4 point FFT 蝶形网络的另一种形式。

类似的，8 point FFT 蝶形网络（第二种形式）为：

![[cc2328b46dc54fd98d819dd0d6547aa4_MD5.jpg]]

**对于给定的 point 数，蝶形网络是固定，可预计算。在 fft 的 gpu 实现中，通常将其生成为 LUT。**

**上图中还标出了 stage。使用蝶形网络计算 FFT，是按 stage 推进的**：N 个输入经过第一个 stage 得到 N 个中间结果，再输入第二个 stage... 直至得到最终 N 个输出。N point FFT 有 $log_2N$ 个 stage。

## bitreverse（比特取反）算法

注意到蝶形网络的 N 个输入的顺序是打乱的，以 8 point 蝶形网络为例，可以看到：

x (0) 在 0 号位，x (1) 在 4 号位，x (2) 在 2 号位，x (3) 在 6 号位，x (4) 在 1 号位，x (5) 在 5 号位，x (6) 在 3 号位，x (7) 在 7 位号。

**对于一般 N point 的情况，这个顺序是否可以直接算出来呢？**

答案是肯定的，有称为 bitreverse 的算法，说：

**对于 N point 蝶形网络，求 x (k) 在几号位，只需将 k 化为 $log_2N$ 位二进制数，然后将 bit 反序，再转回十进制，所得结果即为 x (k) 所在位号。**

以 8 point 蝶形网络为例，我们求 x (3) 在几号位，将 3 化为 $log_28=3$ 位二进制数得 011，bit 反序得 110，将 110 化回十进制得 6，所以 x (3) 在 6 号位。

下面是完整列表：（图取自：[OpenStax CNX](https://cnx.org/contents/zmcmahhR@7/Decimation-in-time-DIT-Radix-2-FFT)）
![[1689fa1e1bea27448cd3fc3656a39922_MD5.jpg]]

此算法看起来很神奇，但其实是比较容易理解的。

作为事后诸葛，我估计它是这么想出来的：

![[ca4d4c422010f9f1d4d954dfbebe1c06_MD5.jpg]]

以上就是用于快速计算 DFT 的 FFT 算法。

## IFFT

回到海面模型，遗憾的是它并非 DFT 而是 IDFT，所以无法套用 FFT 算法。

不过没事儿，比较标准 DFT 和标准 IDFT 的表达式：

DFT：

$X(k)=\sum_{n=0}^{N-1}{x(n)e^{-i\frac{2\pi kn}{N}}},k\in{\{0,1,...,N-1\}}$

IDFT：

$x(n)=\frac{1}{N}\sum_{k=0}^{N-1}{X(k)e^{i\frac{2\pi kn}{N}}},n\in{\{0,1,...,N-1\}}$

我们发现，两者很像。所以，虽然无法直接套用，前者思路仍可运用于后者。

**模仿 FFT 算法推导过程重来一遍，可以得到 IFFT 算法：**

用两个 N/2 point IDFT calculator 去构造一个 N point IDFT calculator。将序号为偶数的输入给到第一个 N/2 point IDFT calculator，序号为奇数的输入给到第二个 N/2 point IDFT calcuator，如下图所示：

![[b157f55c8938c03084dd3b7b00d23bca_MD5.jpg]]

则有：

$$G(n)=\frac{1}{N}\sum_{k=0}^{\frac{N}{2}-1}{g(k)e^{i\frac{2\pi kn}{\frac{N}{2}}}}=\frac{1}{N}\sum_{k=0}^{\frac{N}{2}-1}{x(2k)e^{i\frac{2\pi kn}{\frac{N}{2}}}},n\in{\{0,1,...,\frac{N}{2}-1\}}$$
$$H(n)=\frac{1}{N}\sum_{k=0}^{\frac{N}{2}-1}{h(k)e^{i\frac{2\pi kn}{\frac{N}{2}}}}=\frac{1}{N}\sum_{k=0}^{\frac{N}{2}-1}{x(2k+1)e^{i\frac{2\pi kn}{\frac{N}{2}}}},n\in{\{0,1,...,\frac{N}{2}-1\}}$$

如何用 $G (n)$ 和 $H (n)$ 得到 $x (n)$ 呢？

与前面类似方法可推得：

$x(n)=\left\{\begin{matrix} G(n)+W_{N}^{-n}H(n) &,n\in{\{0,1,...,\frac{N}{2}-1\}} \\ G(n-\frac{N}{2})+W_{N}^{-n}H(n-\frac{N}{2}) & ,n\in{\{\frac{N}{2},\frac{N}{2}+1,...,N-1\}} \end{matrix}\right.$

于是补全电路图：

![[ad47e20c67d33b2e2d2d39ac4e862460_MD5.jpg]]

与前面相同，取 N=4 将电路彻底展开并简化，得到 4 point IFFT 蝶形网络：

![[2b09a1ef4db8a29516d63f497cf88004_MD5.jpg]]

利用公式 $W_{N}^{-n-\frac{N}{2}}=-W_N^{-n}$ 可变形为第二种形式：

![[c5380bea1e7514aa43ecc7ae6ede5c30_MD5.jpg]]

8 point IFFT 蝶形网络（第二种形式）：

![[8a9948b56f2caab9325be91e846d76b3_MD5.jpg]]

**另外，IFFT 的 bitreverse 与 FFT 相同。**

最后由于 DFT/IDFT 是线性的，所以常数因子并不会影响算法。

故适用于标准 IDFT 的 IFFT 算法：

$x(n)=\frac{1}{N}\sum_{n=0}^{N-1}{X(k)e^{i\frac{2\pi kn}{N}}},n\in{\{0,1,...,N-1\}}$

**可不加任何修改地应用于未归一化的 IDFT：**

$x(n)=\sum_{n=0}^{N-1}{X(k)e^{i\frac{2\pi kn}{N}}},n\in{\{0,1,...,N-1\}}$

**海面的 IDFT 模型更接近于后者。**

# 6  如何使用 FFT

我们现在已经知道 FFT 是怎么来的了，并且迫不及待地想使用他，那我们干怎么做呢。
![[Pasted image 20230808182016.png]]
**可以看上图，我们需要一个阶段一个阶段的计算。第一阶段将原始频谱作为输入，然后计算输出 ( $A$ 、 $B$ 、 $C$ 和 $D$ )，第一阶段全部计算完后，再开始进行第二阶段，第二阶段将第一阶段的输出作为输入进行计算，依次类推，直到把所有的阶段计算完，最后得到的就是我们想要的结果。**

我们可以看到每一个阶段计算时，他们里面都是相互独立的，并没有相互影响。以第一阶段来说$A(0,m',t)$ ， $A(1,m',t)$.... $D(1,m',t)$ ，他们之间没有任何关系，是**可以并行计算**的，再加上 GPU 强大的并行计算能力，可以上我们的效率更上一层楼。

**总结一句话就是，分阶段计算，阶段内部并行计算 (当然也可以串行计算)。**

再给出实现之前，我们还需要注意一件事。眼尖的你已经发现了，**对于上面的蝶形图。最左侧我们频谱的输入顺序是 (0,4,2,6,1,5,3,7) 是倒序输入，而输出是 (0,1,2,3,4,5,6,7) 是顺序输出**。当然如果你的输入时顺序输入，那么在输出时必然是倒序输出。这里解释一下倒序是什么，将一个十进制转换成二进制，再将二进制码位倒序，在转成十进制，得到的就是那个十进制的倒序。

![[6dbc0d8099aaeb128e55f5f2824f8a7e_MD5.jpg]]

也是截取自《精通 Visual C++ 数字图像处理典型算法及实现 (第二版)》

杨超大佬的这篇 [fft 海面模拟（二）](https://zhuanlan.zhihu.com/p/64726720)有说明产生的原因。所以这时的我们在计算时必然要进行一次倒序操作，所以**我们一般会使用 Stockham 算法，它能够顺序输入并且顺序输出，然后我们来看一下蝶形图**

![[cfb8860ada29a9ddd1356902c1fc96ba_MD5.jpg]]

接下来给出在 GPU 上并行计算的伪代码

**Stockham 算法：**
```c
FFT(x,N, m, input)
{
	Ns = pow(2,m-1);
        //计算输入索引
	index = floor(x / (Ns * 2)) * Ns + x % Ns;
        //计算权值W
	angle = 2 * PI * (x / (Ns * 2));
	w = (cos(angle),sin(angle));
        //进行复数乘法，然后相加输出
	x0 = input[index];
	x1 = input[index + N / 2];
	return x0 + compldexMultiply(x1,w);
}
```

 $N$ 和我们上面的是一样的，代表的是几点的 FFT。
  $m$ 表示的是第几阶段。
  
+对于每一个输出，他都是由两个输入复数，和一个权值 $W$ 构成。对于两个输入，我们只需要找到第一个输入的位置索引 index 就好，第二个复数的索引就是第一个索引再加 $\frac{N}{2}$ ，所以在一开始计算 index 就比较重要。原本是打算想说明白的，但是写了半天连自己都不知道在写什么，算了，只可意会不可言传。

这个是一维的，我们看看我们的二维频谱是怎么进行 FFT 的。

![[866bd10f21a9c58b09571c98f1098901_MD5.jpg]]
**我们首先计算频谱，将得到的频谱进行横向 FFT，每一个红色的箭头代表着一次一维的 FFT，将每一行做为 FFT 的输入数据，然后在进行纵向 FFT。**

