Subdividing Triangles 细分三角形

*   Create hull and domain shaders.  
    创建外壳和域着色器。
*   Subdivide triangles. 细分三角形。
*   Control how things get tessellated.  
    控制事物的镶嵌方式。

sr-annote { all: unset; }

This tutorial covers how to add support for tessellation to a custom shader. It uses the [Flat and Wireframe Shading](https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading/) tutorial as a basis.  
本教程介绍如何向自定义着色器添加对镶嵌的支持。它使用“平面和线框着色”教程作为基础。

This tutorial is made with Unity 2017.1.0.  
本教程使用Unity 2017.1.0制作。

![[e404b59c3de0457fbbff55bcbedc5427_MD5.jpg]]

If you don't have enough triangles, make some more.  
如果你没有足够的三角形，就多做一些。

## Hulls and Domains 外壳和域

Tessellation is the art of cutting things into smaller parts. In our case, we're going to subdivide triangles so we end up with smaller triangles that cover the same space.  
镶嵌是将事物切割成更小部分的艺术。在我们的例子中，我们将对三角形进行细分，从而得到覆盖相同空间的较小三角形。  
This makes it possible to add more details to geometry, though in this tutorial we'll focus on the tessellation process itself.  
这使得可以向几何体添加更多细节，尽管在本教程中，我们将重点关注镶嵌过程本身。

The GPU is capable of splitting up triangles fed to it for rendering. It does this for various reasons, for example when part of a triangle ends up clipped. We cannot control that, but there's also a tessellation stage that we are allowed to configure.  
GPU能够分割提供给它进行渲染的三角形。它这样做的原因多种多样，例如，当三角形的一部分最终被剪裁时。我们无法控制这一点，但也有一个镶嵌阶段，我们可以配置。  
This stage sits in between the vertex and the fragment shader stages. But it's not as simple as adding just one other program to our shader. We're going to need a hull program and domain program.  
此阶段位于顶点着色器阶段和片段着色器阶段之间。但这并不像在着色器中只添加一个其他程序那么简单。我们需要一个外壳程序和域程序。

![[a32eef419b107b213056724d9c44ea11_MD5.png]]

Shading with tessellation.  
带镶嵌的着色。

### Creating a Tessellation Shader  
创建镶嵌着色器

使用镶嵌时的最小着色器目标级别为4.6。如果我们不手动设置，Unity将发出警告并自动使用该级别。

### Hull Shaders 外壳着色器

与几何体着色器一样，镶嵌阶段是灵活的，可以处理三角形、四边形或等值线。我们必须告诉它必须使用什么表面，并向它提供必要的数据。这是 hull program的工作。在 `MyTessellation` 中添加一个程序，从一个不起任何作用的 void 函数开始。

```c
void MyHullProgram () {}
```

**外壳程序在曲面Patch上运行，曲面Patch作为参数传递给外壳程序。我们必须添加一个 `[InputPatch]` 参数才能实现这一点。**

```c
void MyHullProgram (InputPatch patch) {}
```

A patch is a collection of mesh vertices. Like we did for the stream parameter of the geometry function, we have to specify the data format of the vertices. We'll use the `VertexData` struct for now.  
Patch是网格顶点的集合。就像我们对几何函数的流参数所做的那样，我们必须指定顶点的数据格式。现在我们将使用 `VertexData` 结构。

```c
void MyHullProgram (InputPatch<VertexData> patch) {}
```

As we're working with triangles, each patch will contain three vertices. This amount has to be specified as a second template parameter for `[InputPatch](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=InputPatch)`.  
当我们处理三角形时，每个Patch将包含三个顶点。必须将此金额指定为 `[InputPatch]` 的第二个模板参数。

```c
void MyHullProgram (InputPatch<VertexData, 3> patch) {}
```

The job of the hull program is to pass the required vertex data to the tessellation stage. Although it is fed an entire patch, the function should output only a single vertex at a time.  
外壳程序的工作是将所需的顶点数据传递到镶嵌阶段。尽管它被提供了一个完整的Patch，但函数一次应该只输出一个顶点。  
It will get invoked once per vertex in the patch, with an additional argument that specifies which control point (vertex) it should work with. The parameter is an unsigned integer with the `**SV_OutputControlPointID**` semantic.  
它将在Patch中的每个顶点调用一次，并带有一个额外的参数，指定它应该使用的控制点（顶点）。该参数是一个具有 `**SV_OutputControlPointID**` 语义的无符号整数。

```
void MyHullProgram ( InputPatch<VertexData, 3> patch,
	uint id : SV_OutputControlPointID ) {}
```

Simply index the patch as if it were an array and return the desired element.  
只需将Patch作为数组进行索引，然后返回所需的元素。

```
VertexData MyHullProgram ( InputPatch<VertexData, 3> patch,
	uint id : SV_OutputControlPointID ) {
	return patch[id];
}
```

This looks like a functional program, so let's add a compiler directive to use it as a hull shader. Do this for all three shader passes that are involved.  
这看起来像是一个函数程序，所以让我们添加一个编译器指令，将其用作外壳着色器。对涉及的所有三个着色器过程执行此操作。

```
#pragma vertex MyVertexProgram
			#pragma fragment MyFragmentProgram
			#pragma hull MyHullProgram
			#pragma geometry MyGeometryProgram
```

This will produce a few compiler errors, complaining that we haven't configured our hull shader correctly. Like the geometry function, it needs attributes to configure it. First, we have to explicitly tell it that it's working with triangles. That's done via the `[UNITY_domain](https://learn.microsoft.com/en-us/search/?terms=UNITY_domain%20hlsl)` attribute, with _tri_ as an argument.  
这将产生一些编译器错误，抱怨我们没有正确配置外壳着色器。就像几何函数一样，它需要属性来配置它。首先，我们必须明确地告诉它它正在处理三角形。这是通过 `[UNITY_domain](https://learn.microsoft.com/en-us/search/?terms=UNITY_domain%20hlsl)` 属性完成的，其中 _tri_ 是一个参数。

```
[UNITY_domain("tri")]
VertexData MyHullProgram …
```

That's not enough. We also have to explicitly specify that we're outputting three control points per patch, one for each of the triangle's corners.  
这还不够。我们还必须明确指定每个Patch输出三个控制点，三角形的每个角都有一个控制点。

```
[UNITY_domain("tri")]
[UNITY_outputcontrolpoints(3)]
VertexData MyHullProgram …
```

When the GPU will create new triangles, it needs to know whether we want them defined clockwise or counterclockwise. Like all other triangles in Unity, they should be clockwise. This is controlled via the `[UNITY_outputtopology](https://learn.microsoft.com/en-us/search/?terms=UNITY_outputtopology%20hlsl)` attribute. Its argument should be _triangle_cw_.  
当GPU将创建新的三角形时，它需要知道我们是希望顺时针还是逆时针定义它们。像Unity中的所有其他三角形一样，它们应该是顺时针的。这是通过 `[UNITY_outputtopology](https://learn.microsoft.com/en-us/search/?terms=UNITY_outputtopology%20hlsl)` 属性控制的。它的参数应该是 _triangle_cw_ 。

```
[UNITY_domain("tri")]
[UNITY_outputcontrolpoints(3)]
[UNITY_outputtopology("triangle_cw")]
VertexData MyHullProgram …
```

The GPU also needs to be told how it should cut up the patch, via the `[UNITY_partitioning](https://learn.microsoft.com/en-us/search/?terms=UNITY_partitioning%20hlsl)` attribute. There are a few different partitioning methods, which we'll investigate later. For now, just use the _integer_ mode.  
GPU还需要通过 `[UNITY_partitioning](https://learn.microsoft.com/en-us/search/?terms=UNITY_partitioning%20hlsl)` 属性被告知应该如何切割Patch。有几种不同的分区方法，我们稍后将对此进行研究。现在，只需使用 _integer_ 模式。

```
[UNITY_domain("tri")]
[UNITY_outputcontrolpoints(3)]
[UNITY_outputtopology("triangle_cw")]
[UNITY_partitioning("integer")]
VertexData MyHullProgram …
```

Besides the partitioning method, the GPU also has to know into how many parts the patch should be cut. This isn't a constant value, it can vary per patch. We have to provide a function to evaluate this, known as a patch constant function.  
除了分区方法，GPU还必须知道Patch应该切割多少部分。这不是一个恒定的值，它可以随Patch而变化。我们必须提供一个函数来评估这一点，称为Patch常数函数。  
Let's just assume we have such a function, named _MyPatchConstantFunction_.  
让我们假设我们有这样一个函数，名为 _MyPatchConstantFunction_ 。

```
[UNITY_domain("tri")]
[UNITY_outputcontrolpoints(3)]
[UNITY_outputtopology("triangle_cw")]
[UNITY_partitioning("integer")]
[UNITY_patchconstantfunc("MyPatchConstantFunction")]
VertexData MyHullProgram …
```

### Patch Constant Functions  
Patch常数函数

How a patch is to be subdivided is a property of the patch. This means that the patch constant function is only invoked once per patch, not once per control point. That's why it's referred to as a constant function, being constant across the entire patch.  
如何细分Patch是Patch的一个特性。这意味着每个Patch只调用一次Patch常量函数，而不是每个控制点调用一次。这就是为什么它被称为常数函数，在整个Patch中都是常数。  
Effectively, this function is a sub-stage operating in parallel with `MyHullProgram`.  
实际上，此功能是与 `MyHullProgram` 并行操作的子阶段。

![[5dd0c39f08ea9d9f67a3bf4eb2be03b4_MD5.png]]

Inside a hull shader.  
外壳着色器内部。

To determine how to subdivide a triangle, the GPU uses four tessellation factors. Each edge of the triangle patch gets a factor. There's also a factor for the inside of the triangle. The three edge vectors have to be passed along as a float array with the `**SV_TessFactor**` semantic. The inside factor uses the `**SV_InsideTessFactor**` semantic. Let's create a struct for that.  
为了确定如何细分三角形，GPU使用四个细分因子。三角形Patch的每条边都有一个因子。三角形内部也有一个因素。这三个边缘向量必须作为一个具有 `**SV_TessFactor**` 语义的浮点数组传递。内部因素使用 `**SV_InsideTessFactor**` 语义。让我们为它创建一个结构。

```
struct TessellationFactors {
    float edge[3] : SV_TessFactor;
    float inside : SV_InsideTessFactor;
};
```

The patch constant function takes a patch as an input parameter and outputs the tessellation factors. Let's now create this missing function. Simply have it set all factors to 1. This will instruct the tessellation stage to not subdivide the patch.  
Patch常数函数将Patch作为输入参数并输出细分因子。现在让我们创建这个缺失的函数。只需将所有因子设置为1即可。这将指示镶嵌阶段不要细分Patch。

```
TessellationFactors MyPatchConstantFunction (InputPatch<VertexData, 3> patch) {
	TessellationFactors f;
    f.edge[0] = 1;
    f.edge[1] = 1;
    f.edge[2] = 1;
	f.inside = 1;
	return f;
}
```

### Domain Shaders 域着色器

At this point, the shader compiler will complain that a shader cannot have a tessellation control shader without a tessellation evaluation shader. The hull shader is only part of what we need to get tessellation working.  
此时，着色器编译器将抱怨着色器在没有镶嵌评估着色器的情况下无法具有镶嵌控制着色器。外壳着色器只是我们使镶嵌工作所需的一部分。  
Once the tessellation stage has determined how the patch should be subdivided, it's up to the geometry shader to evaluate the result and generate the vertices of the final triangles. So let's create a function for our domain shader, again starting with a stub.  
一旦镶嵌阶段确定了应该如何细分Patch，就由几何体着色器来评估结果并生成最终三角形的顶点。因此，让我们为域着色器创建一个函数，再次从存根开始。

```
void MyDomainProgram () {}
```

Both the hull and domain shader act on the same domain, which is a triangle. We signal this again via the `[UNITY_domain](https://learn.microsoft.com/en-us/search/?terms=UNITY_domain%20hlsl)` attribute.  
外壳和域着色器都作用于同一个域，即三角形。我们通过 `[UNITY_domain](https://learn.microsoft.com/en-us/search/?terms=UNITY_domain%20hlsl)` 属性再次发出信号。

```
[UNITY_domain("tri")]
void MyDomainProgram () {}
```

The domain program is fed the tessellation factors that were used, as well as the original patch, which is of type `[OutputPatch](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=OutputPatch)` in this case.  
域程序被提供了所使用的镶嵌因子，以及原始Patch，在本例中为 `[OutputPatch](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=OutputPatch)` 类型。

```
[UNITY_domain("tri")]
void MyDomainProgram ( TessellationFactors factors,
	OutputPatch<VertexData, 3> patch ) {}
```

While the tessellation stage determines how the patch should be subdivided, it doesn't generated any new vertices. Instead, it comes up with barycentric coordinates for those vertices. It's up to the domain shader to use those coordinates to derive the final vertices.  
虽然镶嵌阶段决定了应如何细分Patch，但它不会生成任何新的顶点。相反，它会为这些顶点提供重心坐标。由域着色器使用这些坐标来导出最终顶点。  
To make this possible, the domain function is invoked once per vertex and is provided the barycentric coordinates for it. They have the `**SV_DomainLocation**` semantic.  
为了实现这一点，域函数在每个顶点调用一次，并为其提供重心坐标。它们具有 `**SV_DomainLocation**` 语义。

```
[UNITY_domain("tri")]
void MyDomainProgram ( TessellationFactors factors,
	OutputPatch<VertexData, 3> patch,
	float3 barycentricCoordinates : SV_DomainLocation ) {}
```

Inside the function, we have to generate the final vertex data.  
在函数内部，我们必须生成最终的顶点数据。

```
[UNITY_domain("tri")]
void MyDomainProgram ( TessellationFactors factors,
	OutputPatch<VertexData, 3> patch,
	float3 barycentricCoordinates : SV_DomainLocation ) {
	VertexData data;
}
```

To find the position of this vertex, we have to interpolate across the original triangle domain, using the barycentric coordinates. The X, Y, and Z coordinates determine the weights of the first, second, and third control points.  
为了找到这个顶点的位置，我们必须使用重心坐标在原始三角形域上进行插值。X、Y和Z坐标确定第一、第二和第三控制点的权重。

```
VertexData data;
	data.vertex =
		patch[0].vertex * barycentricCoordinates.x +
		patch[1].vertex * barycentricCoordinates.y +
		patch[2].vertex * barycentricCoordinates.z;
```

We have to interpolate all vertex data in the same way. Let's define a convenient macro for that, which can be used for all vector sizes.  
我们必须以相同的方式对所有顶点数据进行插值。让我们为它定义一个方便的宏，它可以用于所有向量大小。

```
#define MY_DOMAIN_PROGRAM_INTERPOLATE(fieldName) data.fieldName = \
		patch[0].fieldName * barycentricCoordinates.x + \
		patch[1].fieldName * barycentricCoordinates.y + \
		patch[2].fieldName * barycentricCoordinates.z;

	MY_DOMAIN_PROGRAM_INTERPOLATE(vertex)
```

Besides the position, also interpolate the normal, tangent, and all UV coordinates.  
除了位置之外，还要对法线、切线和所有UV坐标进行插值。

```
MY_DOMAIN_PROGRAM_INTERPOLATE(vertex)
	MY_DOMAIN_PROGRAM_INTERPOLATE(normal)
	MY_DOMAIN_PROGRAM_INTERPOLATE(tangent)
	MY_DOMAIN_PROGRAM_INTERPOLATE(uv)
	MY_DOMAIN_PROGRAM_INTERPOLATE(uv1)
	MY_DOMAIN_PROGRAM_INTERPOLATE(uv2)
```

The only thing that we do not interpolate are instance IDs. As Unity does not support GPU instancing and tessellation at the same time, there's no point in copying this ID. To prevent compiler errors, remove the multi-compile directives from the three shader passes.  
我们唯一不插入的是实例ID。由于Unity不同时支持GPU实例化和镶嵌，因此复制此ID没有意义。为了防止编译器错误，请从三个着色器过程中删除多编译指令。  
This wil also remove the instancing option from the shader's GUI.  
这也将从着色器的GUI中删除实例化选项。

We now have a new vertex, which will be send to either the geometry program or the interpolator after this stage. But these programs expect `**InterpolatorsVertex**` data, not `**VertexData**`. To solve this, we have the domain shader take over the responsibilities of the original vertex program. This is done by invoking `MyVertexProgram` inside it—like any other function—and return its result.  
我们现在有了一个新的顶点，在这个阶段之后，它将被发送到几何程序或插值器。但这些程序需要 `**InterpolatorsVertex**` 数据，而不是 `**VertexData**` 数据。为了解决这个问题，我们让域着色器接管原始顶点程序的职责。这是通过调用它内部的 `MyVertexProgram` 来完成的——就像任何其他函数一样——并返回其结果。

```
[UNITY_domain("tri")]
InterpolatorsVertex MyDomainProgram ( TessellationFactors factors,
	OutputPatch<VertexData, 3> patch,
	float3 barycentricCoordinates : SV_DomainLocation ) {
	…
	
	return MyVertexProgram(data);
}
```

Now we can add the domain shader to our three shader passes, but we'll still get errors.  
现在我们可以将域着色器添加到我们的三个着色器过程中，但仍然会出现错误。

```
#pragma hull MyHullProgram
			#pragma domain MyDomainProgram
```

### Control Points 控制点

`MyVertexProgram` only has to be invoked once, it's just that we changed where this happens. But we still have to specify a vertex program to be invoked during the vertex shader stage, which sits before the hull shader.  
`MyVertexProgram` 只需要调用一次，只是我们更改了发生这种情况的位置。但是，我们仍然需要指定一个顶点程序，以便在顶点着色器阶段调用，该程序位于外壳着色器之前。  
We don't have to do anything at that point, so we can make do with a function that simply passes through the vertex data unmodified.  
在这一点上，我们不必做任何事情，所以我们可以使用一个简单地不修改地通过顶点数据的函数。

```
VertexData MyTessellationVertexProgram (VertexData v) {
	return v;
}
```

Have our three shader passes use this function for its vertex program from now on.  
从现在起，让我们的三个着色器过程为其顶点程序使用此函数。

```
#pragma vertex MyTessellationVertexProgram
```

This will produce yet another compiler error, complaining about a reuse of the position semantic. To make this work, we have to use an alternative output struct for our vertex program, which uses the `**INTERNALTESSPOS**` semantic for the vertex position. The rest of the struct is the same as `**VertexData**`, except that it never has an instance ID. As this vertex data is used as control points for the tessellation process, let's name it `**TessellationControlPoint**`.  
这将产生另一个编译器错误，抱怨位置语义的重用。为了实现这一点，我们必须为顶点程序使用另一个输出结构，该结构使用 `**INTERNALTESSPOS**` 语义表示顶点位置。结构的其余部分与 `**VertexData**` 相同，只是它从来没有实例ID。由于此顶点数据用作镶嵌过程的控制点，因此将其命名为 `**TessellationControlPoint**` 。

```
struct TessellationControlPoint {
	float4 vertex : INTERNALTESSPOS;
	float3 normal : NORMAL;
	float4 tangent : TANGENT;
	float2 uv : TEXCOORD0;
	float2 uv1 : TEXCOORD1;
	float2 uv2 : TEXCOORD2;
};
```

Change `MyTessellationVertexProgram` so it puts the vertex data into a control point struct and returns that.  
更改 `MyTessellationVertexProgram` ，使其将顶点数据放入控制点结构并返回。

```
TessellationControlPoint MyTessellationVertexProgram (VertexData v) {
	TessellationControlPoint p;
	p.vertex = v.vertex;
	p.normal = v.normal;
	p.tangent = v.tangent;
	p.uv = v.uv;
	p.uv1 = v.uv1;
	p.uv2 = v.uv2;
	return p;
}
```

Next, `MyHullProgram` must also change so it works with `**TessellationControlPoint**` instead of `**VertexData**`. Only its parameter type needs to change.  
接下来， `MyHullProgram` 也必须更改，以便与 `**TessellationControlPoint**` 而不是 `**VertexData**` 一起使用。只有其参数类型需要更改。

```
TessellationControlPoint MyHullProgram ( InputPatch<TessellationControlPoint, 3> patch,
	uint id : SV_OutputControlPointID ) {
	return patch[id];
}
```

The same goes for the patch constant function.  
Patch常数函数也是如此。

```
TessellationFactors MyPatchConstantFunction (
	InputPatch<TessellationControlPoint, 3> patch
) {
	…
}
```

And the domain program's parameter type has to change as well.  
域程序的参数类型也必须更改。

```
InterpolatorsVertex MyDomainProgram (
	TessellationFactors factors,
	OutputPatch<TessellationControlPoint, 3> patch,
	float3 barycentricCoordinates : SV_DomainLocation
) {
	…
}
```

At this point we finally have a correct tessellation shader. It should compile and render the quad as before. It isn't subdivided yet, because the tessellation factors are always 1.  
在这一点上，我们终于有了一个正确的镶嵌着色器。它应该像以前一样编译和渲染四边形。它尚未细分，因为镶嵌因子始终为1。

[unitypackage 单位包装](https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/hulls-and-domains/hulls-and-domains.unitypackage)

## Subdividing Triangles 细分三角形

The point of the whole tessellation setup is that we can subdivide patches. This allows us to replace a single triangle with a collection of smaller triangles. We're going to do that now.  
整个镶嵌设置的要点是我们可以细分Patch。这允许我们用一组较小的三角形来替换单个三角形。我们现在就要这么做。

### Tessellation Factors 细分因子

How a triangle patch gets subdivided is controlled by its tessellation factors. We determine these factors in `MyPatchConstantFunction`. Currently, we have them all set to 1, which produces no visual change. The hull, tessellation, and domain shader stages are working, but they're passing though the original vertex data and generate nothing new. To change this, set all factors to 2.  
三角形Patch的细分方式由其镶嵌因子控制。我们在 `MyPatchConstantFunction` 中确定了这些因素。目前，我们将它们都设置为1，这不会产生视觉变化。外壳、镶嵌和域着色器阶段正在工作，但它们正在传递原始顶点数据，不会生成任何新内容。若要更改此设置，请将所有因子设置为2。

```
TessellationFactors MyPatchConstantFunction (
	InputPatch<TessellationControlPoint, 3> patch
) {
	TessellationFactors f;
    f.edge[0] = 2;
    f.edge[1] = 2;
    f.edge[2] = 2;
	f.inside = 2;
	return f;
}
```

![[691aeea6648d51bb28ab310e2b1f7eff_MD5.png]]

Tessellation factors 2. 细分因子2。

The triangles now do get subdivided. All their edges have been split into two sub-edges each, leading to three new vertices per triangle. Also, yet another vertex has been added at the center of each triangle.  
三角形现在确实被细分了。它们的所有边都被分割成两个子边，每个边导致每个三角形有三个新的顶点。此外，还在每个三角形的中心添加了另一个顶点。  
This made it possible generate two triangles per original edge, so the original triangles have been replaced by six smaller triangles each. As the quad is made of two triangles, we're now getting twelve triangles in total.  
这使得每个原始边可以生成两个三角形，因此原始三角形被替换为每个较小的六个三角形。由于四边形是由两个三角形组成的，我们现在总共得到十二个三角形。

If you set all factors to 3 instead, each edge will be split into three sub-edges. In this case, there won't be a center vertex. Instead, three vertices are added inside the original triangle, forming a smaller inner triangle.  
如果将所有因子都设置为3，则每条边将拆分为三个子边。在这种情况下，将不会有一个中心顶点。相反，在原始三角形内部添加三个顶点，形成一个较小的内部三角形。  
The outer edges will be connected to this inner triangle with triangle strips.  
外边缘将通过三角形带连接到该内三角形。

![[40b1b29107d5ae18793e9818999c67ce_MD5.png]]

Tessellation factors 3. 细分因子3。

When the tessellation factors are even, there will be a single center vertex. When they are odd, there will be a center triangle instead. If we use larger tessellation factors, we end up with multiple nested triangles.  
**当镶嵌因子为偶数时，将有一个中心顶点。当它们是奇数时，会出现一个中心三角形**。如果我们使用更大的镶嵌因子，我们最终会得到多个嵌套的三角形。  
Each step towards the center, the amount by which the triangle gets subdivided decreases by two, until we end up with either one or zero sub-edges.  
每向中心走一步，三角形被细分的量就会减少两个，直到我们最终得到一个子边或零个子边。

![[1cbeecb4fe6859fc5435493bb91f9048_MD5.png]]

![[c17d21a07b09aa443ec38494864e1d59_MD5.png]]

  

![[82d28e7d957e4475b2dbe657eae1a351_MD5.png]]

![[76f7783ab9650dc69ab52f3259cb9bce_MD5.png]]

Tessellation factors 4–7.  
细分因子4-7。

### Different Edge and Inside Factors  
不同的边缘和内部因素

How the triangles get subdivided is controlled by the inside tessellation factor. The edge factors can be used to override the amount by which their respective edges are subdivided. This only affects the original patch edges, not the generated inner triangles.  
三角形的细分方式由内部镶嵌因子控制。边因子可用于覆盖其各自边的细分量。这只会影响原始Patch边，而不会影响生成的内部三角形。  
To clearly see this, set the inside factor to 7 while keeping the edge factors 1.  
要清楚地看到这一点，请将内部因子设置为7，同时保持边缘因子1。

```
f.edge[0] = 1;
    f.edge[1] = 1;
    f.edge[2] = 1;
	f.inside = 7;
```

![[08298a1b510c692929191452d65e6346_MD5.png]]

Factor 7 inside, but 1 outside.  
因子7在里面，但1在外面。

Effectively, the triangle is tessellated using the factor 7, after which the outer ring of triangles is discarded. Each edge is then subdivided using its own factor, after which a triangle strip is generated to stitch the edge and inner triangle together.  
实际上，使用因子7对三角形进行镶嵌，然后丢弃三角形的外环。然后使用其自身的因子对每条边进行细分，然后生成一个三角形条带，将边和内三角形缝合在一起。

It is also possible for the edge factors to be greater than the inside factor. For example, set the edge factors to 7 while leaving the inside factor at 1.  
边缘因子也可能大于内部因子。例如，将边缘因子设置为7，同时将内部因子保留为1。

```
f.edge[0] = 7;
    f.edge[1] = 7;
    f.edge[2] = 7;
	f.inside = 1;
```

![[e34a6705a55aed8348274188a611e79b_MD5.png]]

Factor 1 inside, but 7 outside.  
因子1在里面，但因子7在外面。

In this case, the inside factor is forced to act as if it were 2, because otherwise no new triangles could be generated.  
在这种情况下，内部因子被强制作用为2，因为否则就无法生成新的三角形。

### Variable Factors 可变因素

Hard-coded tessellation factors aren't very useful. So let's make it configurable, starting with a single uniform factor.  
硬编码的镶嵌因子不是很有用。因此，让我们从一个统一的因素开始，使其可配置。

```
float _TessellationUniform;

…

TessellationFactors MyPatchConstantFunction (
	InputPatch<TessellationControlPoint, 3> patch
) {
	TessellationFactors f;
    f.edge[0] = _TessellationUniform;
    f.edge[1] = _TessellationUniform;
    f.edge[2] = _TessellationUniform;
	f.inside = _TessellationUniform;
	return f;
}
```

Add a property for this to our shader. Set its range to 1–64. No matter how high a factor we'd like to use, the hardware has a limit of 64 subdivisions per patch.  
将此属性添加到着色器中。将其范围设置为1–64。**无论我们想使用多高的因子，硬件每个Patch都有64个细分的限制。**

```
_TessellationUniform ("Tessellation Uniform", Range(1, 64)) = 1
```

To be able to edit this factor, add a `DoTessellation` method to `**MyLightingShaderGUI**` to display it in its own section.  
为了能够编辑此因子，请在 `**MyLightingShaderGUI**` 中添加 `DoTessellation` 方法，以在其自己的部分中显示它。

```
void DoTessellation () {
		GUILayout.Label("Tessellation", EditorStyles.boldLabel);
		EditorGUI.indentLevel += 2;
		editor.ShaderProperty(
			FindProperty("_TessellationUniform"),
			MakeLabel("Uniform")
		);
		EditorGUI.indentLevel -= 2;
	}
```

Invoke this method inside `OnGUI`, between the rendering mode and the wireframe section. Only do this if the required property exists.  
在 `OnGUI` 内部，在渲染模式和线框部分之间调用此方法。只有在所需属性存在时才执行此操作。

```
public override void OnGUI ( MaterialEditor editor, MaterialProperty[] properties ) {
		…
		DoRenderingMode();
		if (target.HasProperty("_TessellationUniform")) {
			DoTessellation();
		}
		if (target.HasProperty("_WireframeColor")) {
			DoWireframe();
		}
		…
	}
```

![[d2a30107cd36a290cf3d6c9ba44aa31e_MD5.png]]

  
 <video src="" control></video>

 

Configurable uniform tessellation.  
可配置的均匀镶嵌。

### Fractional Factors 分数因子

Even though we use a float to set the tessellation factors, we always end up with a whole number of equivalent subdivisions per edge. That's because we're using the _integer_ partitioning mode. While it is a good mode to see how tessellation works, it prevents us from smoothly transitioning between subdivision levels. Fortunately, there are also fractional partitioning modes. Let's change the mode to _fractional_odd_.  
**即使我们使用浮动来设置镶嵌因子，我们也总是在每条边上得到大量等效的细分。这是因为我们使用 `integer` 分区模式。虽然这是一个很好的模式来查看镶嵌是如何工作的，但它会阻止我们在细分级别之间平滑过渡。幸运的是，还有分数分割模式。让我们将模式更改为 `fractional_odd` 。**

```
[UNITY_domain("tri")]
[UNITY_outputcontrolpoints(3)]
[UNITY_outputtopology("triangle_cw")]
[UNITY_partitioning("fractional_odd")]
[UNITY_patchconstantfunc("MyPatchConstantFunction")]
TessellationControlPoint MyHullProgram …
```


Fractional odd partitioning.  
分数奇数分区。

When using a whole odd factor, the _fractional_odd_ partitioning mode produces the same results as the _integer_ mode. But when transitioning between odd factors, extra edge subdivisions will be split off and grow, or shrink and merge. This means edges are no longer always split in segments of equal length.  
当使用整奇数因子时， `fractional_odd` 分区模式产生与 _integer_ 模式相同的结果。但是，当在奇数因子之间转换时，多余的边细分将被拆分和增长，或者收缩和合并。这意味着边不再总是分割成相等长度的线段。  
The advantage of this approach is that transitions between subdivision levels are now smooth.  
这种方法的优点是细分级别之间的过渡现在是平滑的。

It is also possible to use the `fractional_even` mode. It works the same way, except that it is based on even factors.  
也可以使用 `fractional_even` 模式。它的工作方式是一样的，只是它是基于均匀的因素。

Fractional even partitioning.  
分数均匀分区。

The _fractional_odd_ mode is often used because it can deal with a factor of 1, while the _fractional_even_ mode is forced to use a minimum level of 2.  
_fractional_odd_ 模式经常被使用，因为它可以处理因子1，而 _fractional_even_ 模式被迫使用最小级别2。

[unitypackage 单位包装](https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/subdividing-triangles/subdividing-triangles.unitypackage)

## Tessellation Heuristics 镶嵌启发式

What are the best tessellation factors? That is the main question that you have to ask yourself when working with tessellation. There isn't a single objective answer to this question.  
最佳镶嵌因子是什么？这是在处理镶嵌时必须问自己的主要问题。这个问题没有一个客观的答案。  
In general, the best you can do is come up with some metric that acts as a heuristic that produces good results. In this tutorial, we'll support two simple approaches.  
一般来说，你能做的最好的事情就是想出一些能产生良好结果的启发式指标。在本教程中，我们将支持两种简单的方法。

### Edge Factors 边缘因素

Although tessellation factors have to be provided per edge, you don't have to base the factors on the edges directly. For example, you could determine factors per vertex, then average them per edge. Maybe the factors are stored in a texture.  
尽管必须为每条边提供镶嵌因子，但不必将因子直接基于边。例如，可以确定每个顶点的因子，然后对每条边求平均值。也许这些因素存储在一个纹理中。  
In any case, it's handy to have a separate function to determine the factor, given the two control points of an edge. Create such a function, simply returning the uniform value for now.  
在任何情况下，考虑到边的两个控制点，使用单独的函数来确定因子都很方便。创建这样一个函数，现在只需返回统一的值。

```
float TessellationEdgeFactor (
	TessellationControlPoint cp0, TessellationControlPoint cp1
) {
	return _TessellationUniform;
}
```

Use this function for the edge factors inside `MyPatchConstantFunction`.  
将此函数用于 `MyPatchConstantFunction` 内部的边缘因子。

```
TessellationFactors MyPatchConstantFunction (
	InputPatch<TessellationControlPoint, 3> patch
) {
	TessellationFactors f;
    f.edge[0] = TessellationEdgeFactor(patch[1], patch[2]);
    f.edge[1] = TessellationEdgeFactor(patch[2], patch[0]);
    f.edge[2] = TessellationEdgeFactor(patch[0], patch[1]);
	f.inside = _TessellationUniform;
	return f;
}
```

For the inside factor, we'll simply use the average of the edge factors.  
对于内部因子，我们将简单地使用边缘因子的平均值。

```
f.inside = (f.edge[0] + f.edge[1] + f.edge[2]) * (1 / 3.0);
```

### Edge Length 边缘长度

As the edge tessellation factors control how much we subdivide the edges of the original triangle, it makes sense to base this factor on the length of those edges. For example, we could specify a desired triangle edge length.  
由于边镶嵌因子控制我们对原始三角形边的细分程度，因此将该因子基于这些边的长度是有意义的。例如，我们可以指定所需的三角形边长度。  
If we end up with triangle edges longer than that, we should subdivide them by the desired length. Add a variable for that.  
如果我们最终得到的三角形边比它长，我们应该按所需的长度对它们进行细分。为此添加一个变量。

```
float _TessellationUniform;
float _TessellationEdgeLength;
```

Add a property as well. Let's use a range from 0.1 to 1, with a default of 0.5. This is in world space units.  
同时添加一个属性。让我们使用从0.1到1的范围，默认值为0.5。这是以世界空间单位表示的。

```
_TessellationUniform ("Tessellation Uniform", Range(1, 64)) = 1
		_TessellationEdgeLength ("Tessellation Edge Length", Range(0.1, 1)) = 0.5
```

We need a shader feature to make it possible to switch between uniform and edge-based tessellation. Add the required directive to all our three passes, using the __TESSELLATION_EDGE_ keyword.  
我们需要一个着色器功能，以便可以在均匀镶嵌和基于边的镶嵌之间切换。使用 __TESSELLATION_EDGE_ 关键字将必需的指令添加到我们的所有三个过程中。

```
#pragma shader_feature _TESSELLATION_EDGE
```

Next, add an enum type to `**MyLightingShaderGUI**` to represent the tessellation modes.  
接下来，将枚举类型添加到 `**MyLightingShaderGUI**` 以表示细分模式。

```
enum TessellationMode {
		Uniform, Edge
	}
```

Then adjust `DoTessellation` so it can switch between both modes, using an enum popup. It works similar to how `DoSmoothness` controls the smoothness modes. In this case, uniform is the default mode, requiring no keyword.  
然后调整 `DoTessellation` ，这样它就可以使用枚举弹出菜单在两种模式之间切换。它的工作原理类似于#1控制平滑度模式的方式。在这种情况下，uniform是默认模式，不需要关键字。

```
void DoTessellation () {
		GUILayout.Label("Tessellation", EditorStyles.boldLabel);
		EditorGUI.indentLevel += 2;

		TessellationMode mode = TessellationMode.Uniform;
		if (IsKeywordEnabled("_TESSELLATION_EDGE")) {
			mode = TessellationMode.Edge;
		}
		EditorGUI.BeginChangeCheck();
		mode = (TessellationMode)EditorGUILayout.EnumPopup(
			MakeLabel("Mode"), mode
		);
		if (EditorGUI.EndChangeCheck()) {
			RecordAction("Tessellation Mode");
			SetKeyword("_TESSELLATION_EDGE", mode == TessellationMode.Edge);
		}

		if (mode == TessellationMode.Uniform) {
			editor.ShaderProperty(
				FindProperty("_TessellationUniform"),
				MakeLabel("Uniform")
			);
		}
		else {
			editor.ShaderProperty(
				FindProperty("_TessellationEdgeLength"),
				MakeLabel("Edge Length")
			);
		}
		EditorGUI.indentLevel -= 2;
	}
```

![[624aff64815bfae3e94b02ab6eaa6897_MD5.png]]

Using edge mode. 使用边缘模式。

Now we have to adjust `TessellationEdgeFactor`. When __TESSELLATION_UNIFORM_ is defined, determine the world positions of both points, then compute the distance between them. This is the edge length in world space. The edge factor is equal to this length divided by the desired length.  
现在我们必须调整 `TessellationEdgeFactor` 。定义 __TESSELLATION_UNIFORM_ 后，确定两个点的世界位置，然后计算它们之间的距离。这是世界空间中的边长度。边缘因子等于该长度除以所需长度。

```
float TessellationEdgeFactor (
	TessellationControlPoint cp0, TessellationControlPoint cp1
) {
	#if defined(_TESSELLATION_EDGE)
		float3 p0 = mul(unity_ObjectToWorld, float4(cp0.vertex.xyz, 1)).xyz;
		float3 p1 = mul(unity_ObjectToWorld, float4(cp1.vertex.xyz, 1)).xyz;
		float edgeLength = distance(p0, p1);
		return edgeLength / _TessellationEdgeLength;
	#else
		return _TessellationUniform;
	#endif
}
```

![[911e873a2ffd65c672436f293f6afcf2_MD5.png]]

Different quad scales, same desired edge length.  
不同的四边形比例，相同的所需边长。

Because we're now using the edge length to determine an edge's tessellation factor, we can end up with different factors per edge. You can see this happen for the quad, as the diagonal edges are longer than the other edges.  
因为我们现在使用边的长度来确定边的镶嵌因子，所以我们可以为每条边使用不同的因子。在四边形中可以看到这种情况，因为对角边比其他边长。  
It also becomes obvious when using a nonuniform scale for the quad, stretching it in one dimension.  
当对四边形使用非均匀比例，将其拉伸到一个维度时，这一点也会变得明显。

![[a73f280d9af9b98eb8a6890621f0f29b_MD5.png]]

Stretched quad. 伸展式四人组。

To make this work, it is essential that patches that share an edge both end up using the same tessellation factor for that edge. Otherwise, the generated vertices won't match along that edge, which can produce visible gaps in the mesh.  
为了实现这一点，共享一条边的Patch最终都要对该边使用相同的镶嵌因子，这一点至关重要。否则，生成的顶点将不会沿着该边匹配，这可能会在网格中产生可见的间隙。  
In our case, we're using the same logic for all edges. The only difference can be the order of the control point arguments.  
在我们的例子中，我们对所有边使用相同的逻辑。唯一的区别可能是控制点参数的顺序。  
Because of floating-point limitations, this could technically produce different factors, but the difference will be so minuscule that it would be unnoticeable.  
由于浮点的限制，从技术上讲，这可能会产生不同的因素，但差异非常小，因此不会引起注意。

### Edge Length in Screen Space  
屏幕空间中的边长

While we can now control the triangle edge length in world space, this does not correspond to how they appear in screen space. The point of tessellation is to add more triangles when they are needed. So we don't want to subdivide triangles that already appear small.  
虽然我们现在可以在世界空间中控制三角形的边长，但这与它们在屏幕空间中的显示方式并不一致。镶嵌的目的是在需要时添加更多的三角形。因此，我们不想细分已经显得很小的三角形。  
So let's use the screen-space edge length instead.  
因此，让我们使用屏幕空间的边缘长度。

First, change the range of our edge length property. Instead of world units, we're going to use pixels, so a range like 5–100 makes more sense.  
首先，更改边长属性的范围。我们将使用像素，而不是世界单位，所以像5–100这样的范围更有意义。

```
_TessellationEdgeLength ("Tessellation Edge Length", Range(5, 100)) = 50
```

Replace the world-space calculations with their screen-space equivalents. To do this, the points have to be converted to clip space instead of world space.  
将世界空间计算替换为等效的屏幕空间。为此，必须将点转换为剪裁空间，而不是世界空间。  
Then their distance is determined in 2D, using their X and Y coordinates, divided by their W coordinates to project them onto the screen.  
然后，使用它们的X和Y坐标除以它们的W坐标，在2D中确定它们的距离，将它们投影到屏幕上。

```
float4 p0 = UnityObjectToClipPos(cp0.vertex);
		float4 p1 = UnityObjectToClipPos(cp1.vertex);
		float edgeLength = distance(p0.xy / p0.w, p1.xy / p1.w);
		return edgeLength / _TessellationEdgeLength;
```

Now we have a result in clip space, which is a uniform cube with size 2 that fits the display. To convert to pixels, we have to scale by the display size in pixels.  
现在我们在剪辑空间中得到了一个结果，它是一个大小为2的均匀立方体，适合显示器。要转换为像素，我们必须按像素显示大小进行缩放。  
Actually, because the display is rarely square, to get the most exact result, we should scale the X and Y coordinates separately, before determining the distance. But let's suffice with simply scaling by the screen height, to see how it looks.  
实际上，由于显示器很少是正方形的，为了获得最准确的结果，在确定距离之前，我们应该分别缩放X和Y坐标。但我们只需按屏幕高度缩放即可，看看它的外观如何。

```
return edgeLength * _ScreenParams.y / _TessellationEdgeLength;
```

![[1e7b87d69dbf65bb5f145323c8de585c_MD5.png]]

Same world size, different screen size.  
相同的世界大小，不同的屏幕大小。

Our triangle edges now get subdivided based on how large they are rendered. Position, rotation, and scale all influence this, relative to the camera. As a result, the amount of tessellation changes when things are in motion.  
我们的三角形边现在可以根据渲染的大小进行细分。相对于摄影机，位置、旋转和缩放都会影响这一点。因此，当事物处于运动状态时，镶嵌量会发生变化。

### Using the View Distance  
使用视图距离

A downside of purely relying on the visual length of edges is that edges that are long in world space can end up very small in screen space. This could lead to these edges not being subdivided at all, while other edges are subdivided a lot.  
纯粹依赖边缘的视觉长度的缺点是，在世界空间中较长的边缘在屏幕空间中可能会非常小。这可能导致这些边根本没有被细分，而其他边被细分了很多。  
This is undesirable when tessellation is used to add details up close or to generate complex silhouettes.  
当镶嵌用于近距离添加细节或生成复杂轮廓时，这是不可取的。

A different approach is to go back to using the world-space edge length, but adjust the factor based on the view distance. The further away something is, the smaller it should appear visually, thus the less tessellation it needs.  
另一种方法是返回使用世界空间边长度，但根据视图距离调整因子。东西离得越远，它在视觉上看起来就越小，因此它需要的镶嵌就越少。  
So divide the edge length by the distance between the edge and the camera. We can use the midpoint of the edge to determine this distance.  
因此，将边的长度除以边和相机之间的距离。我们可以使用边的中点来确定这个距离。

```
float3 p0 = mul(unity_ObjectToWorld, float4(cp0.vertex.xyz, 1)).xyz;
		float3 p1 = mul(unity_ObjectToWorld, float4(cp1.vertex.xyz, 1)).xyz;
		float edgeLength = distance(p0, p1);

		float3 edgeCenter = (p0 + p1) * 0.5;
		float viewDistance = distance(edgeCenter, _WorldSpaceCameraPos);

		return edgeLength / (_TessellationEdgeLength * viewDistance);
```

We can still keep tessellation dependent on the display size, by simply factoring the screen height into it and keeping our 5–100 slider range. Note that these values no longer directly correspond to display pixels.  
我们仍然可以根据显示大小保持镶嵌，只需将屏幕高度考虑在内，并保持我们的5–100滑块范围。请注意，这些值不再直接对应于显示像素。  
This is very obvious when you change the field of view of the camera, which doesn't affect tessellation at all. So this simple approach won't work well for games that use a variable field of view, for example to zoom in and out.  
当您更改摄影机的视场时，这一点非常明显，这根本不会影响镶嵌。因此，这种简单的方法对于使用可变视野的游戏来说效果不佳，例如放大和缩小。

```
return edgeLength * _ScreenParams.y /
			(_TessellationEdgeLength * viewDistance);
```

![[7d9aa83cc6ff091186e2c5b85326c1ef_MD5.png]]

Based on edge length and view distance.  
基于边长度和视图距离。

### Using the Correct Inside Factor  
使用正确的内部系数

Although tessellation might appear to work fine at this point, there is something weird going on with the inside tessellation factor. At least, this is the case when using OpenGL Core.  
虽然镶嵌在这一点上可能看起来很好，但内部镶嵌因子有一些奇怪的地方。至少，在使用OpenGL Core时会出现这种情况。  
It isn't that noticeable when using a uniform quad, but it becomes obvious when using a deformed cube.  
当使用统一四边形时，这并不明显，但当使用变形的立方体时，这会变得明显。

![[ee9dc1b671656ddace7db1adcf591642_MD5.png]]

Cube with incorrect inner factors.  
内部因素不正确的多维数据集。

In the case of a cube, the two triangles that make up a face each get a very different inside tessellation factor. The only difference between a quad and a cube face is the order in which the triangle vertices are defined.  
在立方体的情况下，组成一个面的两个三角形的内部镶嵌因子都非常不同。四边形面和立方体面之间的唯一区别是三角形顶点的定义顺序。  
Unity's default cube doesn't use a symmetrical triangle layout, while the quad does. This suggests that the order of the edges apparently influences the inside tessellation factor. However, we simply take the average of the edge factors, so their order shouldn't matter.  
Unity的默认立方体不使用对称三角形布局，而四边形则使用。这表明边的顺序显然会影响内部镶嵌因子。然而，我们只是取边缘因子的平均值，所以它们的顺序应该无关紧要。  
Something else must be going wrong.  
肯定是出了什么问题。

Let's do something seemingly nonsensical and explicitly invoke the `TessellationEdgeFactors` function again, when calculating the inside factor. Logically, this shouldn't make a difference because we just end up performing the exact same calculations twice. The shader compiler will surely optimize that.  
让我们做一些看似荒谬的事情，并在计算内部因子时再次显式调用 `TessellationEdgeFactors` 函数。从逻辑上讲，这不应该有什么不同，因为我们最终只会执行两次完全相同的计算。着色器编译器肯定会对此进行优化。

```
f.inside =
		(TessellationEdgeFactor(patch[1], patch[2]) +
		TessellationEdgeFactor(patch[2], patch[0]) +
		TessellationEdgeFactor(patch[0], patch[1])) * (1 / 3.0);
```

![[00e15607c9fb7f3b42bff604c82d86d5_MD5.png]]

Cube with correct inner factors.  
具有正确内部因素的立方体。

Apparently, it does make a difference, because both face triangles now end up using nearly the same inside factor. What's going on here?  
显然，这确实有区别，因为两个面三角形现在使用的内部因子几乎相同。这是怎么回事？

The patch constant function is invoked in parallel with the rest of the hull shader. But it can actually get more complicated than that. The shader compiler is able to parallelize the calculations of the edge factors as well. The code inside `MyPatchConstantFunction` is ripped apart and partially duplicated, replaced with a forked process that calculates the three edge factors in parallel. Once all three processes are done, their results are combined and used to calculate the inside factor.  
Patch常量函数与外壳着色器的其余部分并行调用。但事实上，它可能会变得更加复杂。着色器编译器也能够并行化边缘因子的计算。 `MyPatchConstantFunction` 内部的代码被拆开并部分复制，取而代之的是并行计算三个边缘因子的分叉过程。一旦这三个过程都完成了，它们的结果就会结合起来，用于计算内部因素。

Whether the compiler decides to fork processes or not shouldn't affect the results of our shader, only its performance. Unfortunately, there is a bug in the generated code for OpenGL Core.  
编译器是否决定分叉进程不应该影响着色器的结果，只会影响其性能。不幸的是，为OpenGL Core生成的代码中存在一个错误。  
Instead of using the three edge factors when calculating the inside factor, only the third edge factor gets used. The data is there, it's just accessing index 2 three times, instead of index 0, 1, and 2. So we always end up with an inside factor equal to the third edge factor.  
在计算内部因子时，不使用三个边缘因子，而只使用第三个边缘系数。数据就在那里，它只访问索引2三次，而不是索引0、1和2。所以我们最终总是得到一个内部因子，等于第三个边缘因子。

In the case of the patch constant function, the shader compiler prioritizes parallelization. It splits the processes as soon as possible, after which it can no longer optimize away the duplicate invocations of `TessellationEdgeFactor`. We end up with three processes that each compute the world positions of two points, the distances, and the final factors.  
在使用Patch常量函数的情况下，着色器编译器会优先考虑并行化。它会尽快拆分进程，之后就无法再优化掉 `TessellationEdgeFactor` 的重复调用。我们最终有三个过程，每个过程都计算两点的世界位置、距离和最终因子。  
Then there is also the process that calculates the inner factor, which now also has to compute the world positions of three points, plus all the distances and factors involved.  
然后还有计算内部因素的过程，现在还必须计算三个点的世界位置，加上所有涉及的距离和因素。  
As we're doing all that work for the inner factor now, it doesn't make sense to also do part of the same work separately for the edge factors.  
由于我们现在正在为内部因素做所有的工作，因此对边缘因素单独做部分相同的工作是没有意义的。

It turns out that if we calculate the world positions of the points first, followed by separate invocations of `TessellationEdgeFactor` for the edge and the inner factors, the shader compiler decides not to fork separate processes for each edge factor. We end up with a single process that computes it all. In this case, the shader compiler does optimize away the duplicate invocations of `TessellationEdgeFactor`.  
事实证明，如果我们首先计算点的世界位置，然后对边和内部因子分别调用 `TessellationEdgeFactor` ，着色器编译器会决定不对每个边因子进行单独的处理。我们最终得到的是一个计算所有内容的单一过程。在这种情况下，着色器编译器会优化掉 `TessellationEdgeFactor` 的重复调用。

```
float TessellationEdgeFactor (float3 p0, float3 p1) {
	#if defined(_TESSELLATION_EDGE)

		…
	#else
		return _TessellationUniform;
	#endif
}

TessellationFactors MyPatchConstantFunction (
	InputPatch<TessellationControlPoint, 3> patch
) {
	float3 p0 = mul(unity_ObjectToWorld, patch[0].vertex).xyz;
	float3 p1 = mul(unity_ObjectToWorld, patch[1].vertex).xyz;
	float3 p2 = mul(unity_ObjectToWorld, patch[2].vertex).xyz;
	TessellationFactors f;
    f.edge[0] = TessellationEdgeFactor(p1, p2);
    f.edge[1] = TessellationEdgeFactor(p2, p0);
    f.edge[2] = TessellationEdgeFactor(p0, p1);
	f.inside =
		(TessellationEdgeFactor(p1, p2) +
		TessellationEdgeFactor(p2, p0) +
		TessellationEdgeFactor(p0, p1)) * (1 / 3.0);
	return f;
}
```

At this point we can subdivide triangles, but we're not doing anything with that ability yet. The [Surface Displacement](https://catlikecoding.com/unity/tutorials/advanced-rendering/surface-displacement/) demonstrates how tessellation can be used to deform surfaces.  
在这一点上，我们可以细分三角形，但我们还没有用这种能力做任何事情。“曲面置换”演示了如何使用镶嵌来使曲面变形。

[unitypackage 单位包装](https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/tessellation-heuristics/tessellatino-heuristics.unitypackage) [PDF](https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/Tessellation.pdf)