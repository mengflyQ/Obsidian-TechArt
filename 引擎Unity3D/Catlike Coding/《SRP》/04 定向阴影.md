---
title: 04 定向阴影
aliases: [04 Directional Shadows]
tags: []
create_time: 2023-06-24 16:00
uid: 202306241600
banner: "[[Pasted image 20230624160021.png]]"
---


![[Pasted image 20230621104957.png]]
# 4.1 渲染阴影

Unity 支持游戏物体投射阴影到其它物体或者在自身的表面上，在画面上显示阴影效果，来提升场景的纵深感和真实感。

**确定产生阴影区域的方法就是把光源想象成一个摄像机（暂时叫做光源相机），光源相机的位置和朝向就是光源的位置和发射光线的方向**。
1. 在渲染场景之前先用光源相机对场景执行一次取景操作，**使用 LightMode 标签为 ShadowCaster 的 Pass**，把在光源相机所在角度所有可视的片元深度信息存储在一个帧缓冲区中，称为ShadowMap（Shadow Map），其本质是一张深度图。
2. 在真正渲染时把每一个待输出片元再次放到光源相机的角度下计算深度值，如果这次计算的深度值比ShadowMap的深度值要离光源相机远，就表示它落在某个阴影区域中了。Unity 就是使用的这种技术。

## 4.1.1 设置阴影

1. 在渲染阴影之前，我们需要配置一些属性，比如渲染阴影的最大距离和ShadowMap的大小。如果把摄像机看到的物体全部进行阴影的绘制，那么性能消耗极大，且ShadowMap也需要很大的尺寸。所以我们设置一个最大距离 100，ShadowMap的大小设置一组枚举，尺寸自己进行选取。先创建 Settings 子文件夹，新建 ShadowSettings 脚本，且该类设置为可序列化，然后定义这两个阴影属性。

```cs
using UnityEngine;
//阴影属性设置
[System.Serializable]
public class ShadowSettings
{
    //阴影最大距离
    [Min(0f)]
    public float maxDistance = 100f;
    //ShadowMap大小
    public enum TextureSize
    {
        _256 = 256, _512 = 512, _1024 = 1024,
        _2048 = 2048, _4096 = 4096, _8192 = 8192
    }
}
```

2. 现在只是处理定向光，后续还会支持其它光源类型，所以**每种光源应该有自己的阴影设置**。定义一个 Directional 结构体，添加一个ShadowMap大小的字段，默认尺寸为 1024，我们**将使用单个纹理包含多个ShadowMap**，所以字段命名为 atlasSize。

```cs
//定向光的阴影配置
 [System.Serializable]
 public struct Directional
 {
 
     public TextureSize atlasSize;
 }
 //默认尺寸为1024
 public Directional directional = new Directional
 {
     atlasSize = TextureSize._1024
 };
```

3. 将阴影配置字段添加到 CustomRenderPipelineAsset 脚本中，并在创建渲染管线实例时作为参数传入，再在 CustomRenderPipeline 脚本中定义一个字段跟踪该配置。

```cs
 //阴影设置
[SerializeField]
    ShadowSettings shadows = default;
    protected override RenderPipeline CreatePipeline()
    {
        return new CustomRenderPipeline(useDynamicBatching, useGPUInstancing, useSRPBatcher, shadows);
    }
```

```cs
ShadowSettings shadowSettings;
    public CustomRenderPipeline(bool useDynamicBatching, bool useGPUInstancing, bool useSRPBatcher, ShadowSettings shadowSettings) {
        this.shadowSettings = shadowSettings;
        ...
    }
```


![[Pasted image 20230621105013.png]]
4. 在 CustomRenderPipeline.Render 方法中调用每个相机的 Render 方法时把阴影配置作为参数传入。

```cs
protected override void Render(ScriptableRenderContext context, Camera[] cameras)
    {
        foreach (Camera camera in cameras)
        {
            renderer.Render(context, camera, useDynamicBatching, useGPUInstancing, shadowSettings);
        }
    }
```

5. 给 CameraRenderer.Render 方法添加一个传入参数 ShadowSettings。在调用 Cull 方法时把阴影最大距离作为参数传入。**在 Culling 方法中，通过传入的阴影最大距离和相机的远截面进行比较，将小的那个作为渲染管线的最大阴影距离**，然后 Render 方法调用 lighting.Setup() 时也将阴影配置作为参数传递，后续会进行处理。

```cs
public void Render (
        ScriptableRenderContext context, Camera camera,
        bool useDynamicBatching, bool useGPUInstancing,
        ShadowSettings shadowSettings
    ) 
    {
        …
        if (!Cull(shadowSettings.maxDistance)) 
        {
            return;
        }
 
        Setup();
    //光源数据和阴影数据发送到GPU计算光照
        lighting.Setup(context, cullingResults, shadowSettings);
        …
    }
bool Cull (float maxShadowDistance) 
{
        if (camera.TryGetCullingParameters(out ScriptableCullingParameters p)) 
        {
            //得到最大阴影距离,和相机远截面作比较，取最小的那个作为阴影距离
            p.shadowDistance = Mathf.Min(maxShadowDistance, camera.farClipPlane);
            cullingResults = context.Cull(ref p);
            return true;
        }
        return false;
}
```

6. 在 Lighting 脚本的 Setup 方法中加上阴影配置的传参，先不做处理。

```cs
public void Setup(ScriptableRenderContext context, CullingResults cullingResults,ShadowSettings shadowSettings) {
    ...
}
```

## 4.1.2 创建阴影类

阴影虽然是光照的一部分，但是内部结构相当复杂。我们**把所有阴影的处理逻辑抽离到一个单独的脚本中去**，在 Runtime 文件夹下创建 `Shadows.cs` 脚本，它的基础架构和 Lighting.cs 脚本差不多，我们复制一下代码并做一些调整。

```cs
using UnityEngine;
using UnityEngine.Rendering;

 public class Shadows
{

     const string bufferName = "Shadows";

     CommandBuffer buffer = new CommandBuffer
    {
        name = bufferName
    };

     ScriptableRenderContext context;

     CullingResults cullingResults;

     ShadowSettings settings;

     public void Setup(
        ScriptableRenderContext context, CullingResults cullingResults,
        ShadowSettings settings
    ) {
        this.context = context;
        this.cullingResults = cullingResults;
        this.settings = settings;
    }

     void ExecuteBuffer() {
        context.ExecuteCommandBuffer(buffer);
        buffer.Clear();
    }
}
```

在 Lighting 脚本中我们创建一个 Shadows 对象，在 Setup 方法中调用该对象的 Setup 方法，并传递相关数据和配置。

```cs
 Shadows shadows = new Shadows();
 public void Setup (…) 
 {
     this.cullingResults = cullingResults;
     buffer.BeginSample(bufferName);
     //传递阴影数据
     shadows.Setup(context, cullingResults, shadowSettings);
     …
 }
```

## 4.1.3 带阴影的光源

1. 由于渲染阴影也需要额外的开销，我们在 Shadows 脚本**定义一个字段来限制渲染管线中可以投影的定向光源数量**，最初设置为 1 个。因为不知道哪个可见光源会产生阴影，所以定义一个 ShadowedDirectionalLight 结构体来**追踪可见光的索引**，然后创建一个该结构体类型的数组，**存储所有能产生阴影的可见光索引**。

```cs
//可投射阴影的定向光数量
const int maxShadowedDirectionalLightCount = 1;

 struct ShadowedDirectionalLight
{
    public int visibleLightIndex;
}
//存储可投射阴影的可见光源的索引
ShadowedDirectionalLight[] ShadowedDirectionalLights = new ShadowedDirectionalLight[maxShadowedDirectionalLightCount];
```

2. 定义一个 int 字段来**追踪当前已经存储了多少个可见光的阴影数据**，并**在 Setup 方法中重置该数量**。

```cs
//已存储的可投射阴影的定向光数量
  int ShadowedDirectionalLightCount;
```

```cs
public void Setup (…) {
        …
        ShadowedDirectionalLightCount = 0;
    }
```

3. 定义 `ReserveDirectionalShadows` 方法来**存储可投影可见光的阴影数据**，**目的是在阴影图集中为该光源的ShadowMap保留空间，并存储渲染它们所需要的信息**。其中我们还需要加上一些判断，来过滤不符合要求或没有意义的可见光源。

```cs
//存储可见光的阴影数据
public void ReserveDirectionalShadows(Light light, int visibleLightIndex) 
{
    //存储可见光源的索引，前提是光源开启了阴影投射并且阴影强度不能为0 
    if (ShadowedDirectionalLightCount < maxShadowedDirectionalLightCount && light.shadows != LightShadows.None && light.shadowStrength > 0f
        //还需要加上一个判断，是否在阴影最大投射距离内，有被该光源影响且需要投影的物体存在，如果没有就不需要渲染该光源的ShadowMap了
        && 
cullingResults.GetShadowCasterBounds(visibleLightIndex,out Bounds b))
        {
            ShadowedDirectionalLights[ShadowedDirectionalLightCount++] = new ShadowedDirectionalLight{ visibleLightIndex = visibleLightIndex };
        }
}
```

4. 最后在 Lighting.SetupDirectionalLight 方法中存储该可见光源的阴影数据。

```cs
void SetupDirectionalLight(int index, ref VisibleLight visibleLight) 
    {
        ...

         shadows.ReserveDirectionalShadows(visibleLight.light, index);
    }
```

## 4.1.4 创建阴影图集

1. 在 Shadows 脚本中定义 Render 方法渲染阴影，渲染定向光阴影我们委派给 RenderDirectionalShadows 方法去做，然后在 Lighting.Setup() 方法中发送多个光源数据，最后再调用 shadows.Render()。

```cs
//阴影渲染
public void Render() {
    if (ShadowedDirectionalLightCount > 0)
    {
        RenderDirectionalShadows();
    }
 }
 
 //渲染定向光阴影
 void RenderDirectionalShadows() 
 { 
 
 }
```

```cs
public void Setup(ScriptableRenderContext context, CullingResults cullingResults,ShadowSettings shadowSettings)
 {
    ...
    //发送光源数据
    SetupLights();
 
    shadows.Render();
    ...
 }
```

2. 现在要**创建一张阴影图集**，后面会将可以投影的物体绘制到ShadowMap。**先定义一个阴影图集的着色器标识 ID**，在 RenderDirectionalShadows 方法中创建一张 RenderTexture，我们通过添加三个额外的参数（最后三个）来设置阴影图集，深度缓冲使用 32 位，尽可能的高一点。过滤模式使用双线性过滤即可，渲染纹理的类型指定为 Shadowmap，用于指定其为渲染阴影的纹理。

```cs
 static int dirShadowAtlasId = Shader.PropertyToID("_DirectionalShadowAtlas");
 
    //渲染定向光阴影
    void RenderDirectionalShadows() 
    {
        //创建renderTexture，并指定该类型是Shadowmap
        int atlasSize = (int)settings.directional.atlasSize;
        buffer.GetTemporaryRT(dirShadowAtlasId, atlasSize, atlasSize, 32, FilterMode.Bilinear, RenderTextureFormat.Shadowmap);
    }
```

3. 我们应该**在相机渲染完后释放临时渲染纹理**，在 Shadows 脚本中添加一个 Cleanup 方法来完成这个工作。

```cs
//释放临时渲染纹理
public void Cleanup() {
    buffer.ReleaseTemporaryRT(dirShadowAtlasId);
    ExecuteBuffer();
}
```

4. 在 Lighting 脚本中也添加一个 Cleanup 方法，调用 shadows.Cleanup()，然后在 CameraRenderer.Render 方法提交命令缓冲区之前调用光照的 Cleanup 方法。

```cs
 //释放ShadowMapRT内存
    public void Cleanup()
    {
        shadows.Cleanup();
    }
```

```cs
public void Render (…) {
    ...
    lighting.Cleanup();
    Submit();
}
```

5. 创建渲染纹理后调用 `buffer.SetRenderTarget` 方法来**指定渲染数据存储到渲染纹理而不是帧缓冲区中**，
    1. 该方法中后两个参数用于指定如何加载和存储渲染纹理的数据，它的初始状态我们不关心，因为会立即清除它。
    2. 渲染纹理的目的是存储阴影数据，所以使用 RenderBufferStoreAction.Store 模式。最后调用 buffer.ClearRenderTarget 方法清除渲染目标的数据，这里我们只关心深度缓冲，所以只需清除它。

```cs
void RenderDirectionalShadows() 
{
    int atlasSize = (int)settings.directional.atlasSize;
    buffer.GetTemporaryRT(dirShadowAtlasId, atlasSize, atlasSize,32, FilterMode.Bilinear, RenderTextureFormat.Shadowmap);
    //指定渲染数据存储到RT中
buffer.SetRenderTarget(dirShadowAtlasId,RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
    //清除深度缓冲区
buffer.ClearRenderTarget(true, false, Color.clear);
    ExecuteBuffer();
}
```

如果当前场景有一个定向光且启用了阴影，加上场景中有可绘制的物体，则在帧调试器中会出现一个 Shadows 条目的 Clear 操作。
![[Pasted image 20230621105027.png]]

6. 我们**还需要调整阴影渲染的时机，应在相机正式渲染场景之前渲染阴影**，所以将 CameraRender.Render 方法中的 Setup 方法的调用放在 lighting.Setup 方法之后。

```cs
lighting.Setup(context, cullingResults, shadowSettings);

Setup();

//绘制几何体
DrawVisibleGeometry(useDynamicBatching, useGPUInstancing);
```
![[Pasted image 20230621105029.png]]


7. **设置在 lighting.Setup 之前开启采样，然后在清除相机渲染之前结束采样，可以将 Shadows 条目嵌入到 MainCamera 条目中**，得到我们最终想看到的结果。

```cs
buffer.BeginSample(SampleName);
ExecuteBuffer();

lighting.Setup(context, cullingResults, shadowSettings);
buffer.EndSample(SampleName);
Setup();
```
![[Pasted image 20230621105032.png]]


## 4.1.5 渲染阴影

1. **接下来开始为单个光源渲染阴影**。在 Shadows 脚本中添加一个重载方法 `RenderDirectionalShadows(int index,int tileSize)`，第一个参数是投射阴影的灯光索引，第二个是该光源的ShadowMap在阴影图集中所占的图块大小。在 RenderDirectionalShadows 方法中遍历所有定向光进行逐光源的阴影渲染，因为现在我们只有一个定向光，所以它的图块大小等于图集大小。

```cs
//渲染定向光阴影
void RenderDirectionalShadows() 
{
    ...
    //清除深度缓冲区
    buffer.ClearRenderTarget(true, false, Color.clear);
 
    buffer.BeginSample(bufferName);
    ExecuteBuffer();
    //遍历所有定向光渲染阴影
    for (int i = 0; i < ShadowedDirectionalLightCount; i++)
    {
        RenderDirectionalShadows(i, atlasSize);
    }
 
    buffer.EndSample(bufferName);
    ExecuteBuffer();
 }
 //渲染单个光源阴影
 void RenderDirectionalShadows(int index, int tileSize)
 { 
 
 }
```

2. 然后实现该重载方法。要渲染阴影，首先要创建一个` ShadowDrawingSettings` 实例，用来**创建阴影设置对象，它需要剔除结果和可见光的索引作为构造时的参数**。

```cs
//渲染单个光源阴影
    void RenderDirectionalShadows(int index, int tileSize)
    {
        ShadowedDirectionalLight light = ShadowedDirectionalLights[index];
        var shadowSettings = new ShadowDrawingSettings(cullingResults, light.visibleLightIndex);
    }
```

1. ShadowMap 本质也是一张深度图，它记录了从光源位置出发，到能看到的场景中距离它最近的表面位置（深度信息）。但是**定向光并没有一个真实位置，我们要做地是找出与光的方向匹配的视图和投影矩阵，并给我们一个裁剪空间的立方体，该立方体与包含光源阴影的摄影机的可见区域重叠，这些数据的获取我们不用自己去实现，可以直接调用 `cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives` 方法**，它需要 9 个参数。
    1. 第 1 个是可见光的索引
    2. 第 2、3、4 个参数用于设置阴影级联数据，后面我们会处理它
    3. 第 5 个参数是 ShadowMap 的尺寸
    4. 第 6 个参数是阴影近平面偏移，我们先忽略它。
    5. 最后三个参数都是输出参数，一个是视图矩阵，一个是投影矩阵，一个是 `ShadowSplitData` 对象，它描述有关给定阴影分割（如定向级联）的剔除信息。

```cs
//渲染单个光源阴影
void RenderDirectionalShadows(int index, int tileSize)
 {
     ...

      cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(light.visibleLightIndex, 0, 1, Vector3.zero, tileSize, 0f,
     out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix,out ShadowSplitData splitData);
 }
```

4. `ShadowSplitData` 包含了如何剔除投影对象的信息，我们将其复制到阴影设置中，然后调用 buffer.SetViewProjectionMatrices 方法应用获取的视图和投影矩阵。最后执行缓冲区命令并调用 context.DrawShadows 方法渲染阴影投射。

```cs
//渲染单个光源阴影
 void RenderDirectionalShadows(int index, int tileSize)
 {
     ...
     shadowSettings.splitData = splitData;
     buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);
     ExecuteBuffer();
     context.DrawShadows(ref shadowSettings);
 }
```

## 4.1.6 ShadowCaster Pass

1. 现在可以渲染阴影投射了，但阴影图集仍然是空的。 **因为 DrawShadows 方法只渲染 Shader 中带有 ShadowCaster Pass 通道的物体**，我们在 Lit.shader 中**添加第二个 Pass 块**，可以直接复制第一个 Pass 块的代码，LightMode 改为 ShadowCaster，顶点和片元函数改个名，后续投影的实现在后面新建的 ShadowCasterPass.hlsl 文件里定义。最后，这个 Pass 只需要写入深度数据，所以添加 ColorMask 0 不写入任何颜色数据，但会进行深度测试，并将深度值写到深度缓冲区中。

```cs
Pass
    {
        Tags 
        {
            "LightMode" = "ShadowCaster"
        }
        ColorMask 0

         HLSLPROGRAM
        #pragma target 3.5
        #pragma shader_feature _CLIPPING
        #pragma multi_compile_instancing
        #pragma vertex ShadowCasterPassVertex
        #pragma fragment ShadowCasterPassFragment
        #include "ShadowCasterPass.hlsl"
        ENDHLSL
}
```

2. 复制 LitPass.hlsl，命名为 ShadowCasterPass.hlsl，删除投射阴影不需要的数据，**我们只需要顶点在裁剪空间的位置和裁剪的基础颜色，片元函数不需要返回任何值，唯一的作用就是裁剪不满足阈值片元。**

```cs
#ifndef CUSTOM_SHADOW_CASTER_PASS_INCLUDED
#define CUSTOM_SHADOW_CASTER_PASS_INCLUDED
#include "../ShaderLibrary/Common.hlsl"

 TEXTURE2D(_BaseMap);
SAMPLER(sampler_BaseMap);

 UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
//提供纹理的缩放和平移
UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)
UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)
UNITY_DEFINE_INSTANCED_PROP(float, _Cutoff)
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

 //用作顶点函数的输入参数
struct Attributes 
{
    float3 positionOS : POSITION;
    float2 baseUV : TEXCOORD0;
    UNITY_VERTEX_INPUT_INSTANCE_ID
};
//用作片元函数的输入参数
struct Varyings 
{
    float4 positionCS : SV_POSITION;
    float2 baseUV : VAR_BASE_UV;
    UNITY_VERTEX_INPUT_INSTANCE_ID
};

//顶点函数
Varyings ShadowCasterPassVertex(Attributes input)
{
    Varyings output;
    UNITY_SETUP_INSTANCE_ID(input);
    //使UnlitPassVertex输出位置和索引,并复制索引
    UNITY_TRANSFER_INSTANCE_ID(input, output);
    float3 positionWS = TransformObjectToWorld(input.positionOS);
    output.positionCS = TransformWorldToHClip(positionWS);
 
    //计算缩放和偏移后的UV坐标
    float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseMap_ST);
    output.baseUV = input.baseUV * baseST.xy + baseST.zw;
    return output;
}
//片元函数
void ShadowCasterPassFragment(Varyings input) 
{
    UNITY_SETUP_INSTANCE_ID(input);
    float4 baseMap = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.baseUV);
    // 通过UNITY_ACCESS_INSTANCED_PROP访问material属性
    float4 baseColor = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);
    float4 base = baseMap * baseColor;
#if defined(_CLIPPING)
    //透明度低于阈值的片元进行舍弃
    clip(base.a - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff));
#endif
 
}
```

3. 下面创建一个测试小场景，添加几个不透明的物体，然后使用默认的定向光源。

​![[Pasted image 20230621105041.png]]

**我们发现最终渲染的图像中物体还是没有投射阴影，但通过帧调试器可以看到场景中的深度数据已经被渲染到阴影图集中了**，可以把阴影距离先调小一点，这样可以使阴影图集中的图像尺寸占比大一点，方便观察。我们的阴影投射使用的是正交投影渲染，因为我们是为定向光进行渲染的。
![[Pasted image 20230621105047.png]]


## 4.1.7 支持多光源渲染阴影

之前我们设置最多可以支持 4 个定向光的照明，现在也支持 4 个定向光的阴影，在 Shadows 脚本中将最大投影灯光数量改为 4。

```cs
const int maxShadowedDirectionalLightCount = 4;
```

然后在场景中复制 3 个定向光，在 Y 轴的旋转上依次增加 90 度。
![[Pasted image 20230621105054.png]]


1. 尽管我们正常渲染了所有光源的阴影投射，但**我们为每盏灯渲染到整个阴影图集时，它们会叠加到一起，所以需要拆分图集，为每个光源使用自己的ShadowMap图块来渲染**。我们可以支持 4 个灯光的投影，**在图集里为每一个灯光分配一个正方形图块区域**。如果有一个以上的可投影光源，需要将图块大小减半并把图集分成 4 个图块，在 Shadows.RenderDirectionalShadows() 方法中确定需要分割几个图块和图块大小应是多少，并传递给该方法的重载方法。

```cs
void RenderDirectionalShadows () 
 {
     …
     //要分割的图块大小和数量
     int split = ShadowedDirectionalLightCount <= 1 ? 1 : 2;
     int tileSize = atlasSize / split;
 
     for (int i = 0; i < ShadowedDirectionalLightCount; i++) 
     {
         RenderDirectionalShadows(i, split, tileSize);
     }
 }
 
 void RenderDirectionalShadows (int index, int split, int tileSize) 
 {
     … 
 }
```

2. 我们通过调整渲染视口来渲染单个图块。用创建 SetTileViewport 方法，参数是图块的索引和拆分的图块数量，以及图块大小。我们计算该图块的偏移量，以图块索引 % 拆分数量为 X 轴偏移，索引 / 拆分数量为 Y 轴偏移。然后通过命令缓冲区调用 SetViewPort 方法，偏移量根据图块大小进行缩放，然后以图块大小作为该视口矩形的宽和高。

```cs
 //调整渲染视口来渲染单个图块
    void SetTileViewport(int index, int split,float tileSize)
    {
        //计算索引图块的偏移位置
        Vector2 offset = new Vector2(index % split, index / split);
        //设置渲染视口，拆分成多个图块
        buffer.SetViewport(new Rect( offset.x * tileSize, offset.y * tileSize, tileSize, tileSize ));
    }
```

3. 在 RenderDirectionalShadows(int index, int split, int tileSize) 方法中设置视图投影矩阵之前调整渲染视口。

```cs
//设置渲染视口
SetTileViewport(index, split, tileSize);
//设置视图投影矩阵
buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);
```

![](https://uwa-edu.oss-cn-beijing.aliyuncs.com/8.1620445390735.png)
![[Pasted image 20230621105104.png]]
# 4.2 采样阴影

现在我们已经渲染了ShadowMap，但还需要**对贴图进行采样才能接收物体的投影**，采样操作需要**在 Shader 的 CustomLit Pass 中完成**。

## 4.2.1 阴影转换矩阵

1. **对于每个片元，我们必须从阴影图集中对应的阴影图块采样深度数据，因此需要找到对应在世界空间的阴影纹理坐标**，可以通过为每个可投影的定向光创建阴影转换矩阵并将其发送到 GPU 来实现这点。首先在 Shadows 脚本中定义该阴影转换矩阵的着色器标识 ID 和一个存储转换矩阵的数组。

```cs
static int dirShadowMatricesId = Shader.PropertyToID("_DirectionalShadowMatrices");
    //存储阴影转换矩阵
    static Matrix4x4[] dirShadowMatrices = new Matrix4x4[maxShadowedDirectionalLightCount];
```

2. 在 RenderDirectionalShadows 方法中**通过将获得的光源的投影矩阵和视图矩阵相乘，可以创建一个从世界空间到<mark style="background: #FF5582A6;">光源裁剪空间</mark>（光源相机的视角）的转换矩阵。**

```cs
void RenderDirectionalShadows (int index, int split, int tileSize) 
{
     …
     SetTileViewport(index, split, tileSize);
     //投影矩阵乘以视图矩阵，得到从世界空间到灯光空间的转换矩阵
     dirShadowMatrices[index] = projectionMatrix * viewMatrix;
     buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);
     …
}
```

3. 当渲染完阴影后，调用 buffer.SetGlobalMatrixArray 方法将转换矩阵发送到 GPU。

```cs
void RenderDirectionalShadows () {
     …

      buffer.SetGlobalMatrixArray(dirShadowMatricesId, dirShadowMatrices);
     buffer.EndSample(bufferName);
     ExecuteBuffer();
}
```

4. 因为我们使用的是阴影图集，它可能包含多个 ShadowMap 图块，所以需要创建一个 ConvertToAtlasMatrix 方法来传入世界空间到灯光空间的转换矩阵、图块偏移和图块拆分数，最终得到一个**从世界空间到阴影纹理图块裁剪空间的转换矩阵**。

```cs
//返回一个从世界空间到阴影图块空间的转换矩阵
    Matrix4x4 ConvertToAtlasMatrix(Matrix4x4 m, Vector2 offset, int split)
    {
        return m;
    }
```

5. 我们在 SetTileViewport 方法中已经计算了图块偏移，所以添加一个返回值直接拿到它。

```cs
Vector2 SetTileViewport (int index, int split, float tileSize) {
        …
        return offset;
    }
```

6. 调整 RenderDirectionalShadows 方法中阴影转换矩阵的获取，调用 ConvertToAtlasMatrix 方法来**得到从世界空间到阴影纹理图块空间的转换矩阵。**

```cs
//dirShadowMatrices[index] = projectionMatrix * viewMatrix;
        dirShadowMatrices[index] = ConvertToAtlasMatrix(projectionMatrix * viewMatrix,
            SetTileViewport(index, split, tileSize), split);
```

1. 最后实现 `ConvertToAtlasMatrix` 方法的具体内容
    1. **首先判断当前平台图形 API, 如果使用了反向 Z-Buffer，就将矩阵的 Z 分量的值进行反转**。（OpenGL 中 0 是 0 深度，1 是最大深度。其它图形 API，如 DirectX 中 0 是 0 深度，-1 是最大深度。由于深度缓冲精度受限（8、16、24bit），能表示的深度数量也有限，而通过反转能更好利用这些位，**其它图形 API 如 DirectX 是使用了反向深度缓冲的**）。
    2. **然后在立方体内定义裁剪空间**，坐标是从 - 1 到 1，中心点是 0。但是深度和纹理坐标是从 0 到 1。要将此转换通过，需要把 XYZ 的尺寸进行缩放和偏移一半的方式拷贝到矩阵中，我们可以利用矩阵乘法做到这一点，但是会导致大量和 0 之间的乘法以及不必要的加法，所以我们直接调整矩阵。

```cs
//返回一个从世界空间转到阴影纹理图块空间的矩阵
     Matrix4x4 ConvertToAtlasMatrix(Matrix4x4 m, Vector2 offset, int split)
    {
        //如果使用了反向Zbuffer
        if (SystemInfo.usesReversedZBuffer)
        {
            m.m20 = -m.m20;
            m.m21 = -m.m21;
            m.m22 = -m.m22;
            m.m23 = -m.m23;
        }
        //设置矩阵坐标
        m.m00 = 0.5f * (m.m00 + m.m30);
        m.m01 = 0.5f * (m.m01 + m.m31);
        m.m02 = 0.5f * (m.m02 + m.m32);
        m.m03 = 0.5f * (m.m03 + m.m33);
        m.m10 = 0.5f * (m.m10 + m.m30);
        m.m11 = 0.5f * (m.m11 + m.m31);
        m.m12 = 0.5f * (m.m12 + m.m32);
        m.m13 = 0.5f * (m.m13 + m.m33);
        m.m20 = 0.5f * (m.m20 + m.m30);
        m.m21 = 0.5f * (m.m21 + m.m31);
        m.m22 = 0.5f * (m.m22 + m.m32);
        m.m23 = 0.5f * (m.m23 + m.m33);
        return m;
    }
```

8. 最后把图块的偏移和缩放也算进去。

```cs
   //设置矩阵坐标
float scale = 1f / split;
m.m00 = (0.5f * (m.m00 + m.m30) + offset.x * m.m30) * scale;
m.m01 = (0.5f * (m.m01 + m.m31) + offset.x * m.m31) * scale;
m.m02 = (0.5f * (m.m02 + m.m32) + offset.x * m.m32) * scale;
m.m03 = (0.5f * (m.m03 + m.m33) + offset.x * m.m33) * scale;
m.m10 = (0.5f * (m.m10 + m.m30) + offset.y * m.m30) * scale;
m.m11 = (0.5f * (m.m11 + m.m31) + offset.y * m.m31) * scale;
m.m12 = (0.5f * (m.m12 + m.m32) + offset.y * m.m32) * scale;
m.m13 = (0.5f * (m.m13 + m.m33) + offset.y * m.m33) * scale;
m.m20 = 0.5f * (m.m20 + m.m30);
m.m21 = 0.5f * (m.m21 + m.m31);
m.m22 = 0.5f * (m.m22 + m.m32);
m.m23 = 0.5f * (m.m23 + m.m33);
```

## 4.2.2 获取定向光的阴影数据

1. **要对光源的阴影采样，需要知道它在阴影图集的图块索引**，我们在用 ReserveDirectionalShadows 方法中存储阴影数据的时候返回阴影强度和阴影图块的偏移，放在 Vector2 结构里一块返回。如果光源没有阴影则返回零向量。

```cs
public Vector2 ReserveDirectionalShadows (…) 
{
    if (…) 
    {
        ShadowedDirectionalLights[ShadowedDirectionalLightCount] = new ShadowedDirectionalLight {visibleLightIndex = visibleLightIndex};
        //返回阴影强度和阴影图块的偏移
        return new Vector2(light.shadowStrength, ShadowedDirectionalLightCount++);
    }
    return Vector2.zero;
 }
```

2. 在 Lighting 脚本中定义一个向量数组，存储定向光的阴影数据，通过在 SetupDirectionalLight 方法中得到它们，再在 SetupLights 方法中将阴影数据传递到 GPU。

```cs
static int dirLightShadowDataId = Shader.PropertyToID("_DirectionalLightShadowData");
//存储阴影数据
static Vector4[] dirLightShadowData = new Vector4[maxDirLightCount];
void SetupLights () 
{
    ...
    buffer.SetGlobalVectorArray(dirLightShadowDataId, dirLightShadowData);
}
void SetupDirectionalLight(int index, ref VisibleLight visibleLight) 
{
    ...
    //存储阴影数据
    dirLightShadowData[index] = shadows.ReserveDirectionalShadows(visibleLight.light, index);
}
```

3. 最后在 Light文件中的_CustomLight 缓冲区定义字段获取传递来的阴影数据。

```cs
CBUFFER_START(_CustomLight)
    ...
    //阴影数据
    float4 
    _DirectionalLightShadowData[MAX_DIRECTIONAL_LIGHT_COUNT];
CBUFFER_END
```

## 4.2.3 阴影图集采样

- ? TEXTURE2D_SHADOW 和 SAMPLER_CMP
```cs file:TEXTURE2D_SHADO宏
#define TEXTURE2D_SHADOW(samplerName) TEXTURE2D(textureName)
//然而GLES 2.0是这样的
#define TEXTURE2D_SHADOW(samplerName) SHADOW2D_TEXTURE_AND_SAMPLER textureName
```
如果不想支持 GLES 2.0也是可以直接写 TEXTURE2D 的

一般来说，我们在Shader为了采样，会使用samper2D来声明，不过实际上这一举动导致绝大部分情况下，纹理和采样器是耦合在一起的，不过也没关系，我们就是要这么用的，而且旧的图形API（如OpenGL ES）上这是唯一支持的做法。
另一种情况是纹理和采样器是相互独立的。没错，因为有些图形 API 允许使用比纹理更少的采样器，比如 D3D11就支持单个着色器中使用128个纹理，但是只能有16个采样器。这种情况下，需要特殊的命名规范：具有【“sampler”+ 纹理命名】形式名称的采样器将从该纹理中获取采样状态。
```cs file:SAMPLER_CMP宏
#define SAMPLER(samplerName) SamplerState samplerName
#define SAMPLER_CMP(samplerName) SamplerComparisonState samplerName

//使用时：
Texture2D _MainTex;
SamplerState sampler_MainTex; // "sampler" + “_MainTex”
```

接下来回到正题：
1. 我们在 ShaderLibrary 子文件夹下创建 Shadows .hlsl 文件专门用来对阴影图集进行采样。定义支持投影的最大光源数和阴影图集纹理以及它的采样器，**因为图集不是常规的纹理，所以用 TEXTURE2D_SHADOW 宏进行定义。最后在_CustomShadows 缓冲区定义阴影的转换矩阵。**

```cs 
//阴影采样
#ifndef CUSTOM_SHADOWS_INCLUDED
#define CUSTOM_SHADOWS_INCLUDED

#define MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT 4
//阴影图集
TEXTURE2D_SHADOW(_DirectionalShadowAtlas);
#define SHADOW_SAMPLER sampler_linear_clamp_compare
SAMPLER_CMP(SHADOW_SAMPLER);

 CBUFFER_START(_CustomShadows)
//阴影转换矩阵
float4x4 _DirectionalShadowMatrices[MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT];
CBUFFER_END

 #endif
```

2. 在 LitPass 中 Include 该文件，放在 Light 之前。

```cs
#include "../ShaderLibrary/Surface.hlsl"
#include "../ShaderLibrary/Shadows.hlsl"
#include "../ShaderLibrary/Light.hlsl"
```

3. 在 Shadows 文件中定义一个结构体，用来存储定向光的阴影数据，包括阴影强度和在图集中的图块索引。

```cs
//阴影的数据信息
struct DirectionalShadowData 
{
   float strength;
   int tileIndex;
};
```

4. 为了**采样阴影，需要知道表面的位置**，通过在 Surface 结构体中定义它，并在片元函数中获取它。

```cs
struct Surface 
{
   //表面位置
   float3 position;
    ...
};
```

```cs
Surface surface;
  surface.position = input.positionWS;
  surface.normal = normalize(input.normalWS);
```

5. 在 Shadows 中定义` SampleDirectionalShadowAtlas` 方法，通过 `SAMPLE_TEXTURE2D_SHADOW` 宏**对阴影图集采样**，它需要图集和采样器，以及阴影纹理空间中的表面位置。

```cs
//采样阴影图集
float SampleDirectionalShadowAtlas(float3 positionSTS) {
    return SAMPLE_TEXTURE2D_SHADOW(_DirectionalShadowAtlas, SHADOW_SAMPLER, positionSTS);
}
```

6. 然后定义 `GetDirectionalShadowAttenuation` 方法**计算阴影衰减**，它通过阴影数据中的图块索引找到对应的转换矩阵，通过转换矩阵将表面位置从世界空间转换到阴影纹理空间，然后对阴影图集进行采样。

```cs
//计算阴影衰减
float GetDirectionalShadowAttenuation(DirectionalShadowData data, Surface surfaceWS) 
{
    //通过阴影转换矩阵和表面位置得到在阴影纹理(图块)空间的位置，然后对图集进行采样
    float3 positionSTS = mul(_DirectionalShadowMatrices[data.tileIndex],float4(surfaceWS.position, 1.0)).xyz;
    float shadow = SampleDirectionalShadowAtlas(positionSTS);
    return shadow;
}
```

7. **采样阴影图集的结果是根据有多少光到达表面来决定的，它是一个［0，1］区间的值，通常叫做阴影衰减因子**。如果片元完全被阴影覆盖则为 0，如果没有任何阴影遮挡则为 1，之间的值表示片元被部分阴影遮挡。

**还有一种情况，当灯光的阴影强度属性被降到 0 时，阴影衰减就不受阴影影响了，衰减值始终为 1，所以最终的阴影衰减应该是阴影强度和采样图集得到的衰减因子进行插值得到的。** 我们调整 GetDirectionalShadowAttenuation 方法的返回值，且灯光的阴影强度为 0 时采样阴影图集没有意义，阴影衰减值始终为 1。

```cs
//得到阴影的衰减
float GetDirectionalShadowAttenuation(DirectionalShadowData data, Surface surfaceWS) {
    if (data.strength <= 0.0) 
    {
        return 1.0;
    }
    ...
     //最终阴影衰减值是阴影强度和衰减因子的插值
    return lerp(1.0, shadow, data.strength);
}
```

## 4.2.4 灯光的阴影衰减

1. 在 Light 结构体中添加一个光源的阴影衰减属性。

```cs
//灯光的属性
struct Light 
{
     float3 color;
     float3 direction;
     float attenuation;
};
```

2. 在 Light 文件中定义 ` GetDirectionalShadowData` 方法来获取 CPU 传递过来的定向光阴影数据。

```cs
//获取定向光的阴影数据
DirectionalShadowData GetDirectionalShadowData(int lightIndex) {
     DirectionalShadowData data;
     data.strength = _DirectionalLightShadowData[lightIndex].x;
     data.tileIndex = _DirectionalLightShadowData[lightIndex].y;
     return data;
}
```

3. 给 GetDirectionalLight 方法添加一个表面信息的传参，然后得到光源的阴影数据并计算阴影衰减。

```cs
//获取目标索引定向光的属性
Light GetDirectionalLight (int index,Surface surfaceWS) 
{
    ...
    //得到阴影数据
    DirectionalShadowData shadowData = GetDirectionalShadowData(index);
    //得到阴影衰减
    light.attenuation = GetDirectionalShadowAttenuation(shadowData, surfaceWS);
    return light;
}
```

4. 在 Lighting.GetLighting 方法中将表面信息 surfaceWS 传递到 GetDirectionalLight 方法中。

```cs
//根据物体的表面信息和灯光属性获取最终光照结果
float3 GetLighting(Surface surfaceWS, BRDF brdf) 
{
    //可见光的光照结果进行累加得到最终光照结果
    float3 color = 0.0;
    for (int i = 0; i < GetDirectionalLightCount(); i++) 
    {
        color += GetLighting(surfaceWS, brdf, GetDirectionalLight(i, surfaceWS));
    }
    return color;
}
```

5. 在 IncomingLight 方法中将灯光的阴影衰减添加到入射光强度的计算中。

```cs
//得到入射光的数据
float3 IncomingLight (Surface surface, Light light) {
    return saturate(dot(surface.normal, light.direction)* light.attenuation) * light.color;
}

```
![[Pasted image 20230621105121.png]]



![[Pasted image 20230621105124.png]]
虽然得到了阴影，**但是阴影质量很差，不应被投影的表面最终被形成像素化带的<mark style="background: #FF5582A6;">自阴影</mark>伪影所覆盖**，即使提高阴影图集的分辨率只能有所改善，但也不能消除。**灯光能够渲染阴影到屏幕中只是实现阴影的第一步**，本节后续内容会逐渐完善阴影的各种功能和改善阴影质量。

# 4.3 级联ShadowMap（CSM）

**使用 ShadowMap 通常会有透视走样的问题**。透视走样指的是阴影越靠近相机，其边缘的锯齿化越严重。因为 ShadowMap 的分辨率是固定的，同样大小的一个阴影所对应的 ShadowMap 中纹素大小也是固定的（由于 ShadowMap 使用正交投影，因此 ShadowMap 中的每个纹理像素都有固定的世界空间大小）。
如果使用透视相机，其效果是近大远小，在渲染时，阴影越靠近摄像机，越容易出现多个片元从ShadowMap中的同一纹素进行采样的情况，这几个片元得到的是相同的阴影值，从而产生锯齿边。使用高分辨率的ShadowMap可以降低锯齿边，但渲染时会占用更多内存和带宽。
![[6a7sdASd 1.gif|500]]
级联 ShadowMap（Cascaded Shadow Map）就是解决这个问题的，可以更好的兼顾精度和性能问题，它将摄像机的视锥体按一定比例分成若干层（Cascade），每个层级对应一个子视锥体，每一层都单独计算相关的 ShadowMap，在渲染大场景时就可以避免使用单张 ShadowMap 的各种缺点。Unity 就是使用的这种技术，我们可以在工程的 Project Setting->Quality->Shadows 看到：
![[Pasted image 20230621105130.png]]


​下图是级联ShadowMap的原理。
![[Pasted image 20230621105133.png]]


## 4.3.1 设置级联

**目前我们使用的是单级联**，覆盖了整个场景区域。**Unity 的阴影源码中可以为每个定向光支持最多 4 个级联，我们在自己的管线中也添加该功能**。
首先在 ShadowSettings 脚本的 Directional 结构体中定义一个级联数量滑块，**每个级联都会覆盖一部分阴影区域，直到达到设置的阴影最大距离为止**。
我们**定义 3 个参数来调节前三级级联的区域比例，最后一级会覆盖整个区域，所以不用自己调节**。默认情况下级联数量设置为 4，前三级级联比例为 0.1，0.25 和 0.5。

```cs
 //定向光的阴影属性
 [System.Serializable]
 public struct Directional
 {
     public TextureSize atlasSize;
     //级联数量
     [Range(1, 4)]
     public int cascadeCount;
     //级联比例
     [Range(0f, 1f)]
     public float cascadeRatio1, cascadeRatio2, cascadeRatio3;
 }
 //图集大小默认为1024
 public Directional directional = new Directional
 {
     atlasSize = TextureSize._1024,
     cascadeCount = 4,
     cascadeRatio1 = 0.1f,
     cascadeRatio2 = 0.25f,
     cascadeRatio3 = 0.5f
 };
```
![[Pasted image 20230621105139.png]]

后续我们要将每级级联的比例传递到之前调用的 ComputeDirectionalShadowMatricesAndCullingPrimitives 方法中，它**需要我们将三个比例值封装到一个 Vector3 向量中，我们来定义一个向量字段进行封装。**

```cs
public Vector3 CascadeRatios => new Vector3(cascadeRatio1, cascadeRatio2, cascadeRatio3);
```

## 4.3.2 渲染级联

1. 在 Shadows 脚本中**定义字段设置最大级联数量，因为每个级联都需要自己的阴影转换矩阵，所以转换矩阵的数组的大小应是定向光数量乘以最大级联数量。**

```cs
//最大级联数量
 const int maxCascades = 4;
```

```cs
//光源的阴影转换矩阵
    static Matrix4x4[] dirShadowMatrices = new Matrix4x4[maxShadowedDirectionalLightCount * maxCascades];
```

2. 在 Shadows.hlsl 中也**定义一个代表级联最大数量的宏和扩张数组大小**。然后需要重启下 Unity，因为**在同一会话中的着色器中修改固定长度数组的大小是不生效的。**
![[Pasted image 20230624235438.png]]

```cs
#define MAX_CASCADE_COUNT 4
CBUFFER_START(_CustomShadows)
//阴影矩阵
float4x4 _DirectionalShadowMatrices[MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT * MAX_CASCADE_COUNT];
CBUFFER_END
```

3. 修改 ReserveDirectionalShadows 方法中阴影图块的索引，需要乘以级联数量，因为现在每个定向光声明多个连续的图块。

```cs
return new Vector2(light.shadowStrength, settings.directional.cascadeCount * ShadowedDirectionalLightCount++);
```

4. 现在整个阴影图集可以分割成最多 4X4=16 个图块，因此调整 RenderDirectionalShadows 方法中的分割图块数量和图块大小。

```cs
//要分割的图块数量和大小
 int tiles = ShadowedDirectionalLightCount * settings.directional.cascadeCount;
 int split = tiles <= 1 ? 1 : tiles <= 4 ? 2 : 4;
int tileSize = atlasSize / split;
```

5. 在 RenderDirectionalShadows 方法中，要**为每个级联渲染阴影，我们在最外面添加一个 for 循环遍历级联数量**，在循环中去调用 ComputeDirectionalShadowMatricesAndCullingPrimitives() 方法。之前我们说这 9 个传参中，第 2、3、4 个参数是级联ShadowMap的配置，当时我们使用的是默认参数，现在我们使用正式的值。第 2 个参数是当前级联的索引，第 3 个参数是级联的数量，第 4 个参数是 Vector3 类型的各级联比例，我们从阴影配置中拿到它们并设置。最后我们还需要调整图块索引，它等于光源的图块偏移加上级联的索引。

```cs
//渲染定向光阴影
 void RenderDirectionalShadows(int index, int split, int tileSize)
 {
     ...
     //得到级联ShadowMap需要的参数
     int cascadeCount = settings.directional.cascadeCount;
     int tileOffset = index * cascadeCount;
     Vector3 ratios = settings.directional.CascadeRatios;
     for (int i=0;i<cascadeCount;i++)
     {
         cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(light.visibleLightIndex, i, cascadeCount,ratios, tileSize, 0f,
         out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix, out ShadowSplitData splitData);
 
         shadowSettings.splitData = splitData;
         //调整图块索引，它等于光源的图块偏移加上级联的索引
         int tileIndex = tileOffset + i;
 
         dirShadowMatrices[tileIndex] = ConvertToAtlasMatrix(projectionMatrix * viewMatrix,SetTileViewport(tileIndex, split, tileSize), split);
         ...
      }
 
 }
```

我们使用一个定向光源，将最大阴影距离设置为 30，级联比例为 0.3，0.4 和 0.5。通过帧调试器可以查看阴影图集被分割为了 4 个图块。


![[Pasted image 20230621105150.png]]
下图是带有 4 个定向光源的阴影图集。


![[Pasted image 20230621105152.png]]
## 4.3.3 级联包围球

要使用级联阴影，**首先要为每个层级对应的子视锥体构造一个投影矩阵，构建投影矩阵时，必须是在生成的 ShadowMap 中，并尽可能减少当前不在视野内的无关区域，也就是说要计算出和当前层级所对应的子视锥体尽可能重合的投影矩阵**，投影矩阵一般用正交投影，是一个**能包住子视锥体的且与光源空间坐标系轴对齐的包围盒（AABB）** 所对应生成的，如下图：
![[Pasted image 20230621105155.png]]



但因为在渲染时，摄像机的位置朝向等属性会及时改变，所以每个层级的子视锥体都会不断变换，子视锥体的轴对齐包围盒也要跟着变化，但这样可能导致出现前后两帧轴对齐包围盒发生突变，进而导致生成的ShadowMap的有效分辨率可能在连续的两帧中发生突变，产生**阴影抖动**问题，解决方案是**把包围盒改为包围球，包围球随着子视锥体的变化而发生大小的变化程度相对于包围盒来说小很多**，如下图：


![[Pasted image 20230621105157.png]]
​

虽然阴影的投影可以契合包围球，但是球体还会覆盖周围的一些空间，导致我们在剔除区域之外也可以看到一些阴影。**光的方向和球无关，所以我们所有的定向光都使用相同的包围球。**

1. **我们需要知道这些球体应该从哪个级联中采样，因此需要将包围球数据发送到 GPU**，在 Shadows 脚本中定义级联包围球和级联数量的着色器标识 ID，并定义一个 Vector4 类型的数组存储包围球数据，其中 XYZ 分量存储包围球的位置，W 分量存储球体半径。

```cs
static int cascadeCountId = Shader.PropertyToID("_CascadeCount");
 static int cascadeCullingSpheresId = Shader.PropertyToID("_CascadeCullingSpheres");
 static Vector4[] cascadeCullingSpheres = new Vector4[maxCascades];
```

2. **级联包围球是从 ComputeDirectionalShadowMatricesAndCullingPrimitives 方法中得到的 spitData 数据的一部分，我们可以直接调用获取到，然后赋值给包围球数组**。因为**我们想要所有的光源都使用相同的级联，所以只需要拿到第一个定向光的包围球数据即可。**

```cs
for (int i=0;i<cascadeCount;i++)
{
    //计算视图和投影矩阵和裁剪空间的立方体
    cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(light.visibleLightIndex, i, cascadeCount,ratios, tileSize, 0f,
    out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix, out ShadowSplitData splitData);
    //得到第一个光源的包围球数据
    if (index == 0)
    {
        cascadeCullingSpheres[i] = splitData.cullingSphere;
    }
```

3. 我们**后续需要在着色器中判断物体表面的片元是否在包围球中，可以通过该片元到球心距离的平方和球体半径的平方来比较**，我们传递数据之前先计算好球体半径的平方，就不用再在着色器中计算了。

```cs
Vector4 cullingSphere = splitData.cullingSphere;
    //*=得到半径的平方值
    cullingSphere.w *= cullingSphere.w;
    cascadeCullingSpheres[i] = cullingSphere;
```

4. 渲染级联后在 RenderDirectionalShadows 方法中将级联数量和级联包围球数据发送到 GPU。

```cs
//将级联数量和包围球数据发送到GPU
buffer.SetGlobalInt(cascadeCountId, settings.directional.cascadeCount);
buffer.SetGlobalVectorArray(cascadeCullingSpheresId, cascadeCullingSpheres);
//阴影转换矩阵传入GPU
buffer.SetGlobalMatrixArray(dirShadowMatricesId, dirShadowMatrices);
buffer.EndSample(bufferName);
ExecuteBuffer();
```

## 4.3.4 采样级联

1. 在 Shadows 文件的_CustomShadows 缓冲区中定义级联数量和包围球数据数组。

```cs
CBUFFER_START(_CustomShadows)
//级联数量和包围球数据
int _CascadeCount;
float4 _CascadeCullingSpheres[MAX_CASCADE_COUNT];
//阴影矩阵
float4x4 _DirectionalShadowMatrices[MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT * MAX_CASCADE_COUNT];
CBUFFER_END
```

2. 定义一个结构体 ShadowData 存储表面阴影数据，在其中定义级联索引的属性，再定义一个`GetShadowData` 方法，返回世界空间的表面阴影数据。最初只把级联索引设为 0。

```cs
//阴影数据
struct ShadowData 
{
    int cascadeIndex;
};
//得到世界空间的表面阴影数据
ShadowData GetShadowData (Surface surfaceWS) {
    ShadowData data;
    data.cascadeIndex = 0;
    return data;
}
```

3. 将阴影数据添加到 Light 文件的 `GetDirectionalShadowData` 方法中，**将级联索引和光源的阴影图块索引相加得到最终的图块索引。**

```cs
//获取定向光阴影数据
DirectionalShadowData GetDirectionalShadowData(int lightIndex, ShadowData shadowData) {
        ...
        data.tileIndex = _DirectionalLightShadowData[lightIndex].y + shadowData.cascadeIndex;
        return data;
}
```

4. 在 GetDirectionalLight 方法中也添加 shadowData 参数，把阴影数据发送到 GetDirectionalShadowData 方法中。

```cs
//获取目标索引定向光的属性
Light GetDirectionalLight (int index,Surface surfaceWS, ShadowData shadowData) 
{
        ...
        //得到阴影数据
        DirectionalShadowData dirShadowData = GetDirectionalShadowData(index,shadowData);
        //得到阴影衰减
        light.attenuation = GetDirectionalShadowAttenuation(dirShadowData, surfaceWS);
        return light;
}
```

5. 在 Lighting.hlsl 的 GetLighting 方法中获取表面阴影数据并传递到 GetDirectionalLight 方法中。

```cs
//根据物体的表面信息和灯光属性获取最终光照结果
float3 GetLighting(Surface surfaceWS, BRDF brdf) 
{
        //得到表面阴影数据
        ShadowData shadowData = GetShadowData(surfaceWS);
        //可见光的光照结果进行累加得到最终光照结果
        float3 color = 0.0;
        for (int i = 0; i < GetDirectionalLightCount(); i++) 
        {
               Light light = GetDirectionalLight(i, surfaceWS, shadowData);
               color += GetLighting(surfaceWS, brdf, light);
        }
        return color;
}
```

6. **要选择正确的级联，需要计算两点间距离的平方**，在 Common.hlsl 中定义这么一个方法。

```cs
//计算两点间距离的平方
float DistanceSquared(float3 pA, float3 pB) {
    return dot(pA - pB, pA - pB);
}
```

7. 调整 Shadows.hlsl 文件中的 GetShadowData 方法**得到合适的级联索引**。**循环所有级联包围球，如果物体表面到球心的距离的平方小于球体半径的平方，就说明该物体应在这层级联的包围球中，则跳出循环并得到正确的级联索引。**

```cs
//得到世界空间的表面阴影数据
ShadowData GetShadowData (Surface surfaceWS) 
{
    ShadowData data;
    int i;
    //如果物体表面到球心的平方距离小于球体半径的平方，就说明该物体在这层级联包围球中，得到合适的级联层级索引
    for (i = 0; i < _CascadeCount; i++) 
    {
        float4 sphere = _CascadeCullingSpheres[i];
        float distanceSqr = DistanceSquared(surfaceWS.position, sphere.xyz);
        if (distanceSqr < sphere.w) 
        {
            break;
        }
    }
    data.cascadeIndex = i;
    return data;
}
```


![[Pasted image 20230621105215.png]]
由于存在自阴影的伪影，导致级联之间的弯曲过渡边界也清晰可见。如果想试试看效果，可以在 Light.hlsl 文件的 GetDirectionalLight() 方法中用级联索引除以 4 来代替阴影衰减，这样效果就会比较明显，如下图所示：
​![[Pasted image 20230621105218.png]]
## **4.3.5 剔除阴影采样**

1. **如果我们最终超过了最后一个级联的范围，很可能没有有效阴影数据，这种情况下也不需要采样阴影了，没有意义**。我们在 Shadows.hlsl 文件的 ShadowData 结构体中添加一个字段 Strength 作为一个标识符，如果超出最后一个级联范围就设为 0。

```cs
struct ShadowData 
{
    int cascadeIndex;
    //是否采样阴影的标识
    float strength;
};

//得到世界空间的表面阴影数据
ShadowData GetShadowData (Surface surfaceWS) 
{
    ShadowData data;
    data.strength = 1.0;
    ...
    //如果超出最后一个级联的范围，标识符设置为0，不对阴影进行采样
    if (i == _CascadeCount) 
    {
        data.strength = 0.0;
    }
    data.cascadeIndex = i;
    return data;
}
```

2. 在 Light.hlsl 文件的 GetDirectionalShadowData 方法中获取阴影强度时乘上这个 Strength 参数，这样**可以剔除掉最后一个级联范围外的所有阴影**。然后恢复 GetDirectionalLight 方法中的阴影衰减的计算，把级联索引除以 4 的测试代码删掉。

```cs
//获取定向光阴影数据
DirectionalShadowData GetDirectionalShadowData(int lightIndex, ShadowData shadowData) {
    DirectionalShadowData data;
    data.strength = _DirectionalLightShadowData[lightIndex].x * shadowData.strength;
    ...
}
```

这样不在级联中的阴影就被剔除了，可以把阴影的最大距离调小一点观察一下。
![[Pasted image 20230621105225.png]]


​根据上图我们会发现，**有些物体的投影在最后一个级联的包围球内没有。原因就是最外面的包围球超出了我们设置的最大阴影距离**，上图中我设置的最大距离是 13，结果出现了这种问题。我们**需要把最大阴影距离传到 GPU，然后进行判断，如果超出最大距离就停止采样阴影**来解决它。

3. 首先在 Shadows 脚本中定义阴影最大距离的着色器标识 ID，通过 RenderDirectionalShadows 方法将最大阴影距离传到 GPU。

```cs
static int shadowDistanceId = Shader.PropertyToID("_ShadowDistance");
    void RenderDirectionalShadows () {
        ...
        buffer.SetGlobalFloat(shadowDistanceId, settings.maxDistance);
        buffer.EndSample(bufferName);
        ExecuteBuffer();
    }
```

4. 阴影最大距离基于的是观察空间的深度，而不是与相机的距离，**为了进行剔除我们需要知道物体表面的深度**，在 Surface 结构体重定义一个 depth 字段存储表面深度。

```cs
struct Surface 
{
    ...
    //表面深度
    float depth;
};
```

5. 在片元函数中，调用源码库中的 TransformWorldToView() 方法把世界坐标转换到视图空间，并**获取负的 z 坐标作为表面深度**。由于这种转换只是相对于世界空间的旋转和偏移，因此在视图空间和世界空间中的深度都是相同的。

```cs
//得到视角方向
surface.viewDirection = normalize(_WorldSpaceCameraPos - input.positionWS);
//获取表面深度
surface.depth = -TransformWorldToView(input.positionWS).z;
```

6. 在 Shadows.hlsl 文件的_CustomShadows 缓冲区中定义_ShadowDistance 字段获取阴影最大距离，然后在 GetShadowData 方法中进行判断，当表面深度比最大阴影距离小时，才进行阴影采样。

```cs
CBUFFER_START(_CustomShadows)
...
float _ShadowDistance;
CBUFFER_END

ShadowData GetShadowData (Surface surfaceWS) 
{
    ShadowData data;
    data.strength = surfaceWS.depth < _ShadowDistance ? 1.0 : 0.0;
    …
}
```


![[Pasted image 20230621105232.png]]
## 4.3.6 阴影衰减

上图中还有一个问题，**突然切断阴影最大距离处的阴影会显得很突兀**，我们通过一种**线性淡化**的方式使阴影衰减变得柔和自然一些。
**阴影淡化应从阴影最大距离之前的一段距离开始，直到最大距离时阴影强度为 0**。我们使用下面的数学公式：
$$
\frac{1-\frac{d}{m}}{f}
$$
​ d 是表面的深度
m 是阴影最大距离
f 是阴影衰减范围，指的是到达阴影最大距离之前的那一小段距离。公式的最终结果应限制在［0，1］之间。

这是 f 分别为 0.1，0.2 和 0.5 时的示意图。

![[Pasted image 20230621105238.png]]
下面进行具体实现。

1. 在 ShadowSettings 脚本中添加一个字段表示阴影衰减距离，默认为 0.1。因为这个过渡距离和阴影最大距离在上面的数学公式中有一个相除的计算，所以该值不能为 0，我们限制一下该字段的最小值为 0.001。

```cs
//阴影最大距离
  [Min(0.001f)]
  public float maxDistance = 100f;
  //阴影衰减距离
  [Range(0.001f, 1f)]
  public float distanceFade = 0.1f;
```

2. 在 Shadows 脚本中，**定义一个阴影衰减距离着色器标识 ID，代替原来的阴影最大距离标识 ID**。然后把阴影最大距离和阴影衰减距离的**倒数**传递给 GPU，因为在着色器中乘法比除法效率更高。

```cs
//static int shadowDistanceId = Shader.PropertyToID("_ShadowDistance");
static int shadowDistanceFadeId = Shader.PropertyToID("_ShadowDistanceFade");

void RenderDirectionalShadows() 
{
    ...
    //最大阴影距离和阴影衰减距离发送GPU
    //buffer.SetGlobalFloat(shadowDistanceId, settings.maxDistance);
    buffer.SetGlobalVector(shadowDistanceFadeId,new Vector4(1f / settings.maxDistance, 1f / settings.distanceFade));
    buffer.EndSample(bufferName);
    ExecuteBuffer();
}
```

3. 在 Shadows 文件的_CustomShadows 缓冲区中将阴影最大距离替换成新的字段。

```cs
CBUFFER_START(_CustomShadows)
...
//float _ShadowDistance;
//阴影衰减距离
float4 _ShadowDistanceFade;
CBUFFER_END
```

4. 最后定义一个 FadedShadowStrength 方法来计算阴影衰减时的强度，通过套用上面的数学公式完成。在 GetShadowData 方法中调用该方法得到有线性过渡的阴影强度。

```cs
//公式计算阴影衰减时的强度
float FadedShadowStrength (float distance, float scale, float fade) 
{
     return saturate((1.0 - distance * scale) * fade);
}
 
ShadowData GetShadowData (Surface surfaceWS) 
{
     ShadowData data;
     //通过公式得到有线性过渡的阴影强度
     data.strength =FadedShadowStrength(surfaceWS.depth, _ShadowDistanceFade.x, _ShadowDistanceFade.y);
     ...
}
```

![[Pasted image 20230621105250.png]]
## 4.3.7 级联衰减

我们也可以**使用和阴影衰减相同的方法**，**在最后一个级联边缘对阴影进行平滑过渡，而不是硬切**。在 ShadowSettings 脚本中定义一个级联阴影衰减的字段，并设置一个初值 0.1。

```cs
public struct Directional 
{
    ...
    //级联淡入值
    [Range(0.001f, 1f)]
    public float cascadeFade;
}

public Directional directional = new Directional 
{
    …
    cascadeRatio3 = 0.5f,
    cascadeFade = 0.1f
};
```

**和之前的衰减公式的区别是分子使用级联距离的平方除以包围球半径的平方**，而不是之前线性的深度除以阴影最大距离，这意味着该阴影衰减是**非线性的**。

$$
\frac{1-\frac{d^2}{r^2}}{f}
$$

其中 r 是包围球的半径，我们要保持配置的过渡距离不变，需要将 $f$ 替换成 $1−(1−f)^2$，然后将**该值存储在阴影衰减向量中的 Z 分量中并取反**，一同发送到 GPU。

```cs
float f = 1f - settings.directional.cascadeFade;
buffer.SetGlobalVector(shadowDistanceFadeId,new Vector4(1f / settings.maxDistance, 1f / settings.distanceFade,1f / (1f - f * f)));
```

在 Shadow.hlsl 文件的 GetShadowData 方法中**判断要渲染的对象是否在最后一个级联的范围中，如果是则计算级联的阴影衰减强度，和阴影最大距离的阴影衰减强度相乘得到最终阴影强度**。

```cs
if (distanceSqr < sphere.w) 
{
    //如果绘制的对象在最后一个级联的范围中，计算级联的阴影衰减强度，和阴影最大距离的阴影衰减强度相乘得到最终阴影强度
    if (i == _CascadeCount - 1) 
    {
        data.strength *= FadedShadowStrength(distanceSqr, 1.0 / sphere.w, _ShadowDistanceFade.z);
    }
    break;
}
```


![[Pasted image 20230621105303.png]]
# 4.4 阴影质量


![[Pasted image 20230621105308.png]]
现在我们已经实现了级联阴影，接下来要做的是提升阴影的质量，使用ShadowMap技术实现阴影的时候，如果不对阴影效果进行微调，就会出现这种交错条纹状阴影的情况，这种现象被比喻为 “痤疮（Acne）”，专业术语叫做阴影渗漏（Shadow Acne）。

**产生阴影渗漏的主因是ShadowMap分辨率的问题，如果分辨率比较小，导致在场景中多个片元在计算阴影时对应上了同一个ShadowMap的纹素，因而导致判断该片元到底在不在光线可到达的片元之前或者之后出现了问题。**

如下图所示，片元 $A、B、C、D$ 都对应于一个 ShadowMap 中的采样判定点 $P$，而 $L_a、L_b、L_c、L_d$ 分别对应于光源到片元 $A、B、C、D$ 的距离，$L$ 对应于光源到采样判定点 $P$ 的距离。
![[Pasted image 20230621105312.png]]


因为ShadowMap分辨率太小，导致 $A、B、C、D$ 这 4 个在光源空间处于不同位置坐标的片元对应同一个ShadowMap的位置 $P$ 上，并且 $P$ 所对应的深度值为 $L$，即光源到这一被照亮的位置点距离为 $L$。如果点 P 所对应的片元位置与光源的距离小于 $L$，该片元会被照亮，大于 $L$就会遮住。

上图因为 4 个片元都没有被其它物体遮住，所以 $La、Lb、Lc、Ld$ 长度无论是多少，都应该能被光源照亮。但实际计算中，因为ShadowMap分辨率太小，4 个片元都只能使用 $L$ 作为判断能否被照亮的距离，最终$La<L，Lc<L$，片元 $A$ 和 $C$ 被照亮，$Lb>L$，$Ld>L$，片元 $B$ 和 $D$ 被遮挡，于是导致了交错的条纹状阴影。

增大ShadowMap分辨率可以减小世界空间纹素大小，痤疮会变小，但不会消失，同时痤疮数量也会变多，所以无法通过修改ShadowMap分辨率来解决问题，下图我们使用的是 8192 的分辨率，可以验证这个问题。
![[Pasted image 20230621105317.png]]


## 4.4.1 调整深度偏差

解**决阴影渗漏最直接的办法就是计算出 La、Lb、Lc 和 Ld 的长度，沿着这些线的反方向往回拉一拉，即减去一个微小的偏移值，使得最终 La、Lb、Lc 和 Ld 的长度都小于 L，这样原本应该能被照亮的地方确实被照明了，这种方法叫做调整阴影偏移（Shadow Bias）。**

1. 在 Shadows 脚本的 RenderDirectionalShadows 方法中，**我们在渲染阴影前可以调用命令缓冲区的 `SetGlobalDepthBias` 方法来设置全局阴影深度偏差**，我们设置一个较大的值 50000 试试看，该方法的第二个参数是斜度偏差，我们暂时设为 0，绘制完阴影后全局深度偏差我们归零。

```cs
//设置深度偏差
buffer.SetGlobalDepthBias(50000f, 0f);
//绘制阴影
ExecuteBuffer();
context.DrawShadows(ref shadowSettings);
buffer.SetGlobalDepthBias(0f, 0f);
```
![[Pasted image 20230621105322.png]]


我们发现只消除了物体正面朝上被光照亮的表面的痤疮，去除所有痤疮需要一个更大的偏移值，我们把 50000 改成 500000 试试看。

![[Pasted image 20230621105325.png]]


​**调整阴影偏移有个问题，就是比较难定量的针对当前被照明的物体的表面凹凸程度设置准确的偏差值，随着深度偏差将阴影投射推离光线，采样阴影也会向同一方向移动**。
如果偏差设置的过小，依然会有一些应被照亮的片元没被照亮
如果偏移值过大就会导致阴影分离（Peter Panning），即原本某些应该被遮住不被照亮的片元反而被照亮，显得物体和它的影子分开了一样，

如下图所示，图 1 是偏移值设置的过小的效果，图 2 是偏移值设置的过大的效果。
![[Pasted image 20230621105329.png]]


​![[Pasted image 20230621105331.png]]

所以**要找到一个刚好能消除阴影痤疮的值需要一定的技巧和算法**。
**Unity 中采用的阴影偏移值的计算方法是基于物体斜度（Slope）的，称为 “基于斜度比例的深度偏差值”（Slope Scale Based Depth Bias）算法**。大部分改善对阴影深度贴图采样误差的算法，其**核心思想是分析待绘制场景中各部分内容对采样误差的影响程度**。

在前面的代码中我们通过调用 SetGlobalDepthBias 方法设置全局深度偏差，第二个参数就是设置斜度偏差的，此值是该片元在水平或垂直方向上的导数值，对应正面照亮的物体表面，该值为 0。当光线在水平或垂直方向至少其中一个以 45 度角入射时值为 1。当表面法线和光照方向的点积是零时，该值为无穷大。因此需要更多时，偏差会自动增加且没有上限。我们试着将斜度偏差设置为 3，第一个深度偏差参数设置为 0 来看看。

```cs
//设置斜度比例偏差  
buffer.SetGlobalDepthBias(0, 3f);
```


![[Pasted image 20230621105341.png]]
斜度比例偏差效果还不错，但这只是个消除阴影痤疮的实验，而不是用阴影分离（Peter Panning）来替代阴影痤疮的消失，所以设置深度偏差的代码我们可以注释掉了，后面会讲解更好的替代方法消除阴影痤疮。

```cs
//设置深度偏差
//buffer.SetGlobalDepthBias(0, 3f);
//绘制阴影
ExecuteBuffer();
context.DrawShadows(ref shadowSettings);
//buffer.SetGlobalDepthBias(0f, 0f);
```

## 4.4.2 级联数据

1. **痤疮的大小跟世界空间的纹素大小有关，由于不同级联的纹素大小不一样，所以我们需要向 GPU 发送更多的级联数据**，在 Shadows 脚本中定义级联数据的着色器标识 ID 和一个 Vector4 类型的数组存储级联数据，并在 RenderDirectionalShadows 方法中将该数据发送到 GPU。

```cs
//级联数据
    static int cascadeDataId = Shader.PropertyToID("_CascadeData");
    static Vector4[] cascadeData = new Vector4[maxCascades];

    void RenderDirectionalShadows() 
    {
        //级联数据发送GPU
        buffer.SetGlobalVectorArray(cascadeDataId, cascadeData);
        //阴影转换矩阵传入GPU
        buffer.SetGlobalMatrixArray(dirShadowMatricesId, dirShadowMatrices);
    }
```

2. 我们把 RenderDirectionalShadows 方法中设置级联包围球数据的代码抽离出来，放在一个新定义的方法 SetCascadeData 中，之后还需将包围球半径的平方的倒数存储到级联数据的 X 分量中。

```cs
//得到第一个光源的级联包围球数据
if (index == 0)
{
    //设置级联数据
    SetCascadeData(i, splitData.cullingSphere, tileSize);
}
```

```cs
//设置级联数据
    void SetCascadeData(int index, Vector4 cullingSphere, float tileSize)
    {
        cascadeData[index].x = 1f / cullingSphere.w;
        //得到半径的平方值
        cullingSphere.w *= cullingSphere.w;
        cascadeCullingSpheres[index] = cullingSphere;
    }
```

3. 在 Shadows.hlsl 文件的_CustomShadows 缓冲区中定义级联数据字段，然后在 GetShadowData 方法中调用 FadedShadowStrength 时将第二个传参改为级联数据的 X 分量。

```cs
CBUFFER_START(_CustomShadows)
    int _CascadeCount;
    float4 _CascadeCullingSpheres[MAX_CASCADE_COUNT];
    //级联数据
    float4 _CascadeData[MAX_CASCADE_COUNT];
    ...
CBUFFER_END
```

```cs
if (i == _CascadeCount - 1) 
    {
        data.strength *= FadedShadowStrength(distanceSqr,  _CascadeData[i].x, _ShadowDistanceFade.z);
    }
```

## 4.4.3 法线偏差

既然无法调整深度偏差来达到我们想要的效果，那我们尝试另外一个方法，即**尝试在采样阴影时使表面沿法线方向偏移一点**，然后对表面的一点进行采样，如果距离足够远就可以避免阴影痤疮，这**虽然会让阴影的位置发生稍微的改变，可能导致边缘不对齐或添加假阴影，但这些改变远没有阴影分离（Peter Panning）来的明显**。

接下来我们要沿表面的法线方向稍微移动表面的位置来采样阴影。如果只考虑一个维度，那么**移动距离等于一个世界空间中纹素大小的偏移就足够了**。

1. 在 Shadows. cs 文件的 SetCascadeData 方法中，**通过包围球直径除以阴影图块尺寸得到纹素的大小，将结果存储在级联数据的 Y 分量中。需要注意的是，纹素是正方形，最坏的情况是不得不沿着正方形的对角线偏移，所以将纹素大小乘以根号 2 进行缩放**。

```cs
//设置级联数据
    void SetCascadeData(int index, Vector4 cullingSphere, float tileSize)
    {
        //包围球直径除以阴影图块尺寸=纹素大小
        float texelSize = 2f * cullingSphere.w / tileSize;
        //得到半径的平方值
        cullingSphere.w *= cullingSphere.w;
        cascadeCullingSpheres[index] = cullingSphere;
        cascadeData[index] = new Vector4(1f / cullingSphere.w,texelSize * 1.4142136f);
    }
```

2. 然后在 Shadows.hlsl 文件的 GetDirectionalShadowAttenuation 方法中添加一个 ShadowData 参数，在计算阴影纹理空间的位置之前，计算法线偏差，然后和表面顶点位置相加得到一个偏移后的新位置，将其通过转换矩阵转换到阴影纹理空间中，最后使用沿法线偏移后的新位置采样该阴影图集。

```cs
//得到阴影的衰减
float GetDirectionalShadowAttenuation(DirectionalShadowData directional, ShadowData global, Surface surfaceWS) 
{
    if (directional.strength <= 0.0) 
    {
        return 1.0;
    }
    //计算法线偏差
    float3 normalBias = surfaceWS.normal * _CascadeData[global.cascadeIndex].y;
    //通过加上法线偏移后的表面顶点位置 得到在阴影纹理空间的新位置，然后对图集进行采样  
    float3 positionSTS = mul(_DirectionalShadowMatrices[directional.tileIndex],float4(surfaceWS.position+ normalBias, 1.0)).xyz;
    float shadow = SampleDirectionalShadowAtlas(positionSTS);
    return lerp(1.0, shadow, directional.strength);
}
```

3. 最后在 Light.hlsl 文件的 GetDirectionalLight 方法中调用 GetDirectionalShadowAttenuation 方法时传递 shadowData 参数。

```cs
//获取目标索引定向光的属性
Light GetDirectionalLight (int index,Surface surfaceWS, ShadowData shadowData) 
{
    ...
    //得到阴影衰减
    light.attenuation = GetDirectionalShadowAttenuation(dirShadowData,shadowData, surfaceWS);

    return light;
}
```
![[Pasted image 20230621105516.png]]


## 4.4.4 可配置的偏差属性
法线偏差基本已经很好地消除了阴影痤疮，但还会引入新的问题，如下图所示：
![[Pasted image 20230621105522.png]]

我们可以看到 Cube 紧挨地板的地方有一条不该存在的阴影线条，这是因为阴影从 Cube 的面上伸展出来，从而影响到了地面。我们**可以通过设置斜度比例偏差来解决这个问题，但它没有一个固定且完美的值。**

**在光源组件上有一个 Bias 属性和 Normal Bias 属性，我们可以使用 Bias 属性作为我们管线的斜度比例偏差值来进行自由调节，然后将 Normal Bias 属性应用到我们计算好的法线偏差中，使得法线偏差也可以自由调节。**

1. 在 Shadows.cs 脚本的 ShadowedDirectionalLight 结构体中添加一个斜度比例偏差字段。

```cs
struct ShadowedDirectionalLight
{
    public int visibleLightIndex;
    //斜度比例偏差值
    public float slopeScaleBias;
}
```

2. 在 ReserveDirectionalShadows 方法中创建 ShadowedDirectionalLight 实例的时候，获取灯光上的阴影偏移属性，赋值给我们定义的斜度比例偏差字段。

```cs
ShadowedDirectionalLights[ShadowedDirectionalLightCount] = new ShadowedDirectionalLight{ visibleLightIndex = visibleLightIndex
,slopeScaleBias = light.shadowBias};
```

3. 在 RenderDirectionalShadows 方法中调用 buffer.SetGlobalDepthBias 方法配置斜度比例偏差。

```cs
  //设置斜度比例偏差值
  buffer.SetGlobalDepthBias(0, light.slopeScaleBias);
  //绘制阴影
  ExecuteBuffer();
  context.DrawShadows(ref shadowSettings);
  buffer.SetGlobalDepthBias(0f, 0f);
```

4. 灯光中还有一个 Normal Bias 属性可供我们调节法线偏差值，在 ReserveDirectionalShadows 方法中，我们将返回值由 Vector2 改为 Vector3，第三个分量我们存储灯光的法线偏差。

```cs
public Vector3 ReserveDirectionalShadows (Light light, int visibleLightIndex) {
    if (...) 
    {
        ...
        return new Vector3(light.shadowStrength,settings.directional.cascadeCount * ShadowedDirectionalLightCount++,light.shadowNormalBias);
    }
    return Vector3.zero;
}
```

5. 在 Shadows.hlsl 文件 DirectionalShadowData 结构体中定义一个法线偏差属性，然后在 GetDirectionalShadowAttenuation 方法中计算法线偏差时乘上灯光组件的法线偏差属性值。

```cs
struct DirectionalShadowData 
{
    float strength;
    int tileIndex;
    //法线偏差
    float normalBias;
};

float GetDirectionalShadowAttenuation(DirectionalShadowData directional, ShadowData global, Surface surfaceWS) 
{
    ...
    //计算法线偏移
    float3 normalBias = surfaceWS.normal * (directional.normalBias * _CascadeData[global.cascadeIndex].y);
    ...
}
```

6. 最后在 Light.hlsl 文件的 GetDirectionalShadowData 方法中获得 CPU 传递过来的灯光组件的法线偏差。

```cs
DirectionalShadowData GetDirectionalShadowData(int lightIndex, ShadowData shadowData) 
{
    ...
    //获取灯光的法线偏差值
    data.normalBias = _DirectionalLightShadowData[lightIndex].z;
    return data;
}
```
![[Pasted image 20230621105605.png]]


现在我们调整光源组件的两个偏差值，如果增大第一个偏差值，则你可以减小第二个偏差值，我们将法线偏差和斜度比例偏差值都设为 0.6，发现阴影线条基本被消除了。需要注意的是，灯光组件的 Bias 和 Normal Bias 属性在我们修改用途之前代表的是裁剪空间的深度偏差和世界空间的法线偏差，所以当创建新的定向光时，如果不根据实际情况调整偏差，有可能会出现严重的阴影分离（Peter Panning）。

## 4.4.5 阴影平坠（Shadow Pancaking）

可能导致阴影痤疮的另一个潜在问题是如果在 **Unity 中应用了阴影平坠（Shadow Pancaking）技术，那么就可以剔除那些不希望看到的阴影**。
**该技术的想法是渲染定向光的阴影时，通过剪裁光照空间，给该空间设定阴影视椎体近裁剪平面，只有位于该平面内的物体才能投射阴影，且阴影视椎体近裁剪平面会尽可能的向前移动，意在减少沿光照方向渲染ShadowMap时使用的光照空间范围，这可以提高ShadowMap的精度，减少阴影痤疮。**

如下图所示，其中浅蓝圆圈代表阴影投射物，深蓝矩形代表原始光照空间，绿线代表优化的阴影视椎体近裁剪平面（它排除了在视锥体中不可见的所有阴影投射物）。

![[Pasted image 20230621105611.png]]
这个办法虽然有效，但是对于穿过阴影视椎体近裁剪平面的大型三角形，会带来一些瑕疵。如下图所示，在这种情况下，只有蓝色三角形的一个顶点位于近裁剪面背后并被钳制到此处。但是，这会改变三角形的形状，并可能产生不正确的阴影。
![[Pasted image 20230621105613.png]]

​**Unity 可以通过调整 QualitySettings 中的 ShadowNearPlaneOffset 属性避免发生这种问题，该属性用于调整阴影视椎体近裁剪平面的偏移**。
如果将此值设置得过高，则最终还是会引入阴影痤疮，因为它会提高 ShadowMap 需要在光照方向上覆盖的范围；
如果该值调的太低，又会产生漏光。如上图一样，绿色的平面会被往上推很多，则原本该产生阴影的圆形将被部分裁剪而不再产生投影，造成了阴影镂空了一部分。

如果在 Scene 视图中将视野拉近，会发现一些投射的阴影中间有部分镂空，如下图所示。
![[Pasted image 20230621105618.png]]

1. 在 ShadowCasterPass.hlsl 文件中，**我们可以在顶点函数中将顶点位置限制到阴影视椎体近裁剪平面中解决这个问题，把在近裁剪平面前面的阴影投射展平，让它们像黏在近裁剪平面上的花纹一样**。我们可以通过得到顶点在裁剪空间的 Z 和 W 分量之间的最大值，或在当 UNITY_REVERSED_Z 宏被定义时的两者之间的最小值来做到这一点，要让 W 分量使用正确的符号，需要乘上 UNITY_NEAR_CLIP_VALUE。 ^sqd3eh

```c
output.positionCS = TransformWorldToHClip(positionWS);

#if UNITY_REVERSED_Z
    output.positionCS.z =
min(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
#else
    output.positionCS.z =
max(output.positionCS.z, output.positionCS.w * UNITY_NEAR_CLIP_VALUE);
#endif
```


![[Pasted image 20230621105627.png]]
**这非常适用完全在近裁剪平面两侧的投射阴影，但可能对某些大三角形物体来说只影响了部分顶点，而与近裁剪平面有穿叉的投影则会变形，这对于那些小三角形来说，不是很明显。如下图所示，非常长的立方体阴影产生了变形：**
![[Pasted image 20230621105629.png]]


2. 我们通过**把阴影视椎体近裁剪平面向后拉一点来缓解该问题**。在 Shadows 脚本的 ShadowedDirectionalLight 结构体定义一个近裁剪平面偏移字段，在 ReserveDirectionalShadows 方法中创建该实例的时候把灯光的阴影视椎体近裁剪平面偏移属性值赋值给它。

```cs
struct ShadowedDirectionalLight
    {
        ...
        //阴影视椎体近裁剪平面偏移
        public float nearPlaneOffset;
    }
```

```cs
ShadowedDirectionalLights[ShadowedDirectionalLightCount] = new ShadowedDirectionalLight{ visibleLightIndex = visibleLightIndex,
slopeScaleBias = light.shadowBias,
nearPlaneOffset = light.shadowNearPlane };
```

3. 在 RenderDirectionalShadows 方法的 `cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives()` 调用中，将**第 6 个传参由 0 改为我们获取到的阴影视椎体近裁剪平面偏移值，然后我们就可以调节灯光组件上的 Near Plane 属性来调整效果了。**

```cs
cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(light.visibleLightIndex, i, cascadeCount,ratios, tileSize, light.nearPlaneOffset,
out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix, out ShadowSplitData splitData);
```
![[Pasted image 20230621105642.png]]


## 4.4.6 百分比切近滤波（PCF）

接下来该解决阴影的锯齿问题了。

**产生锯齿的原因**在于，判断一个片元是否在阴影内而进行深度测试时，要把该片元从当前摄像机观察空间转换到光源空间，因为转换矩阵不一样，且ShadowMap分辨率不大，导致观察空间中多个片元对应ShadowMap同一个纹素。例如两个黑色锯齿中间的空白部分，本来这部分也应该处于黑色阴影中的，但因为采样到的ShadowMap中的纹素刚好不是黑色的，即那个纹素刚好不在黑色阴影下，就会导致阴影锯齿。

**解决锯齿**最直接的办法就是提高ShadowMap分辨率，但内存占用会变大，这种方法也只是减轻问题。**实际开发中通常采用适中的分辨率的ShadowMap加上区域采样方法改善锯齿现象。**

**因为 ShadowMap 的纹素存储的不是颜色信息而是深度信息，对深度值取均值会产生不正确的深度结果，所以锯齿不能通过对某纹素周边邻接的纹素取值然后求平均来消除**。

百分比切近滤波（Percentage-Close Filtering，PCF）方法，是对阴影比较测试后的值进行滤波，可以使生成的阴影边缘平滑柔和。

PCF 方法具体步骤是：在片元着色器中，把当前操作的片元 f 先变换到光源空间，然后经过投影和视口变换到阴影深度贴图空间中，假设变换后深度值为 z，对应的贴图坐标为（u，v），该坐标对应的纹素深度值为 z0。进行到这一步，如果不使用 PCF 方法，那么直接就根据 z 和 z0 的大小判断该片元在阴影中全黑还是不在阴影中不黑。PCF 是对贴图坐标（u，v）处周边纹素也进行采样获取其深度值，再和当前片元的深度值 z 比较。如果在阴影中标识为 1，不在阴影中标识为 0，并把这些 01 值每项累加求平均值，这些平均值落在［0，1］中，这样阴影就有浓淡之分而不像未使用 PCF 方法之前的非明即暗，从而达到柔化边缘，减少锯齿的效果。

下图演示了 PCF 3X3 方法的采样效果：
![[Pasted image 20230621105647.png]]

1. 3X3 的滤波模式代表我们对 9 个纹理像素进行深度比较，一般常用的有 2X2、3X3、5X5 和 7X7，在 ShadowSettings 脚本中我们添加一个滤波模式枚举，将常用的模式添加进来，默认值设为 2X2。

```cs
 //PCF滤波模式
public enum FilterMode
{
    PCF2x2, PCF3x3, PCF5x5, PCF7x7
}
public struct Directional 
{
    public MapSize atlasSize;
    public FilterMode filter;
    ...
}
public Directional directional = new Directional 
{
    atlasSize = MapSize._1024,
    filter = FilterMode.PCF2x2,
    ...
};
```
![[Pasted image 20230621105702.png]]


2. 在 Shadows 脚本中添加一个静态字符串数组，然后添加一个 SetKeywords 方法，设置使用哪个滤波模式的关键字，最后在 RenderDirectionalShadows 方法中执行缓冲区之前调用 SetKeywords 方法。

```cs
//PCF滤波模式  
   static string[] directionalFilterKeywords =   
   {  
        "_DIRECTIONAL_PCF3",  
        "_DIRECTIONAL_PCF5",  
        "_DIRECTIONAL_PCF7",  
    };  
    //设置关键字开启哪种PCF滤波模式  
    void SetKeywords()  
    {  
        int enabledIndex = (int)settings.directional.filter - 1;  
        for (int i = 0; i < directionalFilterKeywords.Length; i++)  
        {  
            if (i == enabledIndex)  
            {  
                buffer.EnableShaderKeyword(directionalFilterKeywords[i]);  
            }  
            else  
            {  
                buffer.DisableShaderKeyword(directionalFilterKeywords[i]);  
            }  
        }  
    }  
    void RenderDirectionalShadows ()   
    {  
            ...  
            SetKeywords();  
            buffer.EndSample(bufferName);  
            ExecuteBuffer();  
    }
```

3. **较大的滤波模式需要更多的纹素样本**，我们需要知道阴影的图集大小和纹素大小，添加一个阴影图集大小的着色器标识 ID，然后在 RenderDirectionalShadows 方法中将图集大小和纹素大小传递给 GPU。

```cs
static int shadowAtlasSizeId = Shader.PropertyToID("_ShadowAtlasSize");  
void RenderDirectionalShadows()   
{  
     ...  
     //设置关键字  
     SetKeywords();  
     //传递图集大小和纹素大小  
     buffer.SetGlobalVector( shadowAtlasSizeId, new Vector4(atlasSize, 1f / atlasSize));  
}
```

4. 在 Shadows.hlsl 的_CustomShadows 缓冲区定义图集大小字段。

```c
CBUFFER_START(_CustomShadows)
    ...
    float4 _ShadowAtlasSize;
CBUFFER_END
```

5. 在 Lit.shader 的 CustomLit Pass 中添加这四个滤波模式关键字，_代表默认的 2X2。

```c
#pragma multi_compile _ _DIRECTIONAL_PCF3 _DIRECTIONAL_PCF5 _DIRECTIONAL_PCF7
 #pragma multi_compile_instancing
```

6. 我们将要**使用源码库 ShadowSamplingTent.hlsl 文件里定义的函数**，先将该文件 Include 到 Shadows.hlsl 文件的顶部。如果定义了 3X3 的滤波模式的关键字，则需要 4 个过滤器样本，因为每个样本都使用双线性 2X2 的滤波模式，在所有方向上偏移半个纹素的平方覆盖了 3×3 的 Tent Filter，其中心的权重大于边缘。然后**使用 `SampleShadow_ComputeSamples_Tent_3x3` 函数设置这些样本，5X5 需要 9 个滤波样本、7X7 需要 16 个滤波样本。**

```c
#ifndef CUSTOM_SHADOWS_INCLUDED
#define CUSTOM_SHADOWS_INCLUDED

 #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Shadow/ShadowSamplingTent.hlsl"
//如果使用的是PCF 3X3
#if defined(_DIRECTIONAL_PCF3)
//需要4个滤波样本
#define DIRECTIONAL_FILTER_SAMPLES 4
#define DIRECTIONAL_FILTER_SETUP SampleShadow_ComputeSamples_Tent_3x3
#elif defined(_DIRECTIONAL_PCF5)
#define DIRECTIONAL_FILTER_SAMPLES 9
#define DIRECTIONAL_FILTER_SETUP SampleShadow_ComputeSamples_Tent_5x5
#elif defined(_DIRECTIONAL_PCF7)
#define DIRECTIONAL_FILTER_SAMPLES 16
#define DIRECTIONAL_FILTER_SETUP SampleShadow_ComputeSamples_Tent_7x7
#endif
```

7. 创建 `FilterDirectionalShadow` 方法，参数是阴影图块的空间位置。**当定义了 `DIRECTIONAL_FILTER_SETUP` 关键字时，需要多次采样，否则只需调用一次 SampleDirectionalShadowAtlas 方法即可。**

```cs
float FilterDirectionalShadow (float3 positionSTS) {
    #if defined(DIRECTIONAL_FILTER_SETUP)
        float shadow = 0;
        return shadow;
    #else
        return SampleDirectionalShadowAtlas(positionSTS);
    #endif
}
```

8. `DIRECTIONAL_FILTER_SETUP` 方法需要传递四个参数，第一个 float4 类型的向量，其中 XY 分量是图集纹素大小，ZW 分量是图集尺寸，第二个参数是原始样本的位置，后两个是样本的权重和样本的位置。然后遍历所有滤波样本，将所有的样本权重进行累加。

```cs
float FilterDirectionalShadow(float3 positionSTS) 
{
    #if defined(DIRECTIONAL_FILTER_SETUP)
    //样本权重
    float weights[DIRECTIONAL_FILTER_SAMPLES];
    //样本位置
    float2 positions[DIRECTIONAL_FILTER_SAMPLES];
    float4 size = _ShadowAtlasSize.yyxx;
    DIRECTIONAL_FILTER_SETUP(size, positionSTS.xy, weights, positions);
    float shadow = 0;
    for (int i = 0; i < DIRECTIONAL_FILTER_SAMPLES; i++) 
    {
        //遍历所有样本得到权重和
        shadow += weights[i] * SampleDirectionalShadowAtlas(
        float3(positions[i].xy, positionSTS.z)
    );
}
    return shadow;
#else
    return SampleDirectionalShadowAtlas(positionSTS);
#endif
}
```

9. 最后在 GetDirectionalShadowAttenuation 方法中调用 FilterDirectionalShadow 方法得到经过调整后的阴影衰减。

```cs
//得到阴影的衰减
float GetDirectionalShadowAttenuation(DirectionalShadowData directional, ShadowData global, Surface surfaceWS) 
{
    ...
    float shadow = FilterDirectionalShadow(positionSTS);
    //最终衰减结果是阴影强度和采样衰减的线性差值
    return lerp(1.0, shadow, directional.strength);
}
```
![[Pasted image 20230621105818.png]]


![[Pasted image 20230621105821.png]]

10. 测试发现，**使用大的滤波模式可以使阴影更平滑，锯齿变得不明显，但是阴影痤疮会再次出现。我们需要增加法线偏差来匹配对应滤波模式的尺寸**，在 Shadows 脚本的 SetCascadeData 方法中**通过将纹素大小乘以 1 加上 SetCascadeData 中的滤波模式枚举值来根据滤波模式调整法线偏差的大小。**

**另外增加样本区域意味着最终在最后一个级联的包围球范围之外也有可能进行采样，要在计算包围球半径的平方之前，使用包围球半径减去经过调整后的纹素大小（偏差大小）来避免这种情况。**

```cs
void SetCascadeData (int index, Vector4 cullingSphere, float tileSize) 
{
    float texelSize = 2f * cullingSphere.w / tileSize;
    float filterSize = texelSize * ((float)settings.directional.filter + 1f);

    cullingSphere.w -= filterSize;
    //得到半径的平方值
    cullingSphere.w *= cullingSphere.w;
    cascadeCullingSpheres[index] = cullingSphere;

    cascadeData[index] = new Vector4(1f / cullingSphere.w, filterSize * 1.4142136f);
}
```


![[Pasted image 20230621105905.png]]
## 4.4.7 级联混合

现在的阴影已经比较柔和了，但是会使得**各级联之间的过渡更加明显**。可以**通过在级联之间添加一个过渡区域来进行相邻级联之间的混合从而使级联衰减更柔和一些**。

1. 在 Shadows.hlsl 文件的 ShadowData 结构体中添加一个级联混合的属性。后续使用它在相邻级联之间进行插值。

```cs
struct ShadowData 
{
    int cascadeIndex;
    //是否采样阴影的标识
    float strength;
    //级联混合
    float cascadeBlend;
};
```

2. 最初在 GetShadowData 方法中将级联混合属性设为 1，表示所选的级联处于完全的强度。然后**在循环中的对应级联被找到后，始终计算级联的阴影衰减强度。如果处在最后一个级联范围中，就像之前一样计算阴影强度，否则将阴影衰减强度赋值给级联混合属性。**

```cs
ShadowData GetShadowData (Surface surfaceWS) 
{
    ShadowData data;
    data.cascadeBlend = 1.0;
    ...
    for (i = 0; i < _CascadeCount; i++) 
    {
        float4 sphere = _CascadeCullingSpheres[i];
        float distanceSqr = DistanceSquared(surfaceWS.position, sphere.xyz);
        if (distanceSqr < sphere.w) 
        {
            //计算级联阴影的过渡强度
            float fade = FadedShadowStrength(distanceSqr, _CascadeData[i].x, _ShadowDistanceFade.z);
            //如果对象处在最后一个级联范围中
            if (i == _CascadeCount - 1) 
            {
                data.strength *= fade;
            }
            else 
            {
                data.cascadeBlend = fade;
            }
            break;

        }
    }
    ...
}
```

3. 在 `GetDirectionalShadowAttenuation` 方法中，**得到当前级联的阴影衰减后检查级联混合属性是否小于 1，小于 1 就代表对象现在在级联的过渡区域中，必须从下一个级联中进行采样ShadowMap并得到当前级联的阴影衰减，根据级联混合属性值对两个级联的阴影衰减强度进行插值。**

```cs
//得到阴影的衰减
float GetDirectionalShadowAttenuation(DirectionalShadowData directional, ShadowData global, Surface surfaceWS) 
{
    ...
    float shadow = FilterDirectionalShadow(positionSTS);
    //如果级联混合小于1代表在在级联层级过渡区域中，必须从下一个级联中采样并在两个值之间进行插值
    if (global.cascadeBlend < 1.0) 
    {
        normalBias = surfaceWS.normal *(directional.normalBias * _CascadeData[global.cascadeIndex + 1].y);
        positionSTS = mul(_DirectionalShadowMatrices[directional.tileIndex + 1],float4(surfaceWS.position + normalBias, 1.0)).xyz;
        shadow = lerp(FilterDirectionalShadow(positionSTS), shadow, global.cascadeBlend);
    }

    //最终衰减结果是阴影强度和采样衰减的线性差值
    return lerp(1.0, shadow, directional.strength);
}
```

## 4.4.8 级联衰减抖动

**虽然从级联混合效果上看起来不错，但这会使我们必须在级联混合区域中对 ShadowMap 多采样一次**。
有一种替代方法是**基于抖动模式始终从一个级联中采样**。虽然这看起来不太好，但是可以提升计算效率，也会减少一次采样，尤其在使用大的 PCF 过滤模式时。

1. 在 ShadowSettings 脚本中定义一个代表级联混合模式的枚举，支持 Hard，Soft 和 Dither 三种模式，默认赋值 Hard。

```cs
public enum CascadeBlendMode
       {
           Hard, Soft, Dither
       }
       public CascadeBlendMode cascadeBlend;

       public Directional directional = new Directional 
       {
           ...
           cascadeFade = 0.1f,
           cascadeBlend = Directional.CascadeBlendMode.Hard
       };
```

2. 在 Shadows 脚本中添加该级联混合模式关键字的静态字符串数组，调整 SetKeywords 方法，让它可以匹配传入的任何关键字的字符串数组和索引，然后在 RenderDirectionalShadows 方法中设置级联混合模式的关键字。

```cs
static string[] cascadeBlendKeywords = {"_CASCADE_BLEND_SOFT","_CASCADE_BLEND_DITHER"};
    void SetKeywords(string[] keywords, int enabledIndex)
    {
       // int enabledIndex = (int)settings.directional.filter - 1;
        for (int i = 0; i < keywords.Length; i++)
        {
            if (i == enabledIndex)
            {
                buffer.EnableShaderKeyword(keywords[i]);
            }
            else
            {
                buffer.DisableShaderKeyword(keywords[i]);
            }
        }
    }

void RenderDirectionalShadows () {
        ...
        SetKeywords(directionalFilterKeywords, (int)settings.directional.filter - 1);
        SetKeywords(cascadeBlendKeywords, (int)settings.directional.cascadeBlend - 1);
        buffer.SetGlobalVector(shadowAtlasSizeId, new Vector4(atlasSize, 1f / atlasSize));
        buffer.EndSample(bufferName);
        ExecuteBuffer();
}
```

3. 在 Lit.shader 的 CustomLit Pass 中添加这三种级联混合模式的关键字，_默认关键字代表 Hard 混合模式。

```cs
#pragma multi_compile _ _CASCADE_BLEND_SOFT _CASCADE_BLEND_DITHER
           #pragma multi_compile_instancing
```

4. 在 Surface 结构体中添加一个抖动属性。

```cs
struct Surface 
{
    ...
    float dither;
};
```

5. 在片元函数中我们生成抖动值，最简单的办法是使用源码库中的 `InterleavedGradientNoise` 方法，**传递屏幕空间顶点位置的 XY 分量，生成一个随机的抖动（噪声）值**。第二个参数用于动画，我们不需要，所以设为 0。

```cs
surface.smoothness =UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Smoothness);
    //计算抖动值
    surface.dither = InterleavedGradientNoise(input.positionCS.xy, 0);
```

6. 在 Shadows.hlsl 文件的 GetShadowData 方法中，**在设置级联索引前，判断级联混合模式是否为 Soft，如果是则将级联混合值设为 1。当混合模式为抖动模式时，如果我们不在最后一个级联中，且当级联混合值小于抖动值时，则跳到下一个级联。**

```cs
//如果超出级联范围，不进行阴影采样
if (i == _CascadeCount) 
{
    data.strength = 0.0;
}
#if defined(_CASCADE_BLEND_DITHER)
    else if (data.cascadeBlend < surfaceWS.dither) 
    {
        i += 1;
    }
#endif
#if !defined(_CASCADE_BLEND_SOFT)
    data.cascadeBlend = 1.0;
#endif
    data.cascadeIndex = i;
    return data;
```

## 4.4.9 剔除偏差

**使用级联 ShadowMap 有一个缺点，我们不止一次对每个光源渲染相同的投影。如果大的级联中的一些投影数据能被小的级联中的投影数据覆盖，就可以从大的级联中剔除这些投影**。
在 Shadows 脚本的 RenderDirectionalShadows 方法中将 splitData 的 shadowCascadeBlendCullingFactor 属性设置为 1 来实现这点。在渲染定向光阴影之前执行这个操作。

```cs
 //剔除偏差
splitData.shadowCascadeBlendCullingFactor = 1f;
            shadowSettings.splitData = splitData;
```

**该值是调节用于执行剔除的上一个级联的半径的因子。在剔除时，Unity 相当的保守，但我们应该通过级联衰减比例降低它，确保过渡区域中的投影不会被剔除**。在 RenderDirectionalShadows 方法中我们使用 0.8 减去级联衰减值，最小值限制到零。如果看到在级联衰减的阴影中出现孔洞，则必须进一步减少孔洞。

```cs
void RenderDirectionalShadows(int index, int split, int tileSize) {
    ...
    float cullingFactor = Mathf.Max(0f, 0.8f - settings.directional.cascadeFade);
    for (int i = 0; i < cascadeCount; i++) 
    {
        ...
        splitData.shadowCascadeBlendCullingFactor = cullingFactor;
        ...
    }
}
```

# 4.5 透明物体的投影
![[Pasted image 20230621105949.png]]


现在裁切模式的物体的投影是正确的，但是透明物体的投影感觉跟不透明物体的投影效果是一样的。


![[Pasted image 20230621105952.png]]
## ​4.5.1 裁剪阴影

1. 我们在 Lit.shader 的属性栏中添加一个调整投影模式的切换开关，可以选择开启、关闭、裁切和抖动阴影，默认投影阴影是开启状态。

```c
//投影模式
    [KeywordEnum(On, Clip, Dither, Off)] _Shadows ("Shadows", Float) = 0
```

2. Lit.shader 中"ShadowCaster"的 Pass 添加一组 Shader 关键字替换之前的_CLIPPING 关键字，现在只需要三个变体，_代表投影的开和关。

```c
//#pragma shader_feature _CLIPPING
    #pragma shader_feature _ _SHADOWS_CLIP _SHADOWS_DITHER
```

3. 在 CustomShaderGUI 脚本中定义一个表示投影模式的枚举，然后添加一个枚举属性决定定义哪种投影模式的关键字。

```c
enum ShadowMode 
    {
        On, Clip, Dither, Off
    }

    ShadowMode Shadows 
    {
        set 
        {
            if (SetProperty("_Shadows", (float)value)) 
            {
                SetKeyword("_SHADOWS_CLIP", value == ShadowMode.Clip);
                SetKeyword("_SHADOWS_DITHER", value == ShadowMode.Dither);
            }
        }
    }
```

4. 还需在 ShadowCasterPass.hlsl 文件的片元函数中，将判断是否定义了_CLIPPING 的关键字替换为_SHADOWS_CLIP。

```cs
#if defined(_SHADOWS_CLIP)
        clip(base.a - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff));
    #endif
```

下图是透明物体使用裁剪投影模式的效果。
![[Pasted image 20230625210722.png|500]]


​现在透明物体可以裁剪阴影了，这可能适合物体表面部分大多是完全不透明或透明的，且透明度混合也是必要的。需要注意的是，裁剪的阴影是不稳定的，当视图移动时阴影转换矩阵会发生变化，会造成片元稍有移动，可能会导致ShadowMap的纹素突然从裁剪状态过渡到未裁剪状态。

## 4.5.2 抖动阴影

抖动和裁剪的条件是不同的，但作用相同，我们在片元函数中用表面的 Alpha 值减去抖动值来进行片元裁剪。

```cs
#if defined(_SHADOWS_CLIP)
    //透明度低于阈值的片元进行舍弃
    clip(base.a - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff));
#elif defined(_SHADOWS_DITHER)
    float dither = InterleavedGradientNoise(input.positionCS.xy, 0);
    clip(base.a - dither);
#endif
```

下图是透明物体使用抖动投影模式的效果。
![[Pasted image 20230621110002.png|500]]


​抖动可以用于半透明物体的投影，但硬抖动阴影看起来很糟糕，不过在使用较大的 PCF 过滤模式时，它看起来效果还不错，下图是 PCF 7X7 模式下的效果。
![[Pasted image 20230621110024.png|500]]

​**由于抖动投影模式会固定每个纹素，重叠的半透明投影不会投射组合的较暗阴影，投影效果和不透明物体的投影一样强**。此外，由于该模式的抖动值是一个噪声值，当阴影转换矩阵发生变化时，会使阴影看起来在抖。**此模式适用于具有固定投影（投影对象不移动）的其它光源类型**，**对于半透明物体，使用裁剪投影模式或关闭投影通常更好一些。**

## 4.5.3 不投影

我们可以**通过禁用材质的 ShadowCaster Pass 来实现对每种材质投影的灵活禁用**。在 CustomShaderGUI 脚本中添加 SetShadowCasterPass 方法，首先检查_Shadows 着色器属性是否存在，且所有选定的材质是否设置为相同的混合模式。条件都满足后，遍历所有材质通过其 SetShaderPassEnabled 方法的调用来选择启用或禁用 ShadowCaster Pass。

然后在 OnGUI 方法的最后检查是否有材质属性被更改，来重新检查和设置材质的 ShadowCaster Pass 的状态。

```cs
//设置材质的ShadowCaster pass是否启用
    void SetShadowCasterPass()
    {
        MaterialProperty shadows = FindProperty("_Shadows", properties, false);
        if (shadows == null || shadows.hasMixedValue)
        {
            return;
        }
        bool enabled = shadows.floatValue < (float)ShadowMode.Off;
        foreach (Material m in materials)
        {
            m.SetShaderPassEnabled("ShadowCaster", enabled);
        }
    }
 
    public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)
    {
        EditorGUI.BeginChangeCheck();
        ...
        if (EditorGUI.EndChangeCheck())
        {
            SetShadowCasterPass();
        }
    }
```


![[Pasted image 20230621110049.png]]
另外，我们在前面的小节中还编写了一个不受光的着色器 Unlit.shader，如果想要该着色器支持投影，可以把 Lit.shader 中的 ShaderCaster Pass 拷贝过来，就可以投影了。

![[Pasted image 20230621110051.png]]
## ​4.5.4 接受阴影

我们在 Lit.shader 的属性栏中定义一个是否接受投影的切换开关，默认为接受投影，并定义一个与其关联的关键字。

```c
[Toggle(_RECEIVE_SHADOWS)] _ReceiveShadows ("Receive Shadows", Float) = 1
```

```c
#pragma shader_feature _RECEIVE_SHADOWS
```

在 Shadows.hlsl 文件的 GetDirectionalShadowAttenuation 方法最前面判断是否接受阴影，如果不接受则阴影衰减直接返回 1 就可以了。

```c
float GetDirectionalShadowAttenuation(DirectionalShadowData directional, ShadowData global, Surface surfaceWS) 
{
    //如果不接受阴影，阴影衰减为1
#if !defined(_RECEIVE_SHADOWS)
    return 1.0;
#endif
    ...
}
```

![[Pasted image 20230621110102.png]]