---
title: 《数据持久化》
aliases: []
tags: []
create_time: 2023-06-08 00:15
uid: 202306080015
banner: "[[Pasted image 20230716220142.png]]"
---

![[Pasted image 20230611210946.png]]
**什么是数据持久化？**
数据持久化就是将内存中的数据模型转换为存储模型, 以及将存储模型转换为内存中的数据模型的统称
说人话: **将游戏数据存储到硬盘，硬盘中数据读取到游戏中，也就是传统意义上的存盘。**

**如何理解不同后缀的文件?**
文件后缀名决定了文件的格式
不同的软件可以根据后缀名用来判断文件的类型并且在打开文件时以特定的读取规则去解析它
文件后缀名是人为定的规则可以有无数种，可以自定义

# Playerprefs
## 基本方法
prefs：控制台

- Playerprefs 是 unity 提供的可以用于**存储读取玩家数据的公共类**
- PlayerPrefs 的数据存储类似于**键值对**存储，一个键对应一个值
    - 提供了存储 3 种数据的方法：int float string
    - 键：string 类型
    - 值：int float string  对应 3 种 API
- 如果不同类型用同一键名进行存储，会覆盖数据


> [!NOTE] 数据的唯一性
> PlayerPrefs 中不同数据的唯一性是由 key 决定的，不同的 key 决定了不同的数据，同一项目中如果不同数据 key 相同，会造成数据丢失要保证数据不丢失，就要建立一个保证 key 唯一的规则。

```cs file:存储数据
//直接调用set相关方法只会把数据存到内存里
//当游戏结束时 Unity会自动把数据存到硬盘中
PlayerPrefs.SetInt("myAge",18);  
PlayerPrefs.SetFloat("myHeight",1.75f);
PlayerPrefs.SetString("myName","张三");

//如果游戏不是正常结束的，而是崩溃，数据是不会存到硬盘中的
//可以调用save方法手动把数据存到硬盘中
PlayerPrefs.Save();
```

**注意运行时只要你 set 了对应键值对，即使你没有马上存储 save 在本地，也能够读取出信息**
```cs file:读取数据
int age = PlayerPrefs.GetInt("myAge",20); //可选第二参数，如果找不到myAge的值，就会返回第二个参数   
float height = PlayerPrefs.GetFloat("myHeight");
string name = PlayerPrefs.GetString("myName");
```

```cs file:判断数据是否存在
if(PlayerPrefs.HasKey("myAge"))
{
    print("myAge存在");
}
```

```cs file:删除数据
//删除单个数据
PlayerPrefs.DeleteKey("MyAge");
//删除所有存储的数据
PlayerPrefs.DeleteAll();
```

## 存储其他类型
PlayerPrefs 是有局限性的它只能存 3 种类型的数据，如果你想要存储别的类型的数据只能降低精度或者上升精度来进行存储，当然也可采用下面的小 trick：

```cs file:trick存储bool类型
bool sex = true;
PlayerPrefs.SetInt( "sex", sex ? 1 : 0);
```

**存储更复杂的 List<> 类型**

```cs file:存储更复杂的List<>类型


public class Player
{
    private string _name;
    public int _age;
    private int _atk;
    private int _def;

    //装备信息
    public List<Equipment> EquipmentsList;

    //该变量时一个存储和读取的唯一key标识。识别多个玩家，分别存储
    private string _keyName;

    public void Save()
    {
        PlayerPrefs.SetString(_keyName + "name", _name);
        PlayerPrefs.SetInt(_keyName + "age", _age);
        PlayerPrefs.SetInt(_keyName + "atk", _atk);
        PlayerPrefs.SetInt(_keyName + "def", _def);

        //装备信息
        PlayerPrefs.SetInt("EquipmentsCount", EquipmentsList.Count);
        for (int i = 0; i < EquipmentsList.Count; i++)
        {
            //存储每一个装备的id和数量
            PlayerPrefs.SetInt("EquipmentsID" + i, EquipmentsList[i]._id);
            PlayerPrefs.SetInt("EquipmentsCount" + i, EquipmentsList[i]._count);
        }
    }

    public void Load(string keyName)
    {
        this._keyName = keyName; 
        
        _name = PlayerPrefs.GetString(keyName + "name", "test");
        _age = PlayerPrefs.GetInt(keyName + "age", 18);
        _atk = PlayerPrefs.GetInt(keyName + "atk", 100);
        _def = PlayerPrefs.GetInt(keyName + "def", 1000);

        //装备信息
        int num = PlayerPrefs.GetInt("EquipmentsCount", 0);
        EquipmentsList = new List<Equipment>();
        for (int i = 0; i < num; i++)
        {
            Equipment equipment = new Equipment();
            equipment._id = PlayerPrefs.GetInt("EquipmentsID" + i, 0);
            equipment._count = PlayerPrefs.GetInt("EquipmentsCount" + i, 0);
            EquipmentsList.Add(equipment);
        }
    }
}

public class Equipment
{
    public int _id;
    public int _count;
}

public class NewBehaviourScript1 : MonoBehaviour
{
    void Start()
    {
        Player player1 = new Player();
        player1.Load("Player1");

        print("装备列表数量：" + player1.EquipmentsList.Count);

        for (int i = 0; i < player1.EquipmentsList.Count; i++)
        {
            print("道具ID：" + player1.EquipmentsList[i]._id);
            print("道具数量：" + player1.EquipmentsList[i]._count);
        }


        Equipment equipment1 = new Equipment();
        equipment1._id = 1;
        equipment1._count = 1;

        Equipment equipment2 = new Equipment();
        equipment2._id = 2;
        equipment2._count = 2;

        player1.EquipmentsList.Add(equipment1);
        player1.EquipmentsList.Add(equipment2);

        player1.Save();

        print("装备列表数量：" + player1.EquipmentsList.Count);
        for (int i = 0; i < player1.EquipmentsList.Count; i++)
        {
            print("道具ID：" + player1.EquipmentsList[i]._id);
            print("道具数量：" + player1.EquipmentsList[i]._count);
        }
        
        Player player2 = new Player();
        player2.Load("Player2");
        //...
        player2.Save();
        
        //...
    }
}
```

## 存储位置
不同平台存储位置不同
**Win**
存储在 `HKCU\Software\[公司名称]\[产品名称]` 项下的注册表中
其中公司和产品名称是在“Project settings”中设置的名称。 

1. 运行 regedit
2.  `HKEY_CURRENT_USER/SOFTWARE/Unity/UnityEditor/`公司名称/产品名称
**安卓**
`/data/ data/包名/shared_prefs/pkg-name .xml`
 
**IOS**
`/Librany/Preferences/[应用 ID]. plist`


单独使用它的原生功能，非常适合存储一些对安全性要求不高的简单数据
但是也不能小看它，对它进行简单的封装，也可以让它变得方便又安全

## Playerprefs 数据管理类 
```cs
/*
 * 数据管理类提供给外部的方法：
 * 1. 存储数据
 * 2. 读取数据
 * 3. 外部可以传入数据直接进行存储
 * 4. 外部可以传入数据类型直接进行数据获取
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using Unity.VisualScripting;
using Unity.VisualScripting.FullSerializer;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// PlayerPrefs数据管理类，统一管理数据的存储和读取
/// </summary>
public class PlayerPrefsDataManager
{
    //单例模式
    private static PlayerPrefsDataManager instance = new PlayerPrefsDataManager();

    public static PlayerPrefsDataManager Instance
    {
        get { return instance; }
    }

    private PlayerPrefsDataManager()
    {

    }

    /// <summary>
    /// 存储数据
    /// </summary>
    /// <param name="data">数据对象</param>
    /// <param name="keyName">数据对象的唯一性key，自己控制</param>
    public void SaveData(object data, string keyName)
    {
        //就是要通过Type得到传入数据对象的所有的字段
        //然后结合aYerPrefs来进行存储

        #region 第一步：获取传入数据对象的所有字段

        Type dataType = data.GetType();
        //得到所有字段
        FieldInfo[] fieldInfos = dataType.GetFields();

        #endregion

        #region 第二步：自己定义一个key的规则，进行数据存储

        //我们存储都是通过PlayerPrefs来进行存储的
        //保证key的唯一性我们就需要自己定一个key的规则
        //key的规则：keyName_数据类型_字段类型_字段名

        #endregion

        #region 第三步：遍历这些字段，进行数据存储

        string saveKeyName = "";
        FieldInfo info;
        for (int i = 0; i < fieldInfos.Length; i++)
        {
            //对每一个字段，进行数据存储
            //得到具体的字段信息
            info = fieldInfos[i];
            //通过FieldInfo可以直接获取到字段的类型和字段的名字
            saveKeyName = keyName + "_" + dataType.Name + "_" + info.FieldType + "_" + info.Name;

            //现在得到了Key按照我们的规则
            //接下来就要来通过PlayerPrefs来进行存储
            SaveValue(info.GetValue(data), saveKeyName);
        }
        
        PlayerPrefs.Save();
        #endregion

    }

    /// <summary>
    /// 存储值
    /// </summary>
    /// <param name="value">数据对象</param>
    /// <param name="saveKeyName">数据对象的唯一性key</param>
    private void SaveValue(object value, string saveKeyName)
    {
        //直接通过PlayerPrefs来进行存储了
        //就是根据数据类型的不同来决定使用哪一个API来进行存储
        //PlayerPrefs只支持3种类型存储
        //判断数据类型是什么类型 然后调用具体的方法来存储
        Type fieldType = value.GetType();

        //int,float,string类型存储
        //类型判断
        if (fieldType == typeof(int))
        {
            PlayerPrefs.SetInt(saveKeyName, (int)value);
        }
        else if (fieldType == typeof(float))
        {
            PlayerPrefs.SetFloat(saveKeyName, (float)value);
        }
        else if (fieldType == typeof(string))
        {
            PlayerPrefs.SetString(saveKeyName, value.ToString());
        }
        else if (fieldType == typeof(bool))
        {
            //自己顶一个存储bool的规则
            PlayerPrefs.SetInt(saveKeyName, (bool)value ? 1 : 0);
        }

        //List<T>类型存储
        //如何判断泛型类的类型？比如List<T>
        //通过反射判断父子关系
        //这相当于判断字段是不是IList的子类
        //为什么想到IList，可以通过List查看他的父类，IList是List的父类，因此可以用父类装子类
        else if (typeof(IList).IsAssignableFrom(fieldType))
        {
            //父类装子类
            IList list = value as IList;
            //先存储数量
            PlayerPrefs.SetInt(saveKeyName, list.Count);
            int index = 0;
            foreach (object obj in list)
            {
                //存储具体的值
                SaveValue(obj, saveKeyName + index); //递归！
                ++index;
            }
        }

        //Dictionary<T>类型存储
        //同理，IDictionary是Dictionary的父类
        else if (typeof(IList).IsAssignableFrom(fieldType))
        {
            //父类装子类
            IDictionary dictionary = value as IDictionary;
            //先存储字典长度
            PlayerPrefs.SetInt(saveKeyName, dictionary.Count);
            //遍历存储字典里面的具体值
            int index = 0;
            foreach (object key in dictionary.Keys)
            {
                SaveValue(key, saveKeyName + "_key_" + index); //递归！
                SaveValue(dictionary[key], saveKeyName + "_value_" + index);
                ++index;
            }

        }

        //存储自定义类类型
        else
        {
            SavaData(value, saveKeyName); //递归
        }
    }


    /// <summary>
    /// 读取数据
    /// </summary>
    /// <param name="type">想要读取数据的数据类型</param>
    /// <param name="keyName">数据对象的唯一性key，自己控制</param>
    public object LoadData(Type type, string keyName)
    {
        //不用object对象传入 而使用Type传入的原因是:
        //object对象传入的话，必须在外部new一个对象传入
        //而Type传入的话，只需要一个Type typeof(Player)，就可以直接使用Activator.CreateInstance(type)来创建对象
        //这样可以少写一行代码

        //根据你传入的类型和keyName
        //依据你存储数据时key的拼接规则来进行数据的获取赋值返回出去

        //根据传入的Type 创建一个对象用于存储数据
        object data = Activator.CreateInstance(type);

        //要往这个new出来的对象中填充数据
        //得到所有字段
        FieldInfo[] fieldInfos = type.GetFields();
        //用于拼接key的字符串
        string saveKeyName = "";
        FieldInfo info;
        for (int i = 0; i < fieldInfos.Length; i++)
        {
            info = fieldInfos[i];
            //key的拼接规则，一定和存储时一模一样
            saveKeyName = keyName + "_" + type.Name + "_" + info.FieldType + "_" + info.Name;
            //有key就可以结合Playerprefs来读取数据
            //填充数据到data中
            info.SetValue(data, LoadValue(info.FieldType, saveKeyName));
        
        }

        return data;
    }

    /// <summary>
    /// 得到单个数据的方法
    /// </summary>
    /// <param name="fieldType">字段类型，用于判断用哪个api来读取</param>
    /// <param name="saveKeyName">用于获取具体数据</param>
    /// <returns></returns>
    private object LoadValue(Type fieldType, string saveKeyName)
    {
        if (fieldType == typeof(int))
        {
            return PlayerPrefs.GetInt(saveKeyName, 0);
        }
        else if (fieldType == typeof(float))
        {
            return PlayerPrefs.GetFloat(saveKeyName, 0);
        }
        else if (fieldType == typeof(string))
        {
            return PlayerPrefs.GetString(saveKeyName, "");
        }
        else if (fieldType == typeof(bool))
        {
            return PlayerPrefs.GetInt(saveKeyName, 0) == 1 ? true : false;
        }
        else if (typeof(IList).IsAssignableFrom(fieldType))
        {
            //得到长度
            int count = PlayerPrefs.GetInt(saveKeyName, 0);
            //创建一个list用于存储数据
            IList list = Activator.CreateInstance(fieldType) as IList;
            for (int i = 0; i < count; i++) 
            {
                //递归
                list.Add(LoadValue(fieldType.GetGenericArguments()[0], saveKeyName + i));
            }
        
            return list;
        }
        else if (typeof(IDictionary).IsAssignableFrom(fieldType))
        {
            //得到长度
            int count = PlayerPrefs.GetInt(saveKeyName, 0);
            //创建一个dictionary用于存储数据
            IDictionary dictionary = Activator.CreateInstance(fieldType) as IDictionary;
            for (int i = 0; i < count; i++)
            {
                //递归
                dictionary.Add(LoadValue(fieldType.GetGenericArguments()[0], saveKeyName + "_key_" + i),
                    LoadValue(fieldType.GetGenericArguments()[1], saveKeyName + "_value_" + i));
            }

            return dictionary;
        }
        else
        {
            //自定义类类型
            return LoadData(fieldType, saveKeyName);
        }
    }
}
```

### 案例
```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerInfo
{
    public int age;
    public string name;
    public float height;
    public bool sex;

    public List<int> list;

    public Dictionary<int, string> dic1;
    
    //以下都属于自定义类型存储
    public ItemInfo itemInfo;

    public List<ItemInfo> itemList;

    public Dictionary<int, ItemInfo> dic2;

}

public class ItemInfo
{
    public int id;
    public int num;

    public ItemInfo()
    {
        
    }
    
    public ItemInfo(int id, int num)
    {
        this.id = id;
        this.num = num;
    }
}
public class Test : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        //读取数据
        PlayerInfo p1 = PlayerPrefsDataManager.Instance.LoadData(typeof(PlayerInfo),"Player1") as PlayerInfo;
        
        //游戏逻辑中回去修改这个玩家数据
        p1.age = 18;
        p1.name = "张三";
        p1.height = 185;
        p1.itemList.Add(new ItemInfo(1, 123));
        p1.itemList.Add(new ItemInfo(2, 456));
        p1.dic1.Add(3, "长剑");
        p1.dic2.Add(4, new ItemInfo(3,789));
        
        //需要把这个数据对象的信息 存储到硬盘
        PlayerPrefsDataManager.Instance.SaveData(p1, "player1");
    }
    
    // Update is called once per frame
    void Update()
    {
        
    }
}
```
# Json
全称：JavaScript 对象简谱 (JavaScript Object Notation) 
Json 是国际通用的一种轻量级的数据交换格式
主要在网络通讯中用于传输数据，或本地数据存储和读取
易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率
![[Pasted image 20230611211123.png]]
我们一般**使用 Json 文件来记录和传输数据**

Json 文档就是使用 Json 格式配置填写的文档后缀一般为.json
我们在游戏中可以把游戏数据按照 Json 的格式标准存储在 Json 文档中，再将 Json 文档存储在硬盘上或者传输给远端，达到数据持久化或者数据传输的目的。

|**Json 和 Xml 的异同（Json 更好用！）** |   |
|:--|:--|
|**共同点**|**不同点**|
|都是纯文本|Json配置更简单|
|都有层级结构|Json在某些情况下读写更快速|
|都具有描述性|  |

**优点**
1. 和 XML 一致的优点
    1.  Json 是国际通用规则
    2. 跨平台（游戏，软件，网页等等都能用，不同操作系统也能用)
    3. 文件结构清晰易懂，非常容易编辑和理解
    4. 可以用于网络通信交换数据

**缺点**
1. 重复工作量繁多
    1. 自定义数据类，都需要自己去实现存储读取的功能
    2. 而且代码的相似度极高
2. 数据容易被修改，只要找到文件位置，就可以轻易的进行数据修改

**主要用处：**
网络游戏：可以用于存储一些客户端的简单不重要数据，可以用于传输信息
单机游戏：用于存储游戏相关数据，用于配置游戏数据（结合 UI 第三部曲一起讲解)

## 语法规则
注释格式和 cs 一样，`//` 或者 `/* */`
![[Pasted image 20230611211909.png]]
{
"vertexIndex":123
"pressure":165
}
![[Pasted image 20230611212009.png]]
```json
{
    "name":"大卫",
    "age":18,
    "sex":true,
    "ids":[1,2,3,4,5,6],
    "students":[
        {"name":"小红","age":16,"sex":true},
        {"name":"小明","age":15,"sex":false}
    ],
    "home":{"address":"成都","street":"春熙路"},
    "son":null,
    
    //字典类型，键会变成双引号以后转换时要注意!!!
    "dic":{"1":"123","2": "234"}
}
```
Json 格式是一种键值对结构
![[Pasted image 20230611211722.png|450]]

> [!NOTE] 注意事项
> 
> 1. 如果数据表示对象，那么最外层有大括号
> 2. 一定是键值对形式
> 3. **键一定是字符串格式** 
> 4. 键值对用逗号分开 
> 5. 数组用 `[ ]` 包裹 
> 6. 对象用`{}`包裹

### Excel 转 Json
1. 在 Excel 表中配置游戏数据——更方便策划人员配置
2. 将 Excel 表中配置的数据转为 Json 配置——方便将数据读取到内存中

![[Pasted image 20230611213325.png]]
上图 XML 中的数据对应的 Excel 表如下：

| hp | speed  | volume | resName           | scale |
|----|--------|--------|-------------------|-------|
| 4  | 6      | 5      | Airplane/Airplan1 | 15    |
| 3  | 7      | 4      | Airplane/Airplan2 | 15    |
| 2  | 8      | 3      | Airplane/Airplan3 | 15    |
| 10 | 3      | 10     | Airplane/Airplan4 | 6     |
| 6  | 5      | 7      | Airplane/Airplan5 | 10    |

转换方法：
1. 在百度或者 Google 搜索 Excel 转 Json.
2.  在线转换网站 https://www.bejson.com/json/col2json/
3. 进行转换
4. 保存 Json 格式的数据

**转换结果如下：**
![[Pasted image 20230611214123.png|450]]

```Json file:Roleinfo.json
[
{"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
{"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
{"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
{"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
{"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
]
```

## JsonUtlity
`JsonUtlity` 是 unity 自带的用于解析 Json 的公共类

> [!NOTE] 序列化与反序列化
>1. 序列化是将对象转换为二进制流的过程。把内存中的数据（类的对象数据）存储到硬盘上。
>2. 反序列化是将二进制流转换为对象的过程。把硬盘上的数据读取到内存（类的对象数据）中
>3. 序列化主要解决对象的传输问题。

**功能：**
1. 将内存中对象序列化为 Json 格式的字符串 
2. 将 Json 字符串反序列化为类对象

### 在文件中读写字符串
导入命名空间 `using System.IO;`

文件夹路径相关： [[《Unity Primer》#1 文件夹路径获取]]

```cs
//1.存储字符串到指定路径文件中
//参数一：是存储的路径（若路径中有文件夹名，必须保证文件夹存在）
//参数二：存储的字符串内容
File.WriteAllText(Application.persistentDataPath + "/test.json", "Hello World"); 
print(Application.persistentDataPath); //打印路径方便定位文件

//2.在指定路径文件中读取字符串
string str = File.ReadAllText(Application.persistentDataPath + "/test.json");
print(str); 
        
```


### 序列化
**序列化：把内存中的数据（类的对象数据）存储到硬盘（以 Json 文件等方式保存）上**  
**方法**：`JsonUtility.ToJson(对象)` 把对象转换成json字符串

**注意:**
1. float 序列化时看起来会有一些误差
2. 自定义类需要加上序列化特性`[System.Serializable]`
3. 想要序列化私有变量需要加上特性 `[SerializeField]`
4. `JsonUtility` 不支持字典
5. `JsonUtlity` 存储 null 对象不会是 null ，而是默认值的数据

```cs file:序列化
[System.Serializable]
public class Student
{
    public int age;
    public string name;

    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

[System.Serializable]
public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<int, string> dic1;
    public Dictionary<string,string> dic2;
    
    public Student stu;
    public List<Student> stus;
    
    [SerializeField]
    private int id;
    [SerializeField]
    protected string address;
}

public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 创建类的对象
        MyData data = new MyData();
        
        data.name = "张三";
        data.age = 18;
        data.height = 1.75f;
        data.weight = 175.0;
        data.sex = true;
        
        data.ids1 = new int[]{1,2,3,4,5};
        data.ids2 = new List<int>(){1,2,3,4,5};
        data.dic1 = new Dictionary<int, string>()
        {
            {1,"张三"},
            {2,"李四"},
            {3,"王五"},
        };
        data.dic2 = new Dictionary<string, string>()
        {
            { "1", "123" },
            { "2", "456" },
            { "3", "789" },
        };

        data.stu = null;
        
        data.stus = new List<Student>()
        {
            new Student(18, "张三"),
            new Student(12, "张s"),
            new Student(18, "张sd"),
        };

        //2. 序列化，存储字符串
        string jsonStr = JsonUtility.ToJson(data);
        File.WriteAllText(Application.persistentDataPath+ "/data.json", jsonStr);
        print(Application.persistentDataPath);
    }
}
```

得到的 Json 文件内容如下：
```json file:data.json
{"name":"张三","age":18,"height":1.75,"weight":175.0,"sex":true,"ids1":[1,2,3,4,5],"ids2":[1,2,3,4,5],"stu":{"age":0,"name":""},"stus":[{"age":18,"name":"张三"},{"age":12,"name":"张s"},{"age":18,"name":"张sd"}],"id":0,"address":""}
```

### 反序列化
**反序列化：把硬盘上的数据（Json 文件数据）读取到内存（类的对象数据）中**

方法：`JsonUtility.FromJson(字符串)`

以 data. json 为例，我们对它反序列化：
```json file:data.json
{"name":"张三","age":18,"height":1.75,"weight":175.0,"sex":true,"ids1":[1,2,3,4,5],"ids2":[1,2,3,4,5],"stu":{"age":0,"name":""},"stus":[{"age":18,"name":"张三"},{"age":12,"name":"张s"},{"age":18,"name":"张sd"}],"id":0,"address":""}
```

```cs file:反序列化
//反序列化要求我们要写出符合Json文件内容的数据结构
[System.Serializable]
public class Student
{
    public int age;
    public string name;

    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}
[System.Serializable]
public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<int, string> dic1;
    public Dictionary<string,string> dic2;
    
    public Student stu;
    public List<Student> stus;
    
    [SerializeField]
    private int id;
    [SerializeField]
    protected string address;
}


public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 读取文件中的Json字符串
        string jsonStr = File.ReadAllText(Application.persistentDataPath+ "/data.json");
        
        //2. 反序列化,将Json字符串转换为类对象
        //MyData data = JsonUtility.FromJson(jsonString,typeof(MyData)) as MyData;
        //更推荐使用泛型方法！！！
        MyData data = JsonUtility.FromJson<MyData>(jsonStr);
        
        //3. 获取data对象的信息
        print(data.age); 
        print(data.name);
        print(data.height);
        //...省略
    }
}
```

### 注意事项
1. **`JsonUtlity` 无法直接读取数据集合（用 `[]` 包含的数组）**
2. Json文本编码格式要时 UTF-8 不然无法加载

前文我们得到了一个 json 文件内容如下，如果直接对其反序列化会报错，因为 Unity 反序列化不支持读取数组
```Json file:Roleinfo.json
[
{"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
{"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
{"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
{"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
{"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
]
```

```cs
[System.Serializable]
public class Roleinfo
{
    public int hp;
    public int speed;
    public int volume;
    public string resName;
    public int scale;
} 

jsonStr = File.ReadAllText(Application.streamingAssetsPath + "/Roleinfo.json");
print(jsonstr);

//企图用一个List数组储存,报错！
List<Roleinfo> roleinfoList = JsonUtility.FronJson<List<Roleinfo>>(jsonStr);
```

**正确的读取方法：**
1. 修改 Json 文件：
```cs
{
    "List":[
    {"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
    {"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
    {"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
    {"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
    {"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
    ]
}
```

2. 添加类, 然后读取
```cs
[System.Serializable]
public class Roleinfo
{
    public int hp;
    public int speed;
    public int volume;
    public string resName;
    public int scale;
} 

[System.Serializable]
public class RoleData
{
    public List<RoleInfo> list;
}


jsonStr = File.ReadAllText(Application.streamingAssetsPath + "/Roleinfo.json");
print(jsonstr);

RoleData data = JsonUtility.FronJson<RoleData>(jsonStr); //反序列化成功
```

## LitJson
- LitJson 是一个第三方库，用于处理 Json 的序列化和反序列化 
- LitJson 是 cs 编写的，体积小、速度快、易于使用
- 它可以很容易的嵌入到我们的代码中
- 只需要将 LitJson 代码拷贝到工程中即可


### 获取 LitJson
1. 前往 LitJson 官网[LitJSON - Home](https://litjson.net/)
2. 通过官网前往 GitHub 获取最新版本代码
3. 将 src 文件夹下的 LitJson 文件夹拷贝到 unity 工程中，即可开始使用 LitJson
4. 使用时引用 LitJson 命名空间 `using LitJson;`
### 序列化
方法：`JsonMapper.ToJson(对象)`

注意:
1. 相对 JsonUtlity **不需要加特性**
2.  **不能序列化私有变量**
3. **支持字典类型**，建议**字典的键值都是字符串**，因为 Json 的特点，键会加上双引号
4. 可以保存 null 类型

```cs file:序列化
public class Student
{
    public int age;
    public string name;

    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<string,string> dic;
    
    public Student stu;
    public List<Student> stus;
    
    private int id;
    protected string address;
}


public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 创建类的对象
        MyData data = new MyData();
        
        data.name = "张三";
        data.age = 18;
        data.height = 1.75f;
        data.weight = 175.0;
        data.sex = true;
        
        data.ids1 = new int[]{1,2,3,4,5};
        data.ids2 = new List<int>(){1,2,3,4,5};
        data.dic = new Dictionary<string, string>()
        {
            { "1", "123" },
            { "2", "456" },
            { "3", "789" },
        };

        data.stu = null;
        
        data.stus = new List<Student>()
        {
            new Student(18, "张三"),
            new Student(12, "张s"),
            new Student(18, "张sd"),
        };
        
        //2. 序列化，存储字符串
        string jsonStr = JsonMapper.ToJson(data);
        File.WriteAllText(Application.persistentDataPath+ "/data.json", jsonStr);
        print(Application.persistentDataPath);
    }
}

```

得到的 Json 文件内容如下：

```json file:data.json
{"name":"\u5F20\u4E09","age":18,"height":1.75,"weight":175.0,"sex":true,"ids1":[1,2,3,4,5],"ids2":[1,2,3,4,5],"dic":{"1":"123","2":"456","3":"789"},"stu":null,"stus":[{"age":18,"name":"\u5F20\u4E09"},{"age":12,"name":"\u5F20s"},{"age":18,"name":"\u5F20sd"}]}
```

### 反序列化
**方法：** `JsonMapper.ToObject(字符串)`

**注意：**
1. **类结构需要无参构造函数**，否则反序列化时报错
2. 字典虽然支持，但是**键**在使用为数值时会有问题，**需要使用字符串类型**


```cs
public class Student
{
    public int age;
    public string name;

    //因为这里自己写了构造函数覆盖掉了无参构造函数
    //所以要手动添加无参构造函数
    public Student()
    { }
    
    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<string,string> dic;
    
    public Student stu;
    public List<Student> stus;
    
    private int id;
    protected string address;
}

public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 读取文件中的Json字符串
        string jsonStr = File.ReadAllText(Application.persistentDataPath+ "/data.json");
        
        //2. 反序列化，将Json字符串转换为类对象
        MyData data = JsonMapper.ToObject<MyData>(jsonStr);
        
        //3. 获取data对象的信息
        print(data.age);
        print(data.name);
        print(data.height);
        //省略...
    }
}
```

### 注意事项
1. LitJson **可以直接读取数据集合**（用 `[]` 包含的数组）
2. 文本编码格式需要是 UTF-8， 不然无法加载

前文我们得到了一个 json 文件内容如下，对其进行反序列化
```Json file:Roleinfo.json
[
{"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
{"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
{"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
{"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
{"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
]
```

```cs
public class RoleInfo
{
    public int hp;
    public int speed;
    public int volume;
    public string resName;
    public int scale;
} 

jsonStr = File.ReadAllText(Application.streamingAssetsPath + "/RoleInfo.json");
print(jsonstr);

//反序列化
//方式一：
RoInfo[] arr = JsonMapper.ToObject<RoleInfo[]>(jsonStr);
//方式二：
List<RoInfo> list = JsonMapper.ToObject<List<RoInfo>>(jsonStr); 
```

## Json 数据管理类

```cs file:JsonDataManager.cs
/*  
* Json数据管理类 主要用于进行 Json的序列化和反序列化  
* 需要引用 LitJson 库
* 创建StreamingAssets文件夹 
* 
* 序列化：JsonDataManager.Instance.SaveData(data, "fileName");  
* 反序列化：MyData data = JsonDataManager.Instance.LoadData<MyData>("fileName", JsonType.LitJson); 
*/
using System.Collections;
using System.Collections.Generic;
using System.IO;
using LitJson;
using UnityEngine;

/// <summary>
/// Json序列化方案
/// </summary>
public enum JsonType
{
    JsonUtlity,
    LitJson,
}

/// <summary>
/// Json数据管理类 主要用于进行 Json的序列化和反序列化
/// </summary>
public class JsonDataManager
{
    //单例模式
    private static JsonDataManager instance = new JsonDataManager();
    
    public static JsonDataManager Instance => instance;

    private JsonDataManager()
    {
    }
    
    //序列化，存储Json数据到硬盘
    public void SaveData(object data, string fileName, JsonType type = JsonType.LitJson)
    {
        //1. 确定存储路径
        string path = Application.persistentDataPath + "/" + fileName + ".json";
        
        //2. 序列化 得到Json字符串
        string jsonStr = "";
        switch (type)
        {
            case JsonType.JsonUtlity:
                jsonStr = JsonUtility.ToJson(data);
                break;
            case JsonType.LitJson:
                jsonStr = JsonMapper.ToJson(data);
                break;
            default:    
                break;
        }
        //3. 把Json字符串存储到硬盘指定路径的文件中
        File.WriteAllText(path, jsonStr);
    }

    public T LoadData<T>(string fileName, JsonType type = JsonType.LitJson) where T : new() //限制泛型存在无参公共构造函数
    {
        //1. 确定从哪个路径读取
        //首先先判断，流动资源文件夹中是否有我们想要的数据，如果有就从中获取
        string path = Application.streamingAssetsPath + "/" + fileName + ".json";
        //如果没有，就从持久数据文件夹中获取
        if (!File.Exists(path))
        {
            path = Application.persistentDataPath + "/" + fileName + ".json";
        }
        //如果持久数据文件夹中也没有,那就返回默认对象
        if (!File.Exists(path))
        {
            return new T();
        }
        
        //2. 读取文件中的Json字符串
        string jsonStr = File.ReadAllText(path);
        
        //3. 反序列化，将Json字符串转换为类对象
        T data =  default(T);
        switch (type)
        {
            case JsonType.JsonUtlity:
                data = JsonUtility.FromJson<T>(jsonStr);
                break;
            case JsonType.LitJson:
                data = JsonMapper.ToObject<T>(jsonStr);
                break;
        }
        
        //4. 返回对象，通过该对象即可获取对象信息
        return data;
    }
}
```
### 序列化
```cs file:序列化
public class Student
{
    public int age;
    public string name;

    public Student()
    { }
    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<string, string> dic;

    public Student stu;
    public List<Student> stus;

    private int id;
    protected string address;
}


public class NewBehaviourScript : MonoBehaviour
{
    void Start()
    {
         //1. 创建类的对象
         MyData data = new MyData();
        
         data.name = "张三";
         data.age = 18;
         data.height = 1.75f;
         data.weight = 175.0;
         data.sex = true;
        
         data.ids1 = new int[] { 1, 2, 3, 4, 5 };
         data.ids2 = new List<int>() { 1, 2, 3, 4, 5 };
         data.dic = new Dictionary<string, string>()
         {
             { "1", "123" },
             { "2", "456" },
             { "3", "789" },
         };
        
         data.stu = null;
        
         data.stus = new List<Student>()
         {
             new Student(18, "张三"),
             new Student(12, "张s"),
             new Student(18, "张sd"),
         };
        
         //2. 序列化，存储字符串
         JsonDataManager.Instance.SaveData(data, "myfile");
    }
}
```

### 反序列化
```cs
public class Student
{
    public int age;
    public string name;

    public Student()
    { }
    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<string, string> dic;

    public Student stu;
    public List<Student> stus;

    private int id;
    protected string address;
}


public class NewBehaviourScript : MonoBehaviour
{
    void Start()
    {
         //1. 反序列化，将Json字符串转换为类对象
         MyData data = JsonDataManager.Instance.LoadData< MyData>("myfile", JsonType.LitJson);
        
        //2. 获取data对象的信息
        print(data.name);
        print(data.age);
        print(data.height);
        //省略...
    }
}
```

### 扩展

![[Pasted image 20230612002808.png]]
Excel 转换过程特别麻烦，最好写一个自动化工具，自动将 Excel 转换成 Json，并自动生成对应的数据结构。（之后的编辑器课程讲）
![[Pasted image 20230612002828.png]]

# CSV
### 程序在表格文件中读取数据。

*   首选创建 excel，并保存为 csv 格式。用文本打开，可以看到一行行的字符串，以逗号分隔。

![](1686645065163.png)

![](1686645065208.png)

*   为 csv 文件编写一个脚本，用于对此文件进行操作，打开读取 csv 文件，将 csv 中数据存储到一个 list 中，对 list 的数据读取的操作，脚本为 csvController ：

```cs
using UnityEngine;
using System.Collections;
using System.IO;
using System.Collections.Generic;

public class csvController  {

    static csvController csv;
    public List<string[]> arrayData;  

    private csvController()   //单例，构造方法为私有
    {
        arrayData = new List<string[]>();
    }

    public static csvController GetInstance()   //单例方法获取对象
    {
        if(csv == null)
        {
            csv = new csvController();
        }
        return csv;
    }

    public void loadFile(string path,string fileName)
    {
        arrayData.Clear();
        StreamReader sr = null;
        try
        {
            string file_url = path + "//" + fileName;    //根据路径打开文件
            sr = File.OpenText(file_url);
            Debug.Log("File Find in " + file_url);
        }
        catch
        {
            Debug.Log("File cannot find ! ");
            return; 
        }

        string line;
        while((line = sr.ReadLine()) != null)   //按行读取
        {
            arrayData.Add(line.Split(','));   //每行逗号分隔,split()方法返回 string[]
        }
        sr.Close();
        sr.Dispose();
    }

    public string getString(int row,int col)
    {
        return arrayData[row][col];
    }
    public int getInt(int row,int col)
    {
        return int.Parse(arrayData[row][col]);
    }
}
```

*   在其他脚本中调用

```c
void Start () {
        //csvController加载csv文件，单例模式，这个类只有一个对象，这个对象只能加载一个csv文件
        csvController.GetInstance().loadFile(Application.dataPath + "/Res", "csvTest.csv");
        //根据索引读取csvController中的list（csv文件的内容）数据
        speed = csvController.GetInstance().getInt(1, 2);
        Debug.Log("Player speed is " + csvController.GetInstance().getInt(1,2));
    }
```

参考：[http://www.jianshu.com/p/ffda934b5e15#](https://www.jianshu.com/p/ffda934b5e15#)

程序读取文件信息，这个感觉和以前 C++ 读取 text/dat 文件差不多的。  
unity 存储数据是如何实现的？参考 [http://www.wtoutiao.com/a/2139080.html](https://link.jianshu.com?t=http://www.wtoutiao.com/a/2139080.html)

# ScriptableObject

在[游戏开发](https://so.csdn.net/so/search?q=%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91&spm=1001.2101.3001.7020)过程中，我们会经常与数据打交道。很多时候，我们会为游戏对象配置数据，比如玩家初始生命值、技能伤害等。那么就需要有个能够存储数据的东西来和游戏对象进行交互。

假设现在要做一个 “打飞机” 的游戏，玩家操控的飞机在吃了不同道具后会发射不同类型的子弹，这些子弹的飞行速度和伤害各不相同。那么显然我要为每一种子弹配置好它的属性值。

实现方式有很多，比如我为每种子弹创建预制体，然后写脚本去定义代表子弹各个属性的成员变量，再把脚本挂载到子弹预制体上。为了方便在开发时调试我们可以将这些变量声明为 public ，以便我们在编辑器面板中对数据进行改动。  

![[4e1d663836a8844b9b98207bded7f381_MD5.png]]

这么做其实是有缺点的：

1） **每生成一个子弹就会对原来的预制体进行拷贝，其挂载的 Bullet 数据脚本同样会被拷贝，因此同样的数据会被拷贝多次**。而我们规定同一种子弹的数据是相同的，也就是同一种子弹，不管生成了多少个，它们都共用一套数据。因此，这种方法会**创建多余的数据脚本，造成内存浪费**。  
2） 如果预制体上的脚本丢失，之前在 Inspector 面板中配置的数据也会消失。  
😫😫😫😫😫😫😫

不过解决方法有很多，比如：

1️⃣ 我们可以创建一个全局的数据管理中心脚本，通过静态变量去调用每种子弹的数据。不过这种数据配置方式不能实现数据的持久化，而且必须要打开代码文件进行修改，面对茫茫代码可能不是那么直观。  
2️⃣ 我们还可以用上像 **excel，Json，xml 等持久化数据存储**的方法，结合 Unity 对准备好的数据文件进行数据读写。这么做的好处是可以实现数据的持久化，比如在游戏过程中修改了数据，退出游戏后下一次打开游戏使用的就是之前修改过的数据。

那么现在，我将介绍另一种用于**数据存储的解决方案——ScriptableObject**。它也能弥补通过挂载继承自 MonoBehaviour 的脚本来配置数据的一些不足。相较于 excel，Json，xml 这类持久化数据存储的方法，它有些额外的优点，但是也存在一些局限性。我将会在接下来的部分详细说明。

## 🔍 什么是 ScriptableObject

*   ScriptableObject 是 Unity 提供的一个**数据配置存储基类**，它是一个可以用来保存大量数据的**数据容器**，我们可以将它保存为自定义的**数据资源文件**。
*   ScriptableObject 是一个类似 MonoBehaviour 的基类，继承自 UnityEngine. Object 。要想使用它，需要我们写个脚本去继承 ScriptableObject 。需要注意的是，继承自 SctiptableObject 的脚本无法挂载到游戏物体上，毕竟它不是继承自 MonoBehaviour。
*   ScriptableObject 类的**实例**会被保存成资源文件（. asset 文件），和预制体，材质球，音频文件等类似，都是一种资源文件，存放在 Assets 文件夹下，创建出来的实例也是唯一存在的。

简单的看一下 ScriptableObject 的实例长啥样：  

![[1e5f113aea457891c1416f9a301fb188_MD5.png]]

上图是编辑器窗口中的样子，再来看看本地文件夹中的模样：  

![[693da9ec55e4e252b4d18f0a25991a8b_MD5.png]]

  
可以看到 ScriptableObject 实例就是一种资源文件。细心的你可能会发现我这里强调的是 **ScriptableObject 的实例（instance）**，那么你也许会联想到类与实例（或者叫对象）的关系。其实 ScriptableObject 也是如此，**它本身是个类，实例化之后得到的就是数据资源文件**。

那么，要如何使用 ScriptableObject 这个类，又如何创建出编辑器面板中的这个数据资源文件呢？在此之前，我先介绍一下 ScriptableObject 的主要作用，来加深大家对它的理解。刚刚已经介绍了它是什么东西，那么现在将进一步介绍它一般能用来做什么。

## 🔍 ScriptableObject 的主要作用

大体上可以分成三点：  
1） 编辑模式下的数据持久化
2） 配置文件 （配置游戏中的数据）  
3） 数据复用 （多个对象共用一套数据）

### 💪 编辑模式下的数据持久化

数据持久化：使用数据时从硬盘中读取，数据改变后保存到硬盘上，游戏退出后数据信息被存储到硬盘上，达到持久化的目的。

当我们在编辑模式下修改了继承自 ScriptableObject 对象的数据文件内容时，修改的数据将被保存到磁盘上。但是在发布运行后，即使在游戏中修改了 ScriptableObject 的数据，改后的数据并不会保存在本地，**重新打开运行时数据并还是配置的初始数据**。

**因此 ScriptableObject 适合在编辑模式下调试数据，但不适合存储在游戏打包发布后的运行期间会改变的数据** ❗

### 💪 配置文件

ScriptableObject 非常适合用来做配置文件。因为：  
1）配置文件的数据在游戏发布之前就定好了规则  
2）配置文件的数据在游戏运行时只会读出来使用，不会修改数据的内容  
3）传统的配置文件一般会通过 xml、json、excel 等方式来配置游戏数据  
，相对来说都是在 Unity 外部通过其它格式的文件对数据进行配置。  
而通过 ScriptableObject 我们可以直接**在 Unity 内部的 Inspector 面板中进行数据的配置**，有时候会更加方便。

我们也可以利用 ScriptableObject 数据文件来制作编辑器相关功能，比如制作 Unity 内置的技能编辑器、关卡编辑器等。因为内置编辑器只在编辑模式下运行，在编辑模式下 ScriptableObject 正好具有数据持久化的特性。

### 💪 数据复用

对于只用不变的数据，通过使用 ScriptableObject 可以有效避免内存的浪费，因为它将共用的数据单独抽离出来，供相同的一类对象使用。

还是利用前言中举的例子，比如一个子弹对象，通过面向对象的思想，会写一个继承自 MonoBehaviour 的脚本，声明相关的属性，然后挂载到子弹预设体上，把子弹需要的数据赋给子弹对象。如果我们要求子弹的数据是**不会改变**的，那么这样每次实例化一个子弹，对内存来说会造成一定的浪费，因为每次生成一个子弹都会复制 Assets 下子弹预制体的值，也就是多次复制了相同的数据。  

![[65d2a4a611ac044c5abbacc9b610ec39_MD5.png]]

![[4f6b0bcd41992e531c687a571c9fdd21_MD5.png]]

**这样每一个子弹预设体上都有该脚本，该脚本中的所有的属性都会分配一次内存**。

但是如果是用 ScriptableObject，对于某一种子弹，我们**只需要拥有一份 ScriptableObject 的实例，也叫做数据资源文件，然后这一种子弹的所有游戏物体都引用这个数据资源文件**，就可实现不管生成多少个子弹，只要它们属于同一类，都会共用一份数据。  

![[553cf2048f555db8969ad84bbfa5c3e5_MD5.png]]

这里每个子弹预制体中的子弹脚本都只是持有 Bullet Data 这一个 ScriptableObject 实例的引用，真正在内存当中分配空间的只有红线所指向的 ScriptableObject 实例，也就是我们的数据资源文件。

## 🔍 如何创建 ScriptableObject

ScriptableObject 是个类，因此自然会有先声明，后实例化的步骤。

### 📕 步骤一：声明自定义的数据容器

第一步：创建一个脚本继承自 ScriptableObject 类  
第二步：在该类中声明成员，规定要存哪些类型的数据 （如果后续创建了数据资源文件，要在 Inspector 窗口中看到这些成员，需要把它们声明为 public ）

```
public class BulletData : ScriptableObject
{
    public float speed;
    public float damage;
}
```

这一步就相当于定义了一个数据的模板。

### 📕 步骤二：根据自定义的 ScriptableObject 数据容器创建数据文件

这一步就相当于根据定义的模板实例化 ScriptableObject ，具体有两种方法：

#### 😊 方法一：为类添加 CreateAssetMenu 特性，在编辑器的菜单中创建资源文件

```
[CreateAssetMenu (fileName = "BulletData", menuName = "ScriptableObject/子弹数据", order = 0)]
public class BulletData : ScriptableObject
{
    public float speed;
    public float damage;
}
```

这种创建 ScriptableObject 资源文件的方法还是比较简单且常见的，主要就是在类的上方加一个 CreateAssetMenu 特性。

fileName 表示数据资源文件创建出来的文件名。  
menuName 表示在 Assets/Create 下的名字。  
order 表示在 Assets/Create 下的位置顺序。

这里涉及到一点编辑器扩展的知识。光看这一段文字描述也许看不出个所以然，那么接下来我会带着大家实操一遍，过程其实非常的简单粗暴😉。  
既然要创建资源文件，大家其实可以类比创建材质、预制体，它们也是一种资源文件。要想创建它们，我们只要在编辑器中的 Asset 目录或者它的子目录中按下鼠标右键（或者直接点击编辑器最上方菜单栏的 Assets），然后点击 Create，找到我们想要创建的资源就行了。  

![[6a54d05cff033c5abbd0c5e5f1968a7c_MD5.png]]

![[cce25a63f89be9ccaecf1528e07dcaeb_MD5.png]]

  
（注：点击 Project 面板中的 “+” 也能实现）

那么 ScriptableObject 也是一样，只不过**我们要手动为继承自 ScriptableObject 的类添加 CreateAssetMenu 特性，让它能像预制体、材质球这类资源文件一样能够在编辑器面板中手动创建。**

如果你像我演示的代码那样添加了 CreateAssetMenu 特性，你会发现 Create 的下一级目录的最上方出现了一个 ScritableObject。  

![[f331e30c66459ff2c433feadbea5a632_MD5.png]]

我们还可以把鼠标移到菜单中 ScriptableObject 的位置，可以发现它又展开了下一级目录：  

![[d82ba5e8713ff5a2433f2b8e28b60252_MD5.png]]

这时候出现了我们的 “子弹数据” （这一级目录下还有我之前创建的其他 ScriptableObject） ，ScriptableObject 下的“子弹数据” 就是我们刚刚在 menuName 中定义的，然后我们点击它。  

![[1e5f113aea457891c1416f9a301fb188_MD5.png]]

这时候就成功创建了我们的数据资源文件。然后我们就可以在 Inspector 面板中配置数据了。  
回看 CreateAssetMenu 特性, 你是否能理解它的一些属性了呢？

fileName 的值就对应了我们创建出来的数据资源文件的文件名。  
menuName 的值对应了我们要如何在编辑器面板中创建出数据资源文件的路径，从 Assets/Create 开始，我们如果想将路径分级，可以在路径名之间用 “/” 隔开。  
那 order 是怎么一回事呢？它的默认值是 0，我们之前看到 ScriptableObject 目录下 “子弹数据” 是排在第一位的，那我如果把 order 的值由 0 改成 1 会发生什么事呢？请看：  

![[4ca118182146752514fc333a59e78251_MD5.png]]

  
事先说明一下，我的另外两个 ScriptableObject 的 order 也是设成 0，那么你可以看到 “子弹数据” 现在排在了第三位。  
那么这个 order 其实就规定了创建 ScriptableObject 数据资源文件的路径在菜单上显示的位置，order 越低，就显示在越上面。如果 order 相同，则是按照继承自 ScriptableObject 的脚本创建时间排序，新创建的排在上面。

#### 😊 方法二：利用 ScriptableObject 的静态方法创建数据对象，然后将数据对象保存在工程目录下

可以新建一个脚本（可以不用继承自 MonoBehavoiur，这个脚本不用挂载到游戏物体上），引入 UnityEditor 命名空间：

```
using UnityEngine;
using UnityEditor;
public class ScriptableObjectTool 
{
    [MenuItem ("ScritableObject/CreateMyData")]
    public static void CreateMyData()
    {
        //创建数据资源文件
        //泛型是继承自ScriptableObject的类
        BulletData asset = ScriptableObject.CreateInstance<BulletData>();
        //前一步创建的资源只是存在内存中，现在要把它保存到本地
        //通过编辑器API，创建一个数据资源文件，第二个参数为资源文件在Assets目录下的路径
        AssetDatabase.CreateAsset(asset, "Assets/Resources/ScriptableObject/BulletData.asset");
        //保存创建的资源
        AssetDatabase.SaveAssets();
        //刷新界面
        AssetDatabase.Refresh();
    }
}
```

保存脚本后，会发现编辑器最上方的菜单栏多出了这个（MenuItem 特性起的作用）：  

![[372912b963bcc47098df28a5274fa252_MD5.png]]

  
点击后，可以看到 Assets/Resources/ScriptableObject 文件夹下多了我们想要的数据资源文件：  

![[9169cae06e4925acec6959d3a8bf1e3f_MD5.png]]

**注意：**  
1️⃣ 使用这种方法无需在继承自 ScriptableObject 的类上增加 CreateAssetMenu 特性。  
2️⃣ **刚刚创建的 ScriptableObjectTool 脚本需要放在 Assets 文件夹下任一位置的 Editor 文件夹下**（这个文件夹放哪都行，看自己需求，只要在 Assets 文件夹或其子文件夹下就好）。**因为我们引入了 UnityEditor 命名空间，这意味着这个脚本只在编辑模式下会用到，实际打包发布后是不会用到的**。如果没放在 Editor 文件夹下，Unity 打包时会认为此脚本是会被一起打包，作用于游戏运行期间，与 Editor 命名空间的性质相矛盾，所以会报错。（这里就涉及到一些扩展编辑器的知识）  

![[8b32c27a0db09a13b6f0ffe140ed0698_MD5.png]]

### 😊 总结创建 ScriptableObject 的步骤

1）写个脚本，继承 ScriptableObject 类  
2）声明需要的数据变量  
3）添加特性来创建数据资源文件。这相当于一种专门用来记录数据的资源，和预制体，材质球，音频文件一样都是资源，只不过是通过继承自 ScriptableObject 类生成的数据资源文件。

## 🔍 如何使用 ScriptableObject

我们刚刚介绍了如何创建 ScriptableObject，但是此时我们只是创建了一个数据资源，并没有将它存储的数据和我们的游戏对象关联起来。那么接下来，我将介绍如何去运用创建出来的数据资源文件。

### 📕 Ⅰ. 数据文件的使用

#### 😊方法一：通过 Inspector 面板中的 public 变量进行关联

步骤一：创建一个数据文件  
步骤二：在继承自 MonoBehaviour 类中声明数据容器类型的成员，在 Inspector 面板中进行关联（拖拽的是数据文件而不是继承自 ScriptableObject 类的脚本）  

![[564200183c038bc2577039137227c635_MD5.png]]

不使用 ScriptableObject 的时候，我们的子弹脚本是这么写的：  

![[733ebd2f19481b7dc3415d4562c806a5_MD5.png]]

  
那么现在我们只需把数据有关的部分替换成 ScriptableObject 的引用就行了：  

![[c9dbc2093c66bf771b0190672238f238_MD5.png]]

  
然后在 Inspector 面板中拖拽赋值：  

![[b09f13f16b2b6fc509d2f5a3be836038_MD5.png]]

这个时候游戏对象就和数据资源关联起来了，不管有多少个物体挂载了 Bullet 脚本，它们关联的都是同一份数据资源。

#### 😊方法二：直接加载数据资源文件

可以用 Resources，AddressBundle，Addressables 等方式加载数据资源文件。

### 📕 Ⅱ. 生命周期函数

ScriptableObject 和 MonoBehaviour 类似，也存在生命周期函数，但是数量会少很多。

```
Awake 数据文件创建时调用
OnDestroy 对象将被销毁时调用
OnEnable 创建或加载对象时调用
OnDisable 对象销毁时，即将加载脚本程序集时调用
OnValidate 编辑器才会调用的函数，Unity 在加载脚本或者 Inspector 面板中更改值时调用
```

除此之外继承自 ScriptableObject 的类中也可以自定义函数，并不是只能声明和数据有关的变量。

### 📕 Ⅲ. 实现非持久化数据

我们知道 ScriptableObject 在打包发布后是不具备数据持久化的功能的，但是它能实现编辑模式下的持久化数据。只要我们在编辑器面板中手动创建一个数据资源文件，这个时候相当于我们在磁盘中真正创建了一个文件，之后在编辑模式中 ScriptableObject 的数据改动会被保存在磁盘中。

其实，对于某些数据资源，我们不一定要将数据保存为磁盘中的资源文件占据空间，而只希望运行期间在内存中临时生成一组共用的数据给对象使用就够了，退出游戏后就释放掉生成的数据资源。**这个时候不论是在编辑模式还是打包发布后，数据都是非持久化的，也就是改动的数据不会被保存到磁盘中而是内存中**。退出游戏后重新打开，读取的还是初始配置的数据。

**如何生成非持久化数据？**  
利用 ScriptableObject 类中的静态方法 CreateInstance<>() 。该方法可以在运行时创建出指定继承自 ScriptableObject 的对象，该对象只存在于内存中，可以被 GC 垃圾回收，调用一次就创建一次。

```
public BulletData bulletData;
void Start (){
//通过这种方式创建的数据对象，它里面的默认值不会受到脚本中设置的影响 
    bulletData=ScriptableObject.CreateInstance<BulletData>();   
}
```

现在我们把刚刚创建的数据资源文件在文件夹中删掉，做个小测试，在脚本中用上 CreateInstance<>() 方法：  

![[de5e3d91f9b2b2c8ce783f010fa29e16_MD5.png]]

  
在编辑模式中，游戏还未运行时 bulletData 引用的是空数据。  
然后运行游戏，可以发现 bulletData 已经关联上了一个子弹数据资源：  

![[edf8e6b1e0a54551985d38c40c071bd1_MD5.png]]

  
这个数据资源文件是被动态创建出来的，只被创建在内存中。当我们关闭游戏后 bulletData 引用的资源重新变成空数据。

### 📕 Ⅳ. 让 ScriptableObject 真正意义上持久化

既然 ScriptableObject 本身无法在游戏打包发布后实现数据持久化，那么我们可以配合 Json，PlayerPrefs， xml ，二进制等方式来实现 ScriptableObject 真正意义上的数据持久化。

以 Json 为例：  
**利用 Json 结合 ScriptableObject 存储数据**

```
public class TestScriptableObject : MonoBehaviour
{
    public BulletData bulletData;
    void Start() {
        bulletData= ScriptableObject.CreateInstance<BulletData>();
        bulletData.speed = 9.5f;
        bulletData.damage = 100.0f;
        //将数据对象序列化为Json字符串
        string str = JsonUtility.ToJson(bulletData);
        //将数据序列化后的结果存入指定路径当中
        File.WriteAllText(Application.persistentDataPath + "/testJson.json", str);
    }

}
```

**利用 Json 结合 ScriptableObject 读取数据**

```
//从本地读取Json字符串
        string text = File.ReadAllText(Application.persistentDataPath + "/testJson.json");
        JsonUtility.FromJsonOverwrite(str, bulletData); //根据Json字符串反序列化出数据，将内容覆盖到bulletData数据文件中
```

但是实际上，让 ScriptableObject 真正意义上数据持久化有点画蛇添足的感觉。因为既然已经要用到持久化数据的方法，那为什么不全部用它们来进行数据交互呢？其实可以自定义一个数据结构类，让它与数据持久化的方法进行交互，而不是再去创建一个类继承自 ScriptableObject。

### 📕 Ⅴ. 单例模块获取数据

之前介绍使用数据文件的时候，要么是通过声明 public 变量在 Inspector 面板中进行拖拽关联，要么是使用资源加载的方法。

如果用拖拽的方式，物体之间的拖拽关系可能会随着项目量的增长而变复杂，不利用后续的维护。😟  
如果用资源加载的方式，以 Resources 为例，可能就要写大量的 Resources. Load 方法，其实是有一点重复工作的。😟

因此可以将 ScriptableObject 实例**通过单例模式化**去获取，减少重复代码，提高编码效率：

```cs
public class SingleScriptableObject<T> : ScriptableObject where T :ScriptableObject
{
    //所有数据资源文件都放在Resources文件夹下加载对应的数据资源文件
    //对需要复用的唯一的数据资源文件名定一个规则：文件名和类名一致
    private static string scriptableObjectPath = "ScriptableObject/"+typeof(T).Name;
    private static T instance;
    public static T Instance
    {
        get
        {
            if (instance == null)
            {
                //如果为空，首先应该去资源路径下加载对应的数据资源文件
                instance = Resources.Load<T>(scriptableObjectPath);
            }
            //如果没有这个文件，直接创建一个数据
            if (instance == null)
            {
                instance = CreateInstance<T>();
            }
            return instance;
        }      
    }
}
```

假如说我要去调用子弹数据，我就让 BulletData 类继承自 SingleScriptableObject 类，然后直接这样调用就行了：

```cs
BulletData. Instance. speed
```

## 🔍 总结

那么 ScriptableObject 的相关基础知识点差不多就介绍完了。  
对于**只用不变**的数据，就适合用 ScriptableObject 做**数据配置文件**，再加上**编辑模式下可实现数据持久化**的特点，我们可以在 **Inspector 面板中进行数据的配置与调试**，有的时候是更加方便的，并且可以达到**数据复用**的目的，减少内存消耗。但是它无法在游戏打包发布后将数据的变动存储到磁盘中。因此我们要熟悉 ScriptableObject 的优缺点，结合实际需求选择使用。🌹