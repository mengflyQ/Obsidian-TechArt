有一个杀死了数千计的手机游戏 GPU 性能的问题：著名的 **Overdraw**。你知道什么是 OverDraw 么，它正在对你做什么？

不要让 OverDraw 杀死你的游戏！

为此我们将学习了解以下内容。

![[bd394b6f117f608bb87ddbae8c843fde_MD5.jpg]]

*   了解什么是 OverDraw，以及 OverDraw 如何破坏游戏 GPU 的性能（**尤其是**在移动设备和 VR 上）
*   3 种**测量**游戏 OverDraw 的技术
*   **减少** Unity OverDraw 的策略

目录

1.  什么是 Unity 中的 OverDraw？
2.  为什么 Unity OverDraw 会使游戏卡顿
3.  测量 OverDraw 的三种方法

1.  Unity：OverDraw 可视化模式
2.  RenderDoc OverDraw 分析（Example：森林）
3.  使用 Compute Shader 测量 OverDraw
4.  Snapdragon Profiler
5.  Xcode

5.  如何减少 OverDraw

1.  减少不透明几何产生的 OverDraw

1.  由于低效率的渲染策略产生的 OverDraw
2.  由于 Unity 批处理而产生的 OverDraw

3.  减少透明渲染产生的 OverDraw

## 1. 什么是 Unity 中的 OverDraw？

想象一下今天是星期一。

你终于在 8:40，第四个闹钟响的时候清醒了过来。

你担心上班迟到，所以只有一点点时间将衣服穿上并且滚粗上班去了。

屋子外面天气很冷，

但是经验告诉你，听生气的老板咆哮比遭受体温过低要糟得多。

因此，你进入汽车并启动了发动机。

现在到 9:00 还差 10 分钟。如果你的数学不是体育老师教的，应该可以在 5 分钟内准时到达办公室并且时开始工作。

现在只有一个问题：挡风玻璃被冻结，你在车内看不到任何车外的东西。

最短也需要 5 分钟才能将挡风玻璃的冰冻去除。

时间还赶得上，窃喜中。。。

开车时，你注意到挡风玻璃起雾了。

_这不可能_，你想。

你以不可能的角度从座位上看挡风玻璃某些地方的小像素，这些像素尚未被遮挡。

当你开车时，你又发现挡风玻璃起雾了！！

擦，这下完蛋了。

在你现在的角度，你无法透过挡风玻璃的**像素**看到车外的景象。

雾越来越大了，你只能打开侧窗，把头伸出车外，才能看清路况，但是你还要想法子开车

你当然在驾驶学校没有学过这样的驾驶技术。

经过短暂理智的思考之后，你认为冒这样的风险不值得。

**你认命了...**

你以安全的方式进行了操作，但是迟到 15 了分钟才到达公司。

老板脸上的笑容说明了一切。你完蛋了。

… 美好的星期一。

![[6599918a8a31034abb5f122e9e4ad32f_MD5.jpg]]

如果你不注意，进到车里时，你会遭受数次 **OverDraw**。

雾蒙蒙的挡风玻璃可以称为 OverDraw。它在你和你想要看到的场景（孩子们过马路）之间添加了中间的视觉效果层。

当**你多次绘制同一像素（在一帧中）**时，会发生 OverDraw，想象一下，你的眼睛就是相机

*   第一个 Draw Call 绘制了在你面前的街道（场景）。
*   第二个 Draw Call 绘制了正在穿马路的小孩子们（角色）。
*   第三 DrawCall 绘制了有雾的挡风玻璃，它使驾驶很危险。
*   最后一个 DrawCall 绘制了你所戴的混浊眼镜。

这里有四层 OverDraw，类似于 Unity 渲染会发生的情况：渲染整个屏幕，该屏幕由数百万个像素组成。如果这些像素被绘制了一次以上（总是如此），那么就造成了 OverDraw，导致 GPU 渲染压力增大。

这种情况最常见于透明几何体，因为首先绘制不透明世界，然后逐次将其与半透明对象混合（绘制）。

更糟糕的是：**简单的后处理效果（例如 color grading）可能会对每个像素至少计算一次**。由于它重画了屏幕上的每个像素，这直接增加了 100%（1.0x）的 OverDraw。

如果您的后期处理效果仅影响屏幕的左侧，因为它涉及到屏幕像素的一半，它将增加一半的 OverDraw 程度（0.50x）。

等等。

可悲的是，导致你上班迟到的 OverDraw 也会导致 GPU 每帧处理理时间增加。

**OverDraw 可能是导致 60 fps 或 30 fps（或更差）渲染帧率差距的原因。**

Unity OverDraw 是 VR 和移动游戏（包括 Switch，PSVR 和 Oculus Quest）的最大性能问题之一。

_你知道为什么 OverDraw 是你对 GPU 所能做的最坏的事情之一么？_

![[f08c1caec1f5a907416ea622d243ce2e_MD5.jpg]]

## 2. 为什么 OverDraw 会蚕食 Unity 渲染性能

渲染的目的是将图像（以非常快的速度）放置到屏幕上。这是通过特定步骤（**Draw Calls**）来完成场景渲染。

其中某些渲染步骤并不是在屏幕中发生，而是在称为帧缓冲区的中间区域中发生。

帧缓冲区就像画家用来画画的一块空画布。

如果你想象你是画家，那么…… 每个笔画都会花一些时间，尤其是当他们不得不更改绘画时使用的颜色时。

在图形编程方面，该帧缓冲区是一种特殊的纹理。由于许多原因，**绘制到帧缓冲区很昂贵**。

每次绘制像素时，都需要从该缓冲区传输出和传入关键信息。

此绘制操作会**占用内存带宽**。

OverDraw 会增加游戏渲染消耗的内存带宽。

你猜怎么着？在 TBR（tile-based rendering）的渲染架构上，这种带宽消耗尤其糟糕，碰巧是所有移动平台都是 TBR 的渲染架构。

OverDraw 在 VR 游戏上尤为棘手，有两个原因：

*   **屏幕分辨率**：每帧绘制的像素数量已经很高。
*   与传统游戏相比，VR 游戏的**性能预算**要**低**得多，因为需要达到 120Hz 才可以避免晕眩，传统游戏只需要 60fps 就够了。

我希望你已经有一些 OverDraw 的概念了，接下去我将向你展示测量 OverDraw 的不同方法。

## 3. 在 Unity 中测量 OverDraw 的三种方法

### 3.1 Unity：OverDraw 可视化模式

了解场景中 OverDraw 的最简单，最快的方法可能是使用 Unity 内置的 OverDraw 视图模式。

在场景视图的右上角，单击_可视化类型_下拉菜单。在那里，选择 OverDraw。

你将看到类似于下面的可视化效果。

![[276bec784dbf9bd8bcba70101705fc92_MD5.jpg]]

最**深的色彩**表示具有最高 OverDraw 屏幕区域。你会发现某些最强烈的区域很可能与粒子效果有关。

如果你看到一个地区有大量的 OverDraw，请分析它是由什么原因造成的。很可能是由于渲染半透明元素造成的。

**→警告！Unity 内置的透支可视化在技术上非常不正确。**

Unity 使用不带 Z-Write 的附加着色器来显示它，因此你将看到的大多数不透明对象上的 OverDraw 都是假的。

Unity 没有考虑到渲染管线所做的 Z-Test，正常情况下，很多不透明元素的渲染会被 Z-Test 剔除掉。

但是，只要你知道它的局限性，它仍然是一个有用的工具。

幸运的是，你和我有更准确的工具可以使用。

如果您使用的是 **HDRP 7.1+**（高清渲染管线），那么你会很高兴听到有增强的 OverDraw 可视化工具可以使用。你可以通过_Window → Render Pipeline → Render Pipeline Debug → Rendering_来访问它，并将 **Fullscreen Debug Mode** 设置为 “ _TransparencyOverdraw_ ”。

![[ae6001e687f530e4c7c6ffb7f5bbca1b_MD5.jpg]]

以下是此渲染模式在示例 UI 上的外观：

![[114c0dcbeda895fa30751973cd2a2c56_MD5.jpg]]

让我们检视下一个工具。

### 3.2 使用 RenderDoc 分析 OverDraw（例子：The Forest）

以下是_The Forest_的起始场景的屏幕截图。它是一款类似于电视节目《_迷失》_题材的生存游戏。

在这里，快速预览一下，因为我们将对其进行分析。

![[ada3fca9f16998bd1979c860073fbf10_MD5.jpg]]

**该场景有多复杂的 OverDraw？**

好吧，由于它主要取决于所涉及的渲染顺序和着色器，所以你无法通过查看屏幕截图来了解。

但是我们可以使用 [RenderDoc](https://renderdoc.org/)，这是一个免费的 GPU 图形调试器，可以让我们在图形调试上节约很多时间。

优势？开箱即用的**内置 Unity 集成**。只要安装_RenderDoc_就可以了。

在此示例中，我使用_RenderDoc_捕获与上一张图像相同的帧。然后，我遍历其 draw calls，将 **overlay mode** 切换为_Quad Overdraw（Draw）_来分析它们产生的 OverDraw，如下所示。

![[d2718ecf92cda7f303d90f38f7c3c645_MD5.jpg]]

下面 GIF 动画由粉红色区域表示通过绘制飞机底盘的一部分而产生的 OverDraw。

![[c04890db48d785f35622afad8db5612d_MD5.gif]]

之所以会发生这种 OverDraw，是因为我们先绘制了地形的像素，之后才被飞机框架覆盖。这是带宽的浪费！首先进行飞机框架的绘制会更高效，因为 Z-Test 会跳过随后绘制地形的像素。

这种情况下 OverDraw 量很大，覆盖了整个屏幕的 30％。

哦不， 你无法在移动设备上负担得起这种开销。

接下去我要指出的 The Forest 中的最后一个示例是 UI 重绘。

在 Unity 中，UI 最通常在渲染管道的末端绘制。这样，这样可以确保它显示在所有事物之上。

在这里，他看起来这不是主要的问题，因为它仅覆盖屏幕的一小块区域。但是，如果你打开全屏地图或背包界面，会发生什么呢？

是的，你懂得。

![[b2de56137d77e23bf06edefac9da8f94_MD5.gif]]

_RenderDoc_是每个（图形 / 性能）程序员都应该拥有的一个非常有用的工具。

要了解有关此工具的更多信息，请访问有关 [Unity RenderDoc 集成的](https://thegamedev.guru/uncategorized/where-did-my-pixel-go-when-unitys-frame-debugger-is-not-enough/)文章。注意：帖子很旧，我的写作风格很烂。仍然是很好的参考信息。

到目前为止，这已经是相当生动的图形冒险了。 蛮好玩的。

但这还不够。

你应该成为**数字驱动的人**。最终关键是可让你用数字比较性能指标。

下一个策略将帮助你在追求性能专业知识的过程中变得更加以数字为导向。

### 3.3 使用 Compute Shader 量化 OverDraw

在 2017 年的 Unite 演讲中，我遇到了一家来自名为 Nordeus 游戏开发公司的出色工程师。

由于 Unite 大会上，对于技术涉及的主题通常很浅，因此我经常对 Unite 的话题感到无聊。

但这次不一样。

演讲的很大一部分是关于 Unity GPU 性能的，你可以想象到我从一开始就认真地做笔记。你可能实际上在视频中的某个地方看到了我（这并不难找，那时候我非常瘦，像其它程序员一样）。

一位工程师介绍了他们开发的一种工具，该工具可以用大量数字分析量化场景的 OverDraw。

从字面上看，该工具为你提供了场景每时每刻都有的 OverDraw 数值。这是一个非常方便的数字。

自从那次演讲以来，我每年都会和这位工程师见面，我们总是在一些简短的咖啡时间分享关于性能的精彩对话。比如 GDC，Unite，等大会上的内容。

您可以在 [GitHub 上](https://github.com/Nordeus/Unite2017/tree/master/OverdrawMonitor)使用 Nordeus 的 OverDraw 工具，并且可以在 [YouTube 上](https://www.youtube.com/watch?v=vJZcbscZ4-o&feature=emb_title)观看该视频。

该工具是我用来分析和优化每个游戏场景中 OverDraw 的主要资源之一。

每当我看到超过 3 倍的 OverDraw 的图形时，我都会迅速进入该场景并开始优化工作。

![[58fb3aa3ab29fa0ea71036ddf5b6444a_MD5.jpg]]

我可能会就如何使用 Nordeus 的 OverDraw 工具进行更深入的介绍，但是你需要注意以下几点：

*   该工具可以在编辑器中直接使用 DirectX 正常工作。如果想要使它适用于 OpenGL，可能需要修改一些代码，但目前我还无法共享代码（需要的话评论区下留言）。
*   争取只有 1 倍 OverDraw，尽可能避免 2 倍 OverDraw，当然不要超过 3 倍（这个根据项目的兼容性和适配目标来，现在手机机能越来越强，为了效果堆各种后处理，避免不了 OverDraw 会上去）。

如果你很关注性能优化这块，那么这是可以集成到项目中的宝贵的资产。

### 3.4 Snapdragon Profiler

如果你手头有晓龙 cpu 手机，市场上几乎所有的 Android 手机（华为除外），那么这就是你的幸运日。

这是一个可以让你从底层分析游戏性能的工具，其中就包含了 OverDraw。

但是我不是这个工具的忠实拥护者 - 它非常不稳定，你可能需要花费数天才能获得有用的东西，但是在特定情况下它非常有价值。

以下就是分析 OverDraw 数据的截图

![[77d7a3cc22a70211ccf9464cdcfbe5df_MD5.jpg]]

### 3.5 Xcode

Xcode 是当世代最强的渲染分析工具，有条件的话尽量用 ios 设备 + Xcode 分析渲染性能，这里主要讲 OverDraw，先简单略过，有兴趣的小伙伴们可以去搜索相关资料，如果需要详细出一期教学，可以在评论区下留言。

## 4. 如何减少 OverDraw

既然现在你已经知道 OverDraw 对游戏有何影响，那么问题就变成了：我该如何处理它？

另外，还有一个重要的问题将导致相同的答案：如何防止 OverDraw？

在本章中，我将与你分享我的最佳建议。

### 4.1 减少不透明 OverDraw

与流行的游戏开发理念相反，渲染不透明的几何形状可能会导致大量 OverDraw。

不透明几何产生的 OverDraw 相比透明几何产生的 OverDraw 开销更低，因为不透明渲染只是替换像素。透明渲染通常会与 Alpha Blend 一起使用，这对于移动设备来说有更加昂贵。

但是，不要低估不透明 OverDraw 产生的性能开销。浪费内存带宽的开销依然很昂贵。

Unity 会尽最大努力从近到远渲染不透明元素。这就是说，我们首先渲染距离摄像机更近的元素，以便使用 Z-Test 剔除被遮挡的物体的像素。

该排序基于相机与每个对象的边界框中心之间的距离。

这种排序非常有利于 GPU 性能。

但是，在某些情况下，会导致渲染队列排序混乱，这会使 OverDraw 增加。

你知道是什么时候吗？

### 由于低效率的渲染策略，导致 GPU OverDraw

事情是这样的：某些网格肯定是麻烦制造者。

假设你位于巨大的倒球面的中心，就像力场效应一样。

好吧，你到球面的距离是多少？

它接近于零，因为球体的中心恰好是摄影机所在的位置，这意味着将先渲染该球体，即使可能会在其前面绘制一些对象。这将导致 OverDraw。

这就是为什么在 Unity 中应该把渲染天空盒放在渲染不透明几何图形之后的原因。首先渲染天空盒会产生大量 OverDraw。

![[871a50affdccc541329153e75f610c22_MD5.jpg]]

那如何解决这个问题呢？

你可以**将对象拆分为较小的子对象，**以便 Unity 可以获取更准确的原点来更有效地对绘图调用进行排序。

相交的几何会发生另一个问题。在这里，透支变得不可预测，因为不能在同一次绘制调用中保证像素渲染顺序。

![[bb0f7d099974a80a04c39aff9672888f_MD5.jpg]]

对于自相交的几何，还可以以明智的方式将其拆分为不同的几何块。在上一个屏幕截图的情况下，您可以将其完全分成四个平面，因此基于距离的排序将正确地完成其工作（请注意，这个操作将支付更多的 Draw Call，以减少 OverDraw，这个需要再实际项目中做平衡，看是 CPU 有余量还是 GPU 有余量，这里只作为例子介绍减少 OverDraw 的策略）。

让我们看看其他情况。

### Unity Batching 导致 GPU OverDraw 增加

我喜欢批处理。而且你也应该喜欢。

批处理可以帮助你我减少渲染线程的 CPU 负载，这在未经优化的游戏中通常是一个巨大的瓶颈（CPU 瓶颈）。它能够将多个绘制调用合并在一起提交给 GPU。

但是，合并绘制调用意味着 Unity 将不再能够对其按原有的顺序进行排序，因为现在已经合为一体。这可能会导致严重的 OverDraw。

这在所有类型的批处理中都会发生：静态，动态和 GPU Instance。通常发生的环境不是确定性的，这会使你的性能分析工作更加困难。

可悲的是，常见的解决方案是禁用麻烦对象的批处理（或者按区域手动来进行批合）。

另一种解决方案是通过将渲染队列更改为 Geometry-1，Geometry + 1 等来手动设置 [Unity 渲染顺序](https://docs.unity3d.com/ScriptReference/Rendering.RenderQueue.html)。这几乎可以完全控制渲染顺序，但这带来了责任 / 风险（常见的是把地表、天空盒进行延后渲染）。使用 Standard 材质要求检查器处于调试模式，如下所示。

![[0d6289669167d19b1ec3366c32078b84_MD5.jpg]]

### 4.2 减少透明渲染的 OverDraw

半透明对象是导致 OverDraw 最常见的元凶

由透明度引起的 OverDraw 对性能特别不利，因为渲染通常伴随 Alpha Blend，这需要额外的读取和算术运算。

更糟糕的是，透明材质通常不会写入 Z-buffer，因此最终会写入更多无法丢弃的像素。

你要做的是减少绘制**的透明像素**的**数量**及其**成本**。

*   减少渲染的**透明层**的数量。
*   减小透明几何图形所需的**屏幕尺寸**
*   您可以按比例缩小透明对象的（屏幕）大小。
*   尽最大可能从精灵中删除 100％透明纹理像素。
*   制作紧密的网格，以减少完全透明的区域。

![[1c55cae120d5255bbb26332eca18a2a7_MD5.jpg]]

![[99e2b4bdc09dad23f917c51eeab2f443_MD5.jpg]]

**Unity UI 通常会导致 OverDraw**，因为系统仅支持全四方渲染。将可绘制的 UI 元素彼此堆叠非常容易。这些渲染为完整的四边形而不是紧密的网格。

但是，精灵渲染器支持绘图网格，这些网格可以更准确地表示精灵的不透明部分，以减少过度绘制。

示例如下：

![[d654fc5d8d155c66edf6c5a7382d1940_MD5.jpg]]

用精灵制作紧密的网格将大大降低 OverDraw 水平：

![[5c00990d56f69006900a7b4443ab1547_MD5.jpg]]

你可以尝试的一种先进技术是在几何渲染队列之前**以不透明模式**绘制部分 **UI**。如果写入 Z-Buffer，则不会渲染其后面的所有像素。当然，这对于所有类型的 UI 控件来说未必是一件好事。

**粒子系统**也擅长在透明层上创建 OverDraw。问题在于它们经常将粒子堆叠在一起，因此 GPU 必须在混乱区域渲染太多像素。

最后，我将在此处包括**后处理效果**，尽量把他们合并计算，权衡使用。

根据后期处理效果的实现方式，最终可能会引入一个新层，即每个引入的效果会造成 100％OverDraw。这对于移动 GPU 来说非常不利。**（话越少事儿越大）**

_注意：如果您无法进一步减少 OverDraw，请尝试通过 additive 而不是 Alpha Blend 来降低其成本。**Additive blending** 比移动设备上的 Alpha Blend 要廉价得多。_

## **5. 获取性能优化备忘单**

哇，这是一个全部干货的文章。

如果你不熟悉性能优化，那么可能一定要消化很多东西。

即使不是，你最终也可能会忘记这篇文章的重点。

为了进一步帮助你，我准备了一份备忘单，其中包含摘要，资源和清单，你可在游戏开发过程中随时取用。

随身携带它，你可以随时随地翻出来阅读，[立刻获取](https://thegamedev.guru/unity-gpu-performance/overdraw-optimization/#5-the-unity-overdraw-cheatsheet-for-2020)

![[c563ef7c538082b9deef32719bf141cb_MD5.jpg]]

原文作者

[Ruben Torres (The Gamedev Guru)](https://thegamedev.guru/#)

原文地址：[https://thegamedev.guru/unity-gpu-performance/overdraw-optimization/](https://thegamedev.guru/unity-gpu-performance/overdraw-optimization/)

本文翻译由作者授权