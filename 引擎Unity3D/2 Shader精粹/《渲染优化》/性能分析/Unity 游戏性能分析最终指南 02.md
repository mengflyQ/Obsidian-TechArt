## 设置每帧时间预算

[帧率](https://so.csdn.net/so/search?q=%E5%B8%A7%E7%8E%87&spm=1001.2101.3001.7020)（fps）并不是衡量游戏稳定体验的理想指标。考虑以下情况：在运行时的前 0.75s 内渲染了 59 帧。然后接下来的 1 帧需要 0.25s 才能渲染完毕。虽然是 60fps，但实际上会让玩家感觉卡顿。

这是需要设置帧时间预算的重要原因之一。这为您提供了一个目标，在对游戏进行分析和优化时可以朝着这个目标努力，最终创造更流畅、更稳定的游戏体验。

基于目标 fps，每帧都将有一个时间预算。一个目标 30fps 的应用程序每帧时间预算不应超过 33.33ms（1000ms/30fps）；同理，目标 60fps 分配给每帧的时间预算为 16.66ms。

在非交互式情况（例如显示 UI 菜单或场景加载）中，可以超过这个时间预算，但在游戏玩法过程中不行。即使只有一帧的时间超过了预算，也会导致卡顿。

在 VR 游戏中，始终保持高帧率非常重要，这样才能避免给玩家造成不适。

### FPS：具有欺骗性的指标

游戏玩家常用的衡量性能的方法是帧率（fps）。然而建议改用帧时间。请看下面这幅以 fps 和帧时间为变量的图表。

![[a653ab3f7e6f90035f05074fd695ae96_MD5.png]]

fps vs. frame time

考虑以下数字：

1000ms/900 帧 = 每帧 1.111ms

1000ms/450 帧 = 每帧 2.222ms

1000ms/60 帧 = 每帧 16.666ms

1000ms/56.25 帧 = 每帧 17.777ms

如果应用程序以 900fps 运行，这意味着每帧的帧时间为 1.111ms。在 450fps 时，每帧的帧时间为 2.222ms。这表示，即使帧速率下降了一半，每帧的差别也仅为 1.111ms。

如果比较 60fps 和 56.25fps 之间的差异，那么每帧的帧时间分别为 16.666ms 和 17.777ms。同样这也表示每帧多了 1.111ms 的时间，但在这里，帧速率下降在百分比上感觉要小得多。

这就是为什么开发人员使用平均帧时间来衡量游戏速度，而不是使用 fps。别担心 fps，除非帧率掉到了目标帧率之下。

## 移动端挑战：发热管理和电池续航

发热管理是[移动端开发](https://so.csdn.net/so/search?q=%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91&spm=1001.2101.3001.7020)的重要优化方向之一。如果 CPU 或 GPU 由于低效的代码而一直保持满负荷，会产生芯片发热问题。为了避免芯片受损，操作系统将降低设备的时钟速度以降温，会导致帧率卡顿和用户体验下降。同时移动设备发热也会影响电池寿命。

高帧率和增加代码执行（或 [DRAM](https://so.csdn.net/so/search?q=DRAM&spm=1001.2101.3001.7020) 访问操作）会导致更大的电量消耗和发热。糟糕的性能还可能直接排除了低端设备，这可能会导致错失市场机会。

在解决发热问题时，要考虑到全局预算来解决问题。通过使用早期分析技术来优化游戏，为目标硬件配置项目设置，以应对发热和电池问题。

### 调整移动设备的帧时间预算

为了延长游戏可玩时长，并解决发热问题，通常建议每帧保留约 35% 的空闲时间。这给移动芯片提供了降温时间，并有助于防止过度耗电。设定目标帧时间为 33.33ms（30fps），设备的帧时间预算将约为 22ms。

公式如下：**（1000ms/30）* 0.65 = 21.66ms**

要达到 60fps，使用上面的公式得出（1000ms/60）* 0.65 = 10.83ms。这在许多移动设备上很难实现，并且会使耗电速度 2 倍于 30fps 时。因此，多数移动游戏的目标帧率选择 30fps 而不是 60fps。使用 Application.targetFrameRate 来设置帧率。

在性能分析时，移动芯片的频率缩放可能会影响识别帧空闲时间。在优化之前和优化之后, 使用自定义工具 (如 FTrace 或 Perfetto)，来监测移动芯片的频率、空闲时间和频率调节。

只要保持在目标帧时间预算内（30 fps 为 33.33ms），并且帧率和设备温度都很稳定，那么就没什么问题。

![[7ae5790be801b1940874d0a7ae4944df_MD5.png]]

使用 FTrace 或 Perfetto 等工具监视 CPU 频率和空闲状态，以帮助识别帧预算优化的结果

在移动设备上，每帧分配空闲时间的另一个原因是考虑到现实中的温度变化。在炎热的天气里，移动设备的发热和散热问题会加重，将会导致游戏性能下降。留出一定比例的帧预算将有助于避免这些情况。

### 减少内存访问操作

在移动设备上，DRAM 访问是一种耗能操作。[optimization advice for graphics content on mobile devices](https://link.zhihu.com/?target=https%3A//developer.arm.com/documentation/102643/0100/ "optimization advice for graphics content on mobile devices") 指出，LPDDR4 内存访问成本约为每字节 100 皮焦耳。

通过以下方式减少内存访问：

*   降低帧率
*   在允许的情况下降低显示分辨率
*   使用顶点数量较少和属性精度较低的网格
*   使用纹理压缩和多级纹理映射技术

当需要专注于 Arm 或 Arm Mali 设备时，[Arm Mobile Studio](https://link.zhihu.com/?target=https%3A//developer.arm.com/Tools%2520and%2520Software/Arm%2520Mobile%2520Studio "Arm Mobile Studio")（特别是 [Streamline Performance Analyzer](https://link.zhihu.com/?target=https%3A//developer.arm.com/Tools%2520and%2520Software/Streamline%2520Performance%2520Analyzer "Streamline Performance Analyzer")）等工具，可用于识别内存带宽问题。这些工具针对每个 Arm GPU 代进行了列出和解释，如 Mali-G78。请注意，Mobile Studio GPU 分析依赖 Arm Mali。

![[f56d5d31e63eb356af93e6ef23698a15_MD5.png]]

Arm 的 Streamline Performance Analyzer 包含大量性能计数信息，可以在目标 Arm 硬件上进行实时分析时捕获该信息。有助于识别由 overdraw 引起的内存带宽饱和等性能问题。

### 为基准测试建立硬件分级

在不同的平台下，还需要为设备做档位分级，并分别确定一个最低规格设备，并做针对性性能分析和优化。 例如，在移动平台下支持三个档位，基于目标硬件做品质控制（启用或关闭一些特性）。然后针对各级别中的最低规格设备进行优化。

### 从高到低级别的性能分析

在性能分析时 (禁用 Deep Profiling)，使用自顶向下的方法收集数据并记录哪些情况会导致核心循环中出现不必要的托管分配或太多的 CPU 时间。

首先需要收集 GC.Alloc 标记的调用堆栈。

如果报告的调用堆栈详情不足以跟踪分配源，那么启用 Deep Profiling 进行第二次性能分析，以查找分配源。

## 早期性能分析

在项目早期阶段开始性能分析可以获得最佳的优化效果。在项目早期，定期进行性能分析，以便您和团队了解项目的性能水平。如果性能出现急剧下降，就能够轻松地发现并解决问题。在目标设备上运行游戏，同时利用平台特定的工具进行性能分析，以获得最准确的分析结果。

### **找出瓶颈**

在一些平台上，很容易确定您的应用程序是由 CPU 或 GPU 限制。例如，从 Xcode 运行 iOS 游戏时，帧率面板显示了一个柱状图，其中包括 CPU 和 GPU 的总时间，可以看到对比。注意，CPU 时间包括等待 VSync（移动设备上始终是启用的）的时间。

![[0de5ad75b408fae2bcf03de45dcd81e3_MD5.png]]

Xcode fps 视图，显示了游戏运行时，CPU 和 GPU 都运行在 33.3ms 内。

### **什么是 VSync?**

VSync 将应用程序的帧率与显示器的刷新速率同步。这意味着，如果您有一个 60Hz 的显示器，并且游戏的帧预算在 16.66ms 内，则它会强制以 60fps 运行，而不允许更快。将帧率与显示器的刷新速率同步，可以减轻 GPU 的负担并解决屏幕撕裂等视觉图像瑕疵。在 Unity 中，通过 Quality settings 可以设置 VSync Count (Edit> Project Settings > Quality)。

Unity Profiler 提供了足够的信息来定位性能瓶颈。下面的流程图说明了初始的分析过程，后面的部分提供了每个步骤的详细信息。

![[2f2daad81b4cf4d3d38424058f222bf1_MD5.png]]

为了全面了解所有 CPU 活动，包括等待 GPU 时的情况，可以使用 Profiler CPU usage 模块中的 timeline 视图。熟悉常见的 Profiler marker 以帮助正确理解捕获结果。一些 Profiler marker 可能因目标平台而异，因此花时间在每个目标平台上浏览捕获结果，了解 “正常” 捕获结果的特征。

项目的性能受限于芯片或线程中最耗时的部分。优化工作也应该集中在这些部分。假设游戏的目标帧时间预算为 33.33ms，并启用了 VSync：

*   如果 CPU 帧时间（不包括 VSync）为 25ms，GPU 时间为 20ms，那就没有问题了！虽然受限于 CPU，但时间在预算内，优化也不会再提高帧率（除非将 CPU 和 GPU 都降到 16.66ms 以下，并提高到 60 fps）。
*   如果 CPU 帧时间为 40ms，GPU 为 20ms，这时受限于 CPU，并需要优化 CPU 性能。优化 GPU 性能没有任何帮助，可以将一些 CPU 工作转移到 GPU 上，例如使用计算着色器而不是 C# 代码，以平衡出其差异。
*   如果 CPU 帧时间为 20ms，GPU 为 40ms，这时受限于 GPU，需要优化 GPU 工作。
*   如果 CPU 和 GPU 都达到了 40ms，那么受限于两者，需要将它们都优化到 33.33ms 以下才能达到 30 fps。

### 是否在帧预算内？

在开发中定期进行分析和优化，以确保 CPU 线程和整体 GPU 帧时间都在帧预算内。

下图是一款移动游戏的分析捕获图像，该游戏在高配手机上达到 60 fps，在中 / 低配手机上达到 30 fps。

![[6b592e1a98a5464dbcd9397bf9c3bbf7_MD5.png]]

该游戏在不超过 22 毫秒的帧预算内，以 30 fps 流畅运行且不会过热。直到 VSync，主线程的 WaitForTargetfps 会填充主线程时间，而渲染线程和工作线程中还有灰色的空闲时间。同时，可以通过查看 Gfx.Present 帧结束时间来观察 VBlank 间隔。

注意到当前帧的近一半时间都由黄色的 WaitForTargetfps Profiler 标记占据。应用程序设置 Application.targetFrameRate 为 30 fps，并且启用了 VSync。主线程上的实际处理工作在约 19ms，其余时间花在等待，然后开始下一帧。

标记在不同平台或禁用 VSync 时可能不同。重要的是检查主线程是否控制在帧预算时间内运行，或者显示有某种标记，代表主线程正在处于等待 VSync 或者其他线程的空闲时间内。

空闲时间由灰色或黄色的标记表示。上图中显示，渲染线程正处于 Gfx.WaitForGfxCommandsFromMainThread 的空闲状态，这表明它已经完成了一帧中对 GPU 的 draw call 发送，并正在等待下一帧中来自 CPU 的 draw call 请求。同样，虽然 Job Worker 0 线程在 Canvas.GeometryJob 中花费了一些时间，但大部分时间是空闲的。这些代表应用程序在帧预算内流畅运行。

### CPU 受限

如果 CPU 超出了帧预算时间，下一步是调查哪个线程最繁忙。分析找出瓶颈作为优化的目标；如果依靠猜测，可能会优化游戏中非瓶颈的部分，导致整体性能几乎没有改善。有些 “优化” 甚至反而会降低游戏的整体性能。

CPU 成为瓶颈的情况相当少。现代 CPU 具有许多不同的核心，能够独立并行地执行任务。不同的线程运行在 CPU 核心上。Unity 使用不同的线程以达到不同目标。查找性能问题的常见线程有：

*   主线程：默认情况下，这是所有游戏逻辑和脚本执行其工作的地方，在像物理、动画、用户界面和渲染等特性和系统中花费大部分时间。
*   渲染线程：在渲染过程中，主线程检查场景并执行相机剪裁、深度排序和 draw call batching，生成需要渲染的对象列表。这个列表传递给渲染线程，后者将其从 Unity 内部的平台无关表示转换成特定的图形 API 调用，以指示 GPU 在特定平台上执行工作。
*   Job worker 线程：可以使用 C# job 系统安排某些工作在 job worker 线程上运行，以分担主线程的工作量。Unity 的某些系统和特性也使用 job 系统，如物理、动画和渲染等。

### 主线程

下图显示了一个主线程受限的情况。

![[2ef017a99dcb0fe1b2198e02e36b6941_MD5.png]]

主线程受限的项目中捕获的结果

即使考虑到帧末段的少量分析器开销，主线程也占用了超过 45ms，这意味着帧率不到 22fps。这里没有显示主线程等待 VSync 的空闲时间的标记；主线程整个帧期间都处于工作状态。

下一步是确定当前帧中占用时间最长的部分，并了解原因。当前帧中，PostLateUpdate.FinishFrameRendering 占用了 16.23ms，超过整个帧率预算时间。检查发现，有 5 个名为 Inl_RenderCameraStack 标记的实例，表明有 5 个处于活动状态的相机在渲染场景。Unity 中每个相机都会调用整个渲染管道，包括剔除、排序和批量处理，因此当下最优先的任务是减少活动相机的数量，最好只保留一个活动相机。

BehaviourUpdate 标记 (表示所有 MonoBehaviour Update())，占用了 7.27ms，同时 timeline 中品红色部分表示脚本中分配托管堆内存的位置。切换到 Hierarchy 视图，在搜索栏中输入 GC.Alloc 进行过滤，可以看到在当前帧中分配内存占用约 0.33ms。但是，这不是衡量内存分配对 CPU 性能影响的准确方法。

GC.Alloc 标记实际上不是通过测量开始到结束点的时间来计时的。为了降低开销，它们只记录开始的时间戳加上分配的大小。为确保它们可见，Profiler 会为它们分配一小部分时间。实际上分配可能需要更长的时间，特别是需要从系统申请新的内存时。为了清晰地看到影响，可以在对应的代码周围打上 Profiler 标记，在深度分析中，timeline 视图中品红色 GC.Alloc 采样之间的间隔，指示了它们可能的消耗时长。

此外，分配新内存可能对性能产生负面影响，这些影响更难以直接测量：

*   从系统请求新内存可能会影响移动设备上的电源，导致系统降低 CPU 或 GPU 的运行速度。
*   新内存可能需要加载到 CPU 的 L1 缓存中，从而推出现有的缓存行。
*   当托管内存中的可用空间不足时，可能直接或延迟触发 GC。

在当前帧开始时，4 个 Physics.FixedUpdate 实例占用了 4.57ms。随后，LateBehaviourUpdate 标记（MonoBehaviour.LateUpdate()）占用了 4 ms， Animator 大约占用 1 ms。

为了项目达到预期帧率，需要调查主线程的所有问题并找到适当的优化方法。通过优化时间占比最长的部分来实现最大的性能提升。

以下是主线程受限时，查找问题容易获益的地方：

*   物理
*   MonoBehaviour 脚本更新
*   垃圾分配和回收
*   相机剔除和渲染
*   draw call batching 问题
*   UI 更新、布局和重建
*   动画

针对具体问题，使用其他工具：

*   对于 MonoBehaivour 脚本，可以在代码中添加 Profiler 标记或启用深度分析。
*   对于分配托管内存的脚本，启用 Allocation Call Stacks 定位分配来源。也可以启用深度分析或使用 Project Auditor。
*   使用 Frame Debugger 来调查 draw call batching。

### 渲染线程

以下显示了渲染线程受限的情况。其目标帧预算为 33.33 ms。

![[187ffa8d24c77e7da39b171d8a92d4b9_MD5.png]]

profiler 显示，在当前帧开始渲染之前，主线程在等待渲染线程（Gfx.WaitForPresentOnGfxThread 标记）。渲染线程仍在提交上一帧的 draw call 命令，并且还没有准备好接受主线程的新 draw calls；渲染线程中 Camera.Render 正在耗时。

可以通过标记的颜色区分当前帧标记和其他帧标记，后者颜色更暗。还可以看到，一旦主线程能够继续发出 draw call 给渲染线程，渲染线程需要超过 100 ms 的时间来处理当前帧，这也给下一帧制造了瓶颈。

进一步的调查发现，该游戏有一个复杂的渲染设置，涉及 9 个相机和许多由替换着色器引起的额外 pass。使用前向渲染路径渲染超过 130 个点光源，每个光源可以增加多个附加的透明 draw call。这些问题合在一起，每帧会产生超过 3000 次 draw call。

以下是常见的导致渲染线程受限的原因，需要进一步排查：

*   draw call batching 问题，特别是在旧的图形 API 上（如 OpenGL 或 DirectX 11）。
*   相机过多。除非制作的是分屏多人游戏，一般只需要一个活动相机。
*   剔除问题，导致渲染物体过多。调查相机的截锥体大小和剔除层掩码。考虑启用遮挡剔除，甚至创建自定义遮挡剔除系统。查看场景中有多少投射阴影的对象 - 阴影剔除与 “常规” 剔除是在不同的通道中进行的。

Rendering profiler 显示每帧 draw call batches 和 SetPass call 数量的概述。查看 draw call batches 的最佳工具是 Frame Debugger。

### GPU 受限

如果主线程在 Profiler 标记（例如 Gfx.WaitForPresentOnGfxThread）中花费大量时间，而渲染线程同时显示 Gfx.PresentFrame 或 <GraphicsAPIName>.WaitForLastPresent 等标记，则应用程序出现了 GPU 受限。

下图捕获自三星 Galaxy S7(Vulkan)。尽管 Gfx.PresentFrame 中的一些时间可能与等待 VSync 有关，但此 Profiler 标记的长度表明大部分时间都在等待 GPU 完成上一帧的渲染。

![[5797e7867ba9b8d17004e591797bac0e_MD5.png]]

在这个游戏中，特定的游戏事件触发了使用一个着色器，将 GPU 渲染的 draw call 增加了三倍。当分析 GPU 性能时，需要调查以下常见问题：

*   全屏后处理效果，包括环境光遮蔽和泛光等
*   片元着色器：分支逻辑；使用完全浮点精度而不是半精度；过多地使用影响 GPU 波前占用率的寄存器
*   透明渲染队列中的 overdraw：低效的 UI、粒子系统或后处理效果
*   过高的屏幕分辨率，例如 4K 显示器或移动设备的视网膜屏
*   密集的网格，缺乏使用 LOD
*   缓存未命中和浪费 GPU 内存带宽：由未压缩的纹理或未启用 mipmap 的高分辨率纹理引起
*   几何或镶嵌着色器，如果启用动态阴影，则可能每帧运行多次

如果怀疑 GPU 受限，可以使用 Frame Debugger 快速了解发送到 GPU 的绘制调用批次。但是此工具不能提供任何特定的 GPU 时间信息。