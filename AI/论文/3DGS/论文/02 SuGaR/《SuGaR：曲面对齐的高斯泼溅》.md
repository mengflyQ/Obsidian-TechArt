---
title: SuGaR
uid: "202404041611"
create_time: 2024-04-03 21:51
title translation: SuGaR： 用于高效 3D Mesh 重建和高质量 Mesh 渲染的曲面对齐的高斯泼溅
grade: 
author: 
date: 
DOI: 
url:
  - https://arxiv.org/abs/2311.12775
banner: "[[Pasted image 20240404161458.png]]"
---
作者主页：[Antoine Guédon (anttwo.github.io)](https://anttwo.github.io/)

**SuGaR: Surface-Aligned Gaussian Splatting** for Efficient 3D Mesh Reconstruction and High-Quality Mesh rendering

SuGaR： 用于高效 3D Mesh 重建和高质量 Mesh 渲染的**曲面对齐的高斯泼溅**

本问将 surface 译为曲面，将 Mesh 翻译为网格

> [!abstract] 
我们提出了一种方法，可以从三维高斯拼接中精确、快速地提取 Mesh。高斯拼接最近非常流行，因为它能产生逼真的渲染效果，同时训练速度明显快于 NeRFs。然而，从数百万个微小的三维高斯中提取网格是一项挑战，因为这些高斯在优化后往往是无序的，而且迄今为止还没有提出任何方法。
>
**我们的第一个关键贡献是一个正则化项**（regularization term），它能促使高斯与场景曲面保持一致。与通常用于从神经 SDF 中提取网格的 Marching Cubes 算法相比，这种方法快速、可扩展并能保留细节。**最后，我们引入了一种可选的改进策略，将高斯绑定到网格曲面，并通过高斯拼接渲染对这些高斯和网格进行联合优化。**
>
这样就可以通过操作网格而不是高斯模型本身，轻松对高斯模型进行编辑、雕刻、动画制作和重新照明。使用我们的方法，只需几分钟就能检索出这样一个可编辑的网格进行逼真渲染，而使用 SDF 的先进方法则需要数小时，同时还能提供更好的渲染质量。


![[Pasted image 20240404161458.png]]
>图 1：我们介绍了一种方法，可在几分钟内通过单个 GPU 从三维高斯拼接表示法中提取精确且可编辑的网格。这些网格可以编辑、动画、合成等。它具有非常逼真的高斯溅射渲染效果，为计算机图形学提供了新的可能性。例如，在左下方的捕捉场景和右边的合成场景之间，我们改变了机器人的姿势。补充材料提供了更多示例，包括一段展示我们成果的视频。

![[Pasted image 20240404161903.png]] 
>图 2：我们的算法可以在单个 GPU 上几分钟内从任何三维高斯拼接场景中提取高度精细的网格（上图：无纹理网格的渲染图，下图：有边界高斯（bound Gaussians）的网格渲染图）。

# 1 引言
继 NeRFs 之后，三维高斯拼接技术最近在捕捉三维场景并从新视角对其进行渲染方面变得非常流行。
三维高斯拼接技术以一组场景训练图像为基础，优化许多微小三维高斯的位置、方向、外观（以球谐函数表示）和 alpha 混合，以捕捉场景的几何形状和外观。由于渲染高斯比渲染神经场要快得多，因此 3D 高斯拼接比 NeRF 快得多，可以在几分钟内捕捉到一个场景。
虽然高斯模型可以非常逼真地渲染场景，但要从中提取场景的曲面仍然具有挑战性：如图 3 所示，**经过三维高斯拼接优化后，高斯一般不具有有序结构，与实际场景曲面的对应关系并不理想。**
![[Pasted image 20240404162327.png]] >>
>图 3：从高斯模型中提取网格。在没有正则化的情况下，优化后的高斯没有特殊的排列方式，这使得提取网格非常困难。如果没有我们的正则化项，Marching Cubes 无法提取可接受的网格。有了我们的正则化项，即使是非常精细的三维网格，Marching Cubes 也能恢复出噪声极高的网格。我们的可扩展提取方法即使在没有正则化项的情况下也能获得网格。但是，网格噪声仍然很大。相比之下，我们的完整方法能非常高效地重建精确网格。

除了曲面本身外，通常还需要将场景表示为网格，这在许多管线中仍是首选的表示方法：基于网格的表现形式可以提供强大的编辑、雕刻、动画和场景重光工具。**由于高斯拼接后的高斯是非结构化的，因此从中提取网格非常具有挑战性。需要注意的是，这对 NeRFs 也同样具有挑战性，只是原因不同而已。**

在本文中，**我们首先提出了一个<mark style="background: #FF5582A6;">正则化项</mark>，鼓励高斯在场景曲面良好分布，这样高斯就能更好地捕捉场景的几何形状**，如图 3 所示。**我们的方法是在假设高斯平坦且在场景曲面分布良好的前提下，从高斯中推导出体积密度。**

**在优化过程中，通过<mark style="background: #FF5582A6;">最小化该密度与根据高斯计算的实际密度之间的差异</mark>，我们鼓励三维高斯很好地表现曲面几何形状。**

有了这个正则化项，从高斯模型中提取网格就变得容易多了。**事实上，由于我们引入了一个密度函数来评估正则化项，因此一个自然的方法就是提取这个<mark style="background: #FF5582A6;">密度函数的水平集（level sets）</mark>**。然而，高斯拼接技术会进行密集化处理，以便高保真地捕捉场景细节，从而导致高斯数量急剧增加。真实场景中通常会有一个或数百万个不同比例和旋转的三维高斯，为了再现场景中的纹理和细节，大部分高斯都非常小。这导致密度函数几乎处处接近于零，而 Marching Cubes 算法即使使用精细的体素网格也无法提取这种稀疏密度函数的适当水平集，如图 3 所示。

相反，**我们引入了一种方法，可以非常高效地对密度函数水平集可见部分的点进行采样，从而在这些点上运行<mark style="background: #FF5582A6;">泊松重建算法</mark>，获得三角形网格。** 与 "Marching Cubes"算法等相比，这种方法具有可扩展性，在单个 GPU 上几分钟内就能重建曲面网格，而其他依靠神经 SDF 从辐射场提取网格的先进方法，在单个 GPU 上至少需要 24 小时，并且需要多个 GPU 来加快进程。

如图 2 和图 4 所示，我们的方法可以生成高质量的网格。**我们面临的挑战是如何有效地识别水平集上的点。为此，我们依靠从训练视点看到的高斯深度图。** 这些深度图可以通过扩展高斯拼接光栅化器来获得，我们将展示如何从这些深度图出发，对水平集上的点进行精确采样。 

**最后，在提取该网格后，我们提出了一种可选的改进策略，即仅通过高斯拼接渲染来联合优化网格和一组三维高斯。** 通过这种优化，可以使用高斯溅射渲染技术而不是传统的纹理网格渲染技术，实现高质量的网格渲染。

因此，与其他依赖底层网格进行推理的辐射场模型相比，高斯拼接模型具有更高的渲染质量性能[39, 6, 26]。如图 1 所示，这使得使用传统的网格编辑工具编辑场景的高斯拼接表示成为可能，为计算机图形学提供了无限可能。

总之，我们的贡献是
- 一个正则化项，使高斯模型能准确捕捉场景的几何形状；
- 一种高效的算法，能在几分钟内从高斯模型中提取出精确的网格；
- 这种方法可将高斯绑定到网格上，从而获得更精确的网格，与目前使用网格进行新视图合成的方法相比，渲染质量更高，并允许以多种不同方式编辑场景。

# 2 相关工作
基于图像的渲染（IBR）方法依赖于一组场景的二维图像来生成场景表示并渲染新视图。最早的新视图合成方法基于光场，并提出了新视图的体积渲染概念。他们的工作强调了高效遍历体积数据以生成逼真图像的重要性。此后，人们提出了各种场景表示法，如三角形网格、点云、体素网格、多平面图像或神经隐函数。

## 2.1 基于网格的传统 IBR 方法

运动恢复结构（SfM）和随后的多视角立体（MVS）允许对曲面进行三维重建，从而开发出几种依赖三角形网格作为场景主要三维表示的视图合成算法。这些算法考虑了纹理三角形，或将捕捉到的图像在网格曲面进行扭曲和混合，以生成新的视图[37, 4, 12]。[29, 30]考虑了基于深度学习的网格表示法，以实现更好的视图合成，弥补了传统图形学与现代机器学习技术之间的差距。虽然这些基于网格的方法利用了现有的图形硬件和软件来实现高效渲染，但在复杂区域捕捉精确的几何图形和外观方面仍有困难。

## 2.2 体积式 IBR 方法

体积法使用体素网格、多平面图像或神经网络，将场景表示为密度和颜色的连续体积函数。最近，神经辐射场（NeRF）引入了一种基于连续体积函数的新型场景表示法，该函数由多层感知器（MLP）参数化。NeRF 通过体积光线追踪技术生成具有精细细节和视图效果的逼真渲染效果。然而，最初的 NeRF 计算成本很高，而且占用大量内存。为了应对这些挑战，一些研究工作提高了 NeRF 的性能和可扩展性。这些方法利用像素网格（voxel grids）和哈希表等离散或稀疏的体积表示法来存储可学习的特征，作为三维点的位置编码、分层采样策略或低秩近似。
然而，它们仍然依赖于体积光线步进，这与为渲染多边形曲面而设计的标准图形硬件和软件不兼容。最近的研究提出了修改 NeRF 对几何体和发射辐射的表示，以便更好地重建镜面材料，或通过将材料和照明属性明确分解来重新照明场景。

## 2.3 混合 IBR 方法
有些方法建立在可微分渲染的基础上，结合了基于网格和体积方法的优势，可以进行曲面重建，并具有更好的可编辑性。这些方法采用体积-曲面混合表示法，可生成适合下游图形应用的高质量网格，同时有效地模拟视图相关外观。

特别是，一些研究通过训练神经辐射场来优化神经有向距离场（SDF），其中密度是作为 SDF 的可微分变换导出的。最后，通过应用 Marching Cubes 算法[21]，可以根据 SDF 重建三角形网格。然而，这些方法大多不以实时渲染为目标。

另外，还有一些方法将优化的 NeRF 或神经 SDF 的渲染能力 "烘焙 "成一种高效的结构，这种结构依赖于底层三角形网格，可以从传统的三角形光栅化管道中受益。特别是最近的 BakedSDF，它通过优化完整的神经 SDF 模型，将其烘焙到高分辨率的三角形网格中，结合网格渲染来插值特征，并通过深度学习将这些特征转化为图像，最后优化与视图相关的外观模型，从而重建高质量的网格。然而，尽管它能实现实时渲染并生成令人印象深刻的场景曲面网格，但该模型需要训练一个完整的神经 SDF，其架构与 Mip-NeRF360 完全相同，这就需要 48 小时的训练。

同样，最近的 NeRFMeshing [26] 方法也提出将任何 NeRF 模型烘焙成网格结构，从而实现实时渲染。然而，这种方法中执行的网格划分降低了渲染质量，导致 PSNR 远远低于我们的方法。此外，这种方法仍然需要事先训练一个完整的 NeRF 模型，并且需要在 8 个 V100 NVIDIA GPU 上进行大约一个小时的训练，以便进行网格训练和提取。

我们的方法从三维高斯拼接中获取三维网格的速度要快得多，这本身就比 NeRFs 快得多。正如我们的实验所显示的，我们通过将高斯限定在网格上进行的渲染比以前基于网格的解决方案质量更高。

## 2.4 基于点的 IBR 方法
另外，基于点的辐射场表示法擅长对薄几何体建模，并利用快速的点光栅化管道，使用 $\alpha$ 混合而非光线步进来渲染图像。特别是最近推出的 3D 高斯拼接模型，可以优化和渲染场景，其速度和质量都是前所未有的。

# 3 3D 高斯泼溅简介
为完整起见，我们在此简要介绍一下原始的 3D 高斯拼接方法。场景表示为一组（大）高斯，其中每个高斯 $g$ 由其平均值 $\mu_g$ 表示，其协方差 $\Sigma_g$ 由缩放向量 $s_g∈ℝ3$ 和编码高斯旋转的四元数 $q_g∈ℝ4$ 参数表示。此外，每个高斯都与其不透明度 $\alpha_g∈[0,1]$ 和一组球谐坐标相关联，这组球谐坐标描述了高斯在所有方向上发出的颜色。

通过光栅化器，一组高斯图像可以从给定视角进行渲染。该光栅器可将三维高斯图拼接成与图像平面平行的二维高斯图进行渲染，从而实现极快的渲染过程。这是 3D 高斯拼接比 NeRFs 快得多的关键因素，因为它比 NeRFs 优化所需的光线行进合成快得多。

在给定一组图像的情况下，根据 SfM 生成的点云初始化高斯集。高斯参数（均值、四元数、缩放矢量以及不透明度和球谐参数）经过优化，使高斯的渲染效果与输入图像相匹配。在优化过程中，会添加更多的高斯，以更好地适应场景的几何形状。因此，高斯拼接通常会产生具有数百万个高斯的场景，这些高斯可能非常小。

# 4 方法

本节将介绍我们的 SuGaR：
- 首先，我们详细介绍了在高斯拼接优化过程中强制三维高斯与场景曲面对齐的损失项（loss term）。
-  然后，我们详细介绍了我们的方法，该方法利用这种对齐方式，在单个 GPU 上几分钟内就能从高斯中提取出高度精细的网格。
- 最后，我们介绍了我们的可选细化策略（refinement strategy），该策略利用高斯拼接渲染技术对网格和网格曲面的三维高斯进行联合优化。该策略可生成一组绑定到可编辑网格上的新高斯。

### 4.1 将高斯线与曲面对齐
如导言所述，为了便于根据高斯创建网格，我们在高斯拼接优化中引入了一个正则化项，促使高斯与场景表面对齐，并在该表面上均匀分布。

我们的方法是在假设高斯具有所需属性的前提下，从高斯中推导出一个 SDF。通过最小化该 SDF 与为高斯计算的实际 SDF 之间的差值，我们鼓励高斯具有这些特性。

**对于给定的高斯拼接场景，我们首先要考虑的是相应的密度函数 $d:ℝ^3→ℝ_+$，计算方法是在任意空间位置 $p$ 上，高斯值与 $\alpha$ 混合系数的加权和：**
$$
d(p)=\sum_g\alpha_g\exp\left(-\frac{1}{2}(p-\mu_g)^T\Sigma_g^{-1}(p-\mu_g)\right)\tag{1}
$$
其中 $\mu_g$ 、 $\Sigma_g$ 和 $\alpha_g$ 分别是高斯的中心、协方差和 $\alpha$ 混合系数。让我们考虑一下，如果高斯分布良好并与表面对齐，密度函数会变成什么样子。

首先，在这种情况下，高斯与其邻域的重叠有限。如图 3（左上角）所示，一般情况下并非如此。那么，**对于任何靠近场景表面的点 $p∈ℝ^3$ 来说，最靠近点 $p$ 的高斯 $g^*$ 对密度值 $d(p)$ 的贡献可能远远大于其他高斯**。因此，**我们可以通过以下方法来近似计算 $p$ 处的高斯密度：**
$$
\alpha_{g^{*}}\exp\left(-\frac12(p-\mu_{g^{*}})^T\Sigma_{g^{*}}^{-1}(p-\mu_{g^{*}})\right)\tag{2}
$$

其中，"最近高斯" $g^*$ 被认为是在点 $p$ 上贡献最大的高斯：
$$
g^*=\arg\min_{g}\left\{(p-\mu_{g})^T\Sigma_{g}^{-1}(p-\mu_{g})\right\}\tag{3}
$$
**因此，公式 (2) 认为最接近的高斯 $g^*$ 对 $p$ 处密度的贡献远大于其他高斯的贡献。这将有助于我们鼓励高斯充分扩散。**

我们还希望三维高斯是平面的，因为这样它们就能更紧密地与网格表面对齐。因此，**每个高斯 $g$ 的三个缩放因子中都有一个接近 0：**
$$
(p-\mu_{g})^T\Sigma_{g}^{-1}(p-\mu_{g})\approx\frac{1}{s_{g}^{2}}\langle p-\mu_{g},n_{g}\rangle^2\tag{4}
$$
其中 $s_g$ 为高斯的最小缩放因子， $n_g$ 为相应轴线的方向。**此外，由于我们希望高斯能够描述场景的真实表面，因此需要避免半透明高斯。** 因此，我们希望高斯要么是不透明的，要么是完全透明的，在这种情况下，我们可以在呈现时放弃它们。因此，我们希望任何高斯 $g$ 都有 $\alpha_g=1$ 。

**在这种情况下，高斯的密度最终可以用密度 $\bar d(p)$ 来近似：**
$$
\bar d(p)=\exp\left(-\frac{1}{2s_{g^*}^2}\langle p-\mu_{g^*},n_{g^*}\rangle^2\right)\tag{5}
$$
**实施正则化的第一个策略是在优化损失中添加 $| d(p)-\bar d(p)|$ 项。** 虽然这种方法可以很好地**将高斯与表面对齐**，但我们注意到，依靠 SDF 而不是密度来计算略有不同的损失，可以进一步提高高斯与场景表面的对齐度。对于给定的平面高斯（即 $s_g=0$ ），考虑水平集是没有意义的，因为所有水平集都会向通过高斯中心 $\mu_g$ 的平面退化，法线为 $n_g$ 。点 $p$ 与场景真实表面之间的距离约为 $|\langle p-\mu_{g^{\prime}},n_{g^{\prime}}\rangle|$ ，即 $p$ 到该平面的距离。因此，**有向距离函数 SDF 的零交叉点**
$$
\bar{f}(p)=\pm s_{g*}\sqrt{-2\log\left(\bar{d}(p)\right)}\tag{6}
$$
与场景表面相对应。一般来说，我们定义
$$
{f}(p)=\pm s_{g*}\sqrt{-2\log\left({d}(p)\right)}\tag{7}
$$
作为与密度函数 $d$ 相关联的 "理想 "距离函数。该距离函数对应于理想情况下场景的真实表面，即 $d=\bar{d}$ 。因此，**我们将<mark style="background: #FF5582A6;">正则化项</mark> $\mathcal{R}$ 取为**
$$
\mathcal{R}=\frac{1}{|\mathcal{P}|}\sum_{p\in\mathcal{P}}|\hat{f}(p)-f(p)|\tag{8}
$$
方法是对三维点 $p$ 进行采样，并求和这些点上理想 SDF $f(p)$ 与当前高斯创建的曲面 SDF 估计值 $\hat{f}(p)$ 之间的差值。 𝒫 指的是采样点集合。

![[Pasted image 20240404205117.png]]
>图 5：有效估计由高斯生成的表面的 SDF  $\hat{f}(p)$  。我们渲染高斯的深度图，根据高斯的分布在视点中对 $p$ 点进行采样。  $\hat{f}(p)$  值为 $p$ 点与沿 $p$ 视线和深度图交点之间的三维距离。

**高效计算  $\hat{f}(p)$  是一项先验挑战（_priori_ challenging）。为此，我们建议使用训练视点的高斯深度图--这些深度图可以通过扩展拼接光栅化器来高效呈现**。然后，如图 5 所示，对于从训练视角可见的点 $p$ ，  $\hat{f}(p)$ 是 $p$ 的深度与 $p$ 投影处相应深度图的深度之差。**此外，我们按照高斯分布对 $p$ 点进行采样：**
$$
p\sim\prod_g\mathcal{N}(.;\mu_g,\Sigma_g)\tag{9}
$$
其中 $\mathcal{N}(.;\mu_g,\Sigma_g)$ 是均值 $\mu_g$ 和协方差 $\Sigma_g$ 的高斯分布，因为这些点很可能与 $\mathcal{R}$ 的高梯度相对应。

**我们还添加了一个<mark style="background: #FF5582A6;">正则化项</mark>，以促使 SDF $f$ 的法线和 SDF $\bar{f}$ 的法线也相似：**
$$
\mathcal{R}_{\mathrm{Norm}}=\frac{1}{|\mathcal{P}|}\sum_{p\in\mathcal{P}}\left\|\frac{\nabla f(p)}{\|\nabla f(p)\|_2}-n_{g^*}\right\|_2^2\tag{10}
$$
## 4.2 高效网格提取
为了使用公式 (8) 和公式 (10) 中的正则化项对优化后得到的高斯进行网格创建，**我们在根据高斯计算出的密度水平集上对三维点进行采样**。水平集取决于水平参数 $\lambda$ 。**然后，我们只需在这些点上运行泊松重建，就能得到网格**。需要注意的是，**我们还可以根据 SDF 的法线轻松地分配点，从而提高网格质量。**

![[Pasted image 20240404211346.png]]
>图 6：泊松重建在水平集上取样。
>左图： 我们对高斯深度图上的点进行采样，并细化点的位置，以移动水平集上的点。
>右图：没有（左）和有（右）细化步骤的提取网格对比。**由于拼接深度图并不精确，直接使用深度点进行重建通常会产生大量噪音和细节缺失。**

**我们面临的挑战是如何有效地识别水平集上的点。为此，如图 6 所示，我们再次依靠从训练视点看到的高斯深度图。**
1. 我们首先从每个深度图中随机抽样像素。对于每个像素 $m$ ，我们对其视线进行采样，以在水平集上找到一个 3D 点。形式上，我们对 $n$ 点 $p+t_{i}v$ 进行采样，其中 $p$ 是深度图中像素 $m$ 重投影（reprojects）的三维点（从深度重建坐标?）， $v$ 是视线的方向， $t_{i}\in[-3\sigma_{g}(v),3\sigma_{g}(v)]$ 其中 $\sigma_{g}(v)$ 是三维高斯 $g$ 在摄像机方向上的标准偏差。区间 $[-3\sigma_g(v),3\sigma_g(v)]$ 是沿光线方向 $t$ 的一维高斯函数 99.7 置信度的置信区间。
2. 然后，我们根据公式 (1) 计算这些采样点的密度值 $d_{i}=d(p+t_{i}v)$ 。如果存在 $i,j$ ，使得 $d_{i}<\lambda<d_{j}$ ，那么在此范围内存在一个水平集点 （level set point）。如果存在，我们将使用线性插值计算系数 $t^*$ ，从而使 $p+t^*v$ 成为最靠近摄像机的水平集点，并验证 $d(p+t^{*}v)=\lambda$ 。我们还会计算 $\hat{p}$ 点处的曲面法线，我们自然会将其定义为密度 $\frac{\nabla d(\hat{p})}{\|\nabla d(\hat{p})\|_{2}}$ 的归一化分析梯度。 
3. 最后，我们应用泊松重建法，从水平集点及其法线重建曲面网格。

在实际操作中，我们会使用两种泊松重建来提取网格：一种用于前景点（foreground points），另一种用于背景点（background points）。我们将前景点定义为位于所有训练摄像机位姿的 bounding box 内的点，而将背景点定义为位于 bounding box 外的点。我们选择这样简单地区分前景和背景，是为了设计一种尽可能通用的方法。**不过，根据场景内容和要重建的主要对象，为前景点定义自定义边界框可以提高提取网格的质量和精度。**

## 4.3 将新的三维高斯绑定到网格上
提取出第一个网格后，我们可以通过将新的高斯绑定到网格三角形来完善网格，并使用高斯拼接光栅器共同细化高斯和网格。这样就可以使用流行的网格编辑工具编辑高斯拼接场景，同时利用高斯模型保持高质量的渲染效果。

给定初始网格后，我们在网格上实例化新的三维高斯。更确切地说，我们将一组 $n$ 薄（thin）的三维高斯关联到网格的每个三角形，并在三角形表面进行采样，如图 7 所示。**为此，我们稍微修改了原始三维高斯拼接模型的结构。**
在细化过程中，我们在相应的三角形中使用**预定义的重心坐标**明确计算网格顶点的高斯均值。
**此外，高斯模型只有 2 个可学习的缩放因子（scaling factors），而不是 3 个；只有 1 个可学习的二维旋转（2D rotation），用<mark style="background: #FF5582A6;">复数</mark>而不是四元数编码，以保持高斯模型平整并与网格三角形对齐**。
**与原始模型一样，我们也优化了每个高斯的不透明度值（opacity）和一组球谐，以编码在所有方向上发射的颜色。**

**在联合细化过程中，我们还会计算网格面上的法线一致性项，以进一步规范化曲面**。这个项不会影响 PSNR、SSIM 或 LPIPS 的性能。不过，它能使曲面更加平滑，从而在一定程度上提高视觉质量。
> [!NOTE] 复数细节
> 实际上，对于每个高斯，我们优化的是一个可学习的复数 $x+iy$ ，而不是一个四元数，用来编码三角形平面内的二维旋转。**在优化过程中，我们仍然需要计算一个明确的三维四元数，编码高斯在世界空间中的三维旋转，以便应用光栅化器**。要恢复完整的三维四元数，我们的步骤如下：对于任何三维高斯 $g$ ，我们首先计算编码其相应三角形旋转的矩阵 $R=[R^{(0)},R^{(1)},R^{(2)}]\in\mathbb{R}^{3\times3}$ ：我们选择矩阵的第一列 $R^{(0)}$ 作为三角形的法线，第二列 $R^{(1)}$  作为三角形的固定边。我们用叉积计算第三列 $R^{(2)}$  。然后，我们将学习到的二维复数应用于三角形的旋转，计算出编码高斯全三维旋转的矩阵 $R_g$ ，如下所示：
> $$
> R_{g}^{(0)}=R^{(0)},R_{g}^{(1)}=x^{\prime}R^{(1)}+y^{\prime}R^{(2)}
> $$
> $$
> R_{g}^{(2)}=-y^{\prime}R^{(1)}+x^{\prime}R^{(2)}
> $$
> 其中 $x'=\frac{x}{|x^2+y^2|},y'=\frac{y}{|x^2+y^2|}$
> 
> 由于我们学习到的复数表示的是相应三角形空间中的旋转，因此我们的表示法对网格编辑或动画具有很强的鲁棒性：**在推理过程中编辑底层网格时，无需更新所学的二维旋转，因为在旋转或移动三角形时，它们保持不变。**
> **相反，在缩放或变形网格时，三角形的大小可能会发生变化，这就需要调整约束曲面高斯的学习缩放因子**。例如，如果网格尺寸增加一倍，所有高斯缩放因子也应同样乘以 2。在我们的实现过程中，当编辑网格时，我们会实时修改约束曲面高斯的学习缩放因子，将其乘以 (a) 修改后三角形边的平均长度和 (b) 原始三角形边的平均长度之间的比值。

图 7 显示了细化前后的网格示例。图 1 和补充材料举例说明了通过编辑网格可以做些什么。
![[Pasted image 20240404213357.png]]
>图 7：网格和高斯的联合细化 （refinement）。
>左图：我们将高斯绑定到网格的三角形上。根据场景中三角形的数量，我们为每个三角形绑定不同数量的高斯，并预设重心坐标。
>右图：联合细化前后的网格。


# 5 实验
我们的所有模型均在单 GPU Nvidia Tesla V100 SXM2 32 Go 上进行了优化。
## 5.1 实验细节
**规范化（Regularization）**
对于所有场景，我们首先对高斯拼接进行 7000 次无正则化优化迭代，以便让 3D 高斯在没有任何额外约束的情况下进行自我定位。然后，我们对高斯的不透明度 $\alpha_g$ 进行了 2,000 次迭代，并增加了熵损失，以强制它们成为二元图像。
最后，我们剔除不透明度值低于 0.5 的高斯，并利用 4.1 小节中引入的正则化项进行 6000 次迭代，总共进行了 15000 次迭代。为了计算来自高斯 $g$ 的点的密度值，我们只对来自 $g$ 的 16 个最近高斯的高斯函数求和，并每迭代 500 次更新最近邻近列表。根据场景的不同，优化通常需要 15 到 45 分钟。

**网格提取（Mesh extraction）**
对于除表 2 所示消融实验之外的所有实验，我们都提取了 $\lambda=0.3$ 密度函数的 $\lambda$ 级水平集（$\lambda$ -level set）。我们执行深度为 10 的泊松重建，并使用**二次误差度量**进行网格简化，以降低网格的分辨率。根据场景的不同，网格提取一般需要 5 到 10 分钟。

**联合细化（Joint refinement）**
我们对网格和边界三维高斯进行联合细化，迭代次数为 2,000、7,000 或 15,000 次。根据迭代次数的不同，细化时间从几分钟到一小时不等。

## 5.2 实时渲染真实场景
为了评估我们的模型，我们沿用了最初的 3D 高斯拼接论文中的方法，并比较了我们的方法 SuGaR 在 3 个不同数据集的真实 3D 场景中细化后的几种变体的性能：Mip-NeRF360 、DeepBlending 和 Tanks&Temples 。我们称 R-SuGaR-NK 为细化过程中经过 N 次迭代优化的细化 SuGaR 模型。

按照文献[15]，我们选择了相同的两组场景，即来自 Tanks&Temples 的 2 个场景（卡车和火车）和来自 DeepBlending 的 2 个场景（游戏室和约翰逊博士）。然而，由于授权问题以及 Flowers 和 Treehill 场景的不可用性，我们仅在 Mip-NeRF360 的 7 个场景上对所有方法进行了评估，而不是全套的 9 个场景。 

我们计算了标准指标 PSNR、SSIM 和 LPIPS，以评估 SuGaR 使用我们提取的网格及其绑定的曲面高斯进行渲染的质量。请注意，[6, 39, 26] 也没有使用纯纹理网格渲染。我们与几种基线进行了比较，其中一些基线只关注新视图合成，其他基线则依赖于重建网格，就像我们的方法 SuGaR 一样。表 1 列出了 Mip-NeRF360 数据集的结果。在 Tanks&Temple 和 DeepBlending 数据集上的结果类似，请参见补充材料。
![[Pasted image 20240404221257.png]]
>表 1：在 Mip-NeRF360 数据集[2]上对渲染质量进行的定量评估。在恢复网格的方法中，SuGaR 的效果最好，与 NeRF 方法和vanilla三维高斯拼接法相比，SuGaR 仍然表现出色。

尽管在优化的第一阶段，SuGaR 专注于对齐三维高斯以重建高质量的网格，但它的性能明显优于目前使用网格进行新视图合成的方法，而且比一些只专注于渲染的著名模型（如 Instant-NGP 和 Plenoxels）性能更好。由于 SuGaR 提取网格的速度明显快于其他方法，因此其性能非常突出。

此外，在一些用于评估的场景上，SuGaR 甚至在渲染质量方面达到了与最先进模型相近的性能。取得这样的成绩主要有两个原因。首先，第一阶段优化后提取的网格是开始细化阶段高斯定位的绝佳初始化。然后，在细化过程中，高斯受限保留在表面上，这大大提高了渲染质量，因为它们起到了高效纹理工具的作用，有助于重建提取网格中缺失的非常精细的细节。

## 5.3 网格提取
为了证明我们的网格提取方法能够重构出适合视图合成的高质量网格，我们对不同的网格提取算法进行了比较。特别是，除了网格提取过程外，我们按照与标准模型完全相同的流程对 SuGaR 的几种变体进行了优化：我们可以使用非常精细的 marching cubes 算法[21]提取网格，也可以使用泊松重建[14]，将三维高斯中心作为曲面点云，还可以将我们的网格提取方法应用于不同的水平集。表 2 提供了定量结果，显示了我们的方法在三维高斯网格划分方面的明显优势。图 3 还说明了 marching cubes算法在这种情况下的失败。

![[Pasted image 20240404221437.png|500]]
>表 2：在 Mip-NeRF360 数据集[2]上应用正则化项后，不同网格提取方法的消融情况。对于 "泊松（中心）"，我们使用泊松重建[14]，将三维高斯的中心作为面点。为了进行公平比较，我们对这些方法进行了校准，以强制所有提取的网格具有约 1,000,000 个顶点。

![[Pasted image 20240404221448.png|500]]
>表 3：在 Mip-NeRF360 数据集[2]上，表面对齐三维高斯与优化传统 UV 纹理的比较。为了进行公平比较，我们在使用 SuGaR 渲染图像时只使用了漫反射球面谐波分量。使用与网格绑定的三维高斯大大提高了渲染质量，尽管它比 UV 纹理包含的参数更少。

### 5.4 网格渲染消融
表 3 提供了更多结果，量化了各种参数对渲染性能的影响。特别是，我们评估了网格提取的分辨率（即三角形数量）如何改变渲染质量。为了进行公平比较，我们在减少三角形数量时增加了每个三角形的表面对齐高斯数量。结果表明，增加顶点数量可以提高曲面高斯的渲染质量，但三角形数量较少的网格也能达到最先进的效果。
然后，我们说明了使用在表面上对齐的高斯作为渲染网格的纹理工具的好处。为此，我们还使用可微分网格渲染和传统的三角形光栅化技术优化了网格上的传统 UV 纹理。尽管使用曲面对齐高斯进行渲染的性能更好，但使用传统 UV 纹理对网格进行渲染的结果仍然令人满意，这进一步说明了我们提取的网格的质量。补充材料中提供了定性比较。

# 6 结论

我们提出了一种非常快速的算法，通过高斯拼接法获得场景的精确三维三角形网格。此外，通过将网格划分与高斯拼接相结合，我们可以对捕捉到的场景进行直观操作和逼真渲染，为创作者提供了新的可能性。

