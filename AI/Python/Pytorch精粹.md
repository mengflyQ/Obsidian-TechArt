---
title: Pytorch精粹
uid: "202311111641"
create_time: 2023-11-11 16:39
reference: 
banner: "[[Pasted image 20231111164335.png]]"
banner_lock: true
---

# 1 数据操作
## 01 张量
```python
import torch
```

- 深度学习存储和操作数据的主要接口是张量（n维数组）。它提供了各种功能，包括基本数学运算、广播、索引、切片、内存节省和转换其他 Python 对象。

- **张量（tensor）** 表示一个由数值组成的数组，这个数组可能有多个维度。 
    - 具有一个轴的张量对应数学上的_向量_（vector）； 
    - 具有两个轴的张量对应数学上的_矩阵_（matrix）；
    - 具有两个轴以上的张量没有特殊的数学名称。
    - 张量中的每个值都称为张量的 _元素_（element）

- 使用 `arange` 创建一个**行向量** `x`。这个行向量包含以0开始的前12个整数，范围为 $[0,12)$，它们默认创建为整数。也可指定创建类型为浮点数。
```python
x = torch.arange(12)
// tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
```

- 张量（沿每个轴的长度）的形状：
```python
x.shape
//torch.Size([12])
```

- 张量的大小（size）：即张量中元素的总数，即形状的所有元素乘积
```python
X = x.reshape(3, 4)
//tensor([[ 0,  1,  2,  3],
//        [ 4,  5,  6,  7],
 //       [ 8,  9, 10, 11]])
```

不需要通过手动指定每个维度来改变形状。也就是说，如果我们的目标形状是（高度,宽度），那么在知道宽度后，高度会被自动计算得出，不必我们自己做除法。在上面的例子中，为了获得一个3行的矩阵，我们手动指定了它有3行和4列。幸运的是，我们可以通过 `-1` 来调用此自动计算出维度的功能。即我们可以用 `x.reshape(-1,4)` 或 `x.reshape(3,-1)` 来取代 `x.reshape(3,4)`。 

- 创建一个形状为（2,3,4）的张量，指定初始值
```python
torch.zeros((2, 3, 4))

tensor([[[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]],

        [[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]])
```

```python
torch.ones((2, 3, 4))

tensor([[[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]]])
```

- **通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。** 例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。以下代码创建一个形状为（3,4）的张量。**其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样。**

```python
torch.randn(3, 4)

tensor([[-0.0135,  0.0665,  0.0912,  0.3212],
        [ 1.4653,  0.1843, -1.6995, -0.3036],
        [ 1.7646,  1.0450,  0.2457, -0.7732]])
```

- **通过提供包含数值的 Python 列表（或嵌套列表），来为所需张量中的每个元素赋予确定值**。在这里，最外层的列表对应于轴0，内层的列表对应于轴1。
```python
torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])

tensor([[2, 1, 4, 3],
        [1, 2, 3, 4],
        [4, 3, 2, 1]])
```

## 02 运算符
对于**任意具有<mark style="background: #FF5582A6;">相同形状</mark>的张量，常见的标准算术运算符（`+`、`-`、`*`、`/` 和 `**`）都可以被升级为**按元素运算**。

在下面的例子中，我们使用逗号来表示一个具有5个元素的元组，其中每个元素都是按元素操作的结果。
```python
x = torch.tensor([1.0, 2, 4, 8])
y = torch.tensor([2, 2, 2, 2])
x + y
x - y
x * y
x / y
x ** y  # **运算符是求幂运算
torch.exp(x) # 按元素求幂
```

可以把**多个张量连结**（concatenate）在一起，把它们端对端地叠起来形成一个更大的张量。我们只需要提供张量列表，并给出沿哪个轴连结。 
下面的例子分别演示了当我们沿行（轴-0，形状的第一个元素） 和按列（轴-1，形状的第二个元素）连结两个矩阵时，会发生什么情况。我们可以看到，第一个输出张量的轴-0长度（6）是两个输入张量轴-0长度的总和（3+3）；第二个输出张量的轴-1长度（8）是两个输入张量轴-1长度的总和（4+4）。
```c++
X = torch.arange(12, dtype=torch.float32).reshape((3,4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)

(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [ 2.,  1.,  4.,  3.],
         [ 1.,  2.,  3.,  4.],
         [ 4.,  3.,  2.,  1.]]),
 tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],
         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],
         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))
```

**逻辑运算符**也是按元素运算
```c++
X == Y

tensor([[False,  True, False,  True],
        [False, False, False, False],
        [False, False, False, False]])
```

对张量中的所有元素进行**求和**，会产生一个单元素张量。
```c++
X.sum()

tensor(66.)
```
## 03 广播
在上面的部分是在相同形状的两个张量上执行按元素操作。在某些情况下，**即使<mark style="background: #FF5582A6;">形状不同</mark>，我们仍然可以通过调用广播机制（broadcasting mechanism）来执行按元素操作**。

这种机制的工作方式如下：
1. 通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；
2. 对生成的数组执行按元素操作。

在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：
```c++
a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))

(tensor([[0],
         [1],
         [2]]),
 tensor([[0, 1]]))
```

由于 `a` 和 `b` 分别是 $3×1$ 和 $1×2$ 矩阵，如果让它们相加，它们的形状不匹配。我们将两个矩阵**广播**为一个更大的 $3×2$ 矩阵，如下所示：矩阵 `a` 将复制列，矩阵 `b` 将复制行，然后再按元素相加。  

```c++
a + b

tensor([[0, 1],
        [1, 2],
        [2, 3]])
```

## 04 索引和切片
就像在任何其他 Python 数组中一样，**张量中的元素可以通过索引访问**。与任何 Python 数组一样：第一个元素的索引是0，最后一个元素索引是-1；可以指定范围以包含第一个元素和最后一个之前的元素。
[[Python基础#切片语法]]

如下所示，我们可以用 `[-1]` 选择最后一个元素，可以用 `[1:3]` 选择第二个和第三个元素：
```c++
X[-1], X[1:3]
```

除读取外，我们还可以通过指定索引来将元素写入矩阵。

如果我们想为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。例如，`[0:2, :]` 访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。
```c++
X[0:2, :] = 12


X=tensor([[12., 12., 12., 12.],
        [12., 12., 12., 12.],
        [ 8.,  9., 10., 11.]])
```

## 05 节省内存
运行一些操作可能会导致为新结果分配内存。例如，如果我们用 `Y = X + Y`，我们将取消引用 `Y` 指向的张量，而是指向新分配的内存处的张量。

这可能是不可取的，原因有两个：
1. 首先，我们不想总是不必要地分配内存。在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。通常情况下，我们希望原地执行这些更新；
2. 如果我们不原地更新，其他引用仍然会指向旧的内存位置，这样我们的某些代码可能会无意中引用旧的参数。

幸运的是，**执行原地操作**非常简单。我们可以**使用切片表示法将操作的结果分配给先前分配的数组，例如 `Y[:] = <expression>`**。为了说明这一点，我们首先创建一个新的矩阵 `Z`，其形状与另一个 `Y` 相同，使用 `zeros_like` 来分配一个全0的块。
```python
Z = torch.zeros_like(Y)
print('id(Z):', id(Z)) #Python的id()函数返回内存中引用对象的确切地址。
Z[:] = X + Y
print('id(Z):', id(Z))

#id(Z): 140327634811696
#id(Z): 140327634811696
```

如果在后续计算中没有重复使用`X`， 我们也可以使用`X[:] = X + Y`或`X += Y`来减少操作的内存开销。

```python
before = id(X)
X += Y
id(X) == before
#True
```

## 06 转换为其他 Python 对象
将深度学习框架定义的张量转换为 NumPy 张量（`ndarray`）很容易，反之也同样容易。 torch 张量和 numpy 数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。
```python
A = X.numpy()
B = torch.tensor(A)
type(A), type(B)

# (numpy.ndarray, torch.Tensor) 
```

要将大小为1的张量转换为 Python 标量，我们可以调用 `item` 函数或 Python 的内置函数进行类型转换。

```python
a = torch.tensor([3.5])
a, a.item(), float(a), int(a)
#(tensor([3.5000]), 3.5, 3.5, 3)
```

# 2 数据预处理
在 Python 中常用的数据分析工具中，我们通常使用 `pandas` 软件包进行数据预处理。像庞大的 Python 生态系统中的许多其他扩展包一样，`pandas` 可以与张量兼容

## 01 读取数据集
创建一个数据集合存入CSV
```c++
import os

os.makedirs(os.path.join('..', 'data'), exist_ok=True)
data_file = os.path.join('..', 'data', 'house_tiny.csv')
with open(data_file, 'w') as f:
    f.write('NumRooms,Alley,Price\n')  # 列名
    f.write('NA,Pave,127500\n')  # 每行表示一个数据样本
    f.write('2,NA,106000\n')
    f.write('4,NA,178100\n')
    f.write('NA,NA,140000\n')
```

![[Pasted image 20231111173516.png|350]]
调用 `read_csv()` 函数即可读取改 CSV 文件
```python
import pandas as pd

data = pd.read_csv(data_file)
print(data)

#输出,最左边一排是自动生成的序号，不是数据
   NumRooms Alley   Price
0       NaN  Pave  127500
1       2.0   NaN  106000
2       4.0   NaN  178100
3       NaN   NaN  140000
```

## 02 处理缺失值
注意，“`NaN`”项代表缺失值。为了处理缺失的数据，典型的方法包括**插值法**和**删除法**，其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。**在这里，我们将考虑插值法。**

通过位置索引 `iloc`，我们将 `data`（上节中的 CSV 数据，5 行 3 列） 分成 `inputs` 和 `outputs`，其中前者为 `data` 的前两列，而后者为 `data` 的最后一列。
```python
inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]
#此时input为
   NumRooms Alley
0       NaN  Pave
1       2.0   NaN
2       4.0   NaN
3       NaN   NaN

#output为
0    127500.0
1    106000.0
2    178100.0
3    140000.0
4         NaN
Name: Price, dtype: float64
```

对于 `inputs` 中缺少的数值，我们用同一列的均值替换“NaN”项。

```python
inputs = inputs.fillna(inputs.mean())
print(inputs)

#输出
   NumRooms Alley
0       3.0  Pave
1       2.0   NaN
2       4.0   NaN
3       3.0   NaN
```

对于 `inputs` 中的类别值或离散值，我们将“NaN”视为一个类别。由于“Alley”列只接受两种类型的类别值“Pave”和“NaN”， `pandas` 可以自动将此列转换为两列“Alley_Pave”和“Alley_nan”。“Alley”列为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0。缺少“Alley”列的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1。 
```c++
inputs = pd.get_dummies(inputs, dummy_na=True)
print(inputs)
###
   NumRooms  Alley_Pave  Alley_nan
0       3.0           1          0
1       2.0           0          1
2       4.0           0          1
3       3.0           0          1
```

## 03 转换为张量格式
现在 `inputs` 和 `outputs` 中的所有条目都是数值类型，它们可以转换为张量格式, 使用 `to_numpy`。当数据采用张量格式后，可以通过张量函数来进一步操作。  
```python
import torch

X = torch.tensor(inputs.to_numpy(dtype=float))
y = torch.tensor(outputs.to_numpy(dtype=float))
X, y

###
(tensor([[3., 1., 0.],
         [2., 0., 1.],
         [4., 0., 1.],
         [3., 0., 1.]], dtype=torch.float64),
 tensor([127500., 106000., 178100., 140000.], dtype=torch.float64))
```

# 3 线性代数
## 标量
标量由只有一个元素的张量表示
```python
x = torch.tensor(3.0)
y = torch.tensor(2.0)

x + y, x * y, x / y, x**y

# (tensor(5.), tensor(6.), tensor(1.5000), tensor(9.))
```
## 向量

> [!NOTE] 规定
> 列向量是向量的默认方向。在数学中，向量可以写为：$\mathbf{x}=\begin{bmatrix}x_1\\x_2\\\vdots\\x_n\end{bmatrix}$

向量可以被视为标量值组成的列表。人们通过一维张量表示向量。一般来说，张量可以具有任意长度，取决于机器的内存限制。

```python
x = torch.arange(4) 
# tensor([0, 1, 2, 3])

#使用下标引用向量的任意元素
x[3] 
# tensor(3)
```
## 长度、维度和形状
