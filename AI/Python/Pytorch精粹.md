---
title: Pytorch精粹
uid: "202311111641"
create_time: 2023-11-11 16:39
reference: 
banner: "[[Pasted image 20231111164335.png]]"
banner_lock: true
---

# 1 数据操作
## 01 张量
```python
import torch
```

- 深度学习存储和操作数据的主要接口是张量（n维数组）。它提供了各种功能，包括基本数学运算、广播、索引、切片、内存节省和转换其他 Python 对象。

- **张量（tensor）** 表示一个由数值组成的数组，这个数组可能有多个维度。 
    - 具有一个轴的张量对应数学上的_向量_（vector）； 
    - 具有两个轴的张量对应数学上的_矩阵_（matrix）；
    - 具有两个轴以上的张量没有特殊的数学名称。
    - 张量中的每个值都称为张量的 _元素_（element）

- 使用 `arange` 创建一个**行向量** `x`。这个行向量包含以0开始的前12个整数，范围为 $[0,12)$，它们默认创建为整数。也可指定创建类型为浮点数。
```python
x = torch.arange(12)
// tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
```

- 张量（沿每个轴的长度）的形状：
```python
x.shape
//torch.Size([12])
```

- 张量的大小（size）：即张量中元素的总数，即形状的所有元素乘积
```python
X = x.reshape(3, 4)
//tensor([[ 0,  1,  2,  3],
//        [ 4,  5,  6,  7],
 //       [ 8,  9, 10, 11]])
```

不需要通过手动指定每个维度来改变形状。也就是说，如果我们的目标形状是（高度,宽度），那么在知道宽度后，高度会被自动计算得出，不必我们自己做除法。在上面的例子中，为了获得一个3行的矩阵，我们手动指定了它有3行和4列。幸运的是，我们可以通过 `-1` 来调用此自动计算出维度的功能。即我们可以用 `x.reshape(-1,4)` 或 `x.reshape(3,-1)` 来取代 `x.reshape(3,4)`。 

- 创建一个形状为（2,3,4）的张量，指定初始值
```python
torch.zeros((2, 3, 4))

tensor([[[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]],

        [[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]])
```

```python
torch.ones((2, 3, 4))

tensor([[[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]]])
```

- **通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。** 例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。以下代码创建一个形状为（3,4）的张量。**其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样。**

```python
torch.randn(3, 4) #torch.randn函数用于创建一个具有随机值的张量

tensor([[-0.0135,  0.0665,  0.0912,  0.3212],
        [ 1.4653,  0.1843, -1.6995, -0.3036],
        [ 1.7646,  1.0450,  0.2457, -0.7732]])
```

- **通过提供包含数值的 Python 列表（或嵌套列表），来为所需张量中的每个元素赋予确定值**。在这里，最外层的列表对应于轴0，内层的列表对应于轴1。
```python
torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])

tensor([[2, 1, 4, 3],
        [1, 2, 3, 4],
        [4, 3, 2, 1]])
```

## 02 运算符
对于**任意具有<mark style="background: #FF5582A6;">相同形状</mark>的张量，常见的标准算术运算符（`+`、`-`、`*`、`/` 和 `**`）都可以被升级为**按元素运算**。

在下面的例子中，我们使用逗号来表示一个具有5个元素的元组，其中每个元素都是按元素操作的结果。
```python
x = torch.tensor([1.0, 2, 4, 8])
y = torch.tensor([2, 2, 2, 2])
x + y
x - y
x * y
x / y
x ** y  # **运算符是求幂运算
torch.exp(x) # 按元素求幂
```

可以把**多个张量连结**（concatenate）在一起，把它们端对端地叠起来形成一个更大的张量。我们只需要提供张量列表，并给出沿哪个轴连结。 
下面的例子分别演示了当我们沿行（轴-0，形状的第一个元素） 和按列（轴-1，形状的第二个元素）连结两个矩阵时，会发生什么情况。我们可以看到，第一个输出张量的轴-0长度（6）是两个输入张量轴-0长度的总和（3+3）；第二个输出张量的轴-1长度（8）是两个输入张量轴-1长度的总和（4+4）。
```c++
X = torch.arange(12, dtype=torch.float32).reshape((3,4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)

(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [ 2.,  1.,  4.,  3.],
         [ 1.,  2.,  3.,  4.],
         [ 4.,  3.,  2.,  1.]]),
 tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],
         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],
         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))
```

**逻辑运算符**也是按元素运算
```c++
X == Y

tensor([[False,  True, False,  True],
        [False, False, False, False],
        [False, False, False, False]])
```

对张量中的所有元素进行**求和**，会产生一个单元素张量。
```c++
X.sum()

tensor(66.)
```
## 03 广播
在上面的部分是在相同形状的两个张量上执行按元素操作。在某些情况下，**即使<mark style="background: #FF5582A6;">形状不同</mark>，我们仍然可以通过调用广播机制（broadcasting mechanism）来执行按元素操作**。

**这种机制的工作方式如下：**
1. 通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；
2. 对生成的数组执行按元素操作。

在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：
```c++
a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))

(tensor([[0],
         [1],
         [2]]),

tensor([[0, 1]]))
```

由于 `a` 和 `b` 分别是 $3×1$ 和 $1×2$ 矩阵，如果让它们相加，它们的形状不匹配。我们将两个矩阵**广播**为一个更大的 $3×2$ 矩阵，如下所示：矩阵 `a` 将复制列，矩阵 `b` 将复制行，然后再按元素相加。  

```c++
a + b

tensor([[0, 1],
        [1, 2],
        [2, 3]])
```

## 04 索引和切片
就像在任何其他 Python 数组中一样，**张量中的元素可以通过索引访问**。与任何 Python 数组一样：第一个元素的索引是0，最后一个元素索引是-1；可以指定范围以包含第一个元素和最后一个之前的元素。
[[Python基础#切片语法]]

如下所示，我们可以用 `[-1]` 选择最后一个元素，可以用 `[1:3]` 选择第二个和第三个元素：
```c++
X[-1], X[1:3]
```

除读取外，我们还可以通过指定索引来将元素写入矩阵。

如果我们想为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。例如，`[0:2, :]` 访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。
```c++
X[0:2, :] = 12


X=tensor([[12., 12., 12., 12.],
        [12., 12., 12., 12.],
        [ 8.,  9., 10., 11.]])
```

## 05 节省内存
运行一些操作可能会导致为新结果分配内存。例如，如果我们用 `Y = X + Y`，我们将取消引用 `Y` 指向的张量，而是指向新分配的内存处的张量。

这可能是不可取的，原因有两个：
1. 首先，我们不想总是不必要地分配内存。在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。通常情况下，我们希望原地执行这些更新；
2. 如果我们不原地更新，其他引用仍然会指向旧的内存位置，这样我们的某些代码可能会无意中引用旧的参数。

幸运的是，**执行原地操作**非常简单。我们可以**使用切片表示法将操作的结果分配给先前分配的数组，例如 `Y[:] = <expression>`**。为了说明这一点，我们首先创建一个新的矩阵 `Z`，其形状与另一个 `Y` 相同，使用 `zeros_like` 来分配一个全0的块。
```python
Z = torch.zeros_like(Y)
print('id(Z):', id(Z)) #Python的id()函数返回内存中引用对象的确切地址。
Z[:] = X + Y
print('id(Z):', id(Z))

#id(Z): 140327634811696
#id(Z): 140327634811696
```

如果在后续计算中没有重复使用`X`， 我们也可以使用`X[:] = X + Y`或`X += Y`来减少操作的内存开销。

```python
before = id(X)
X += Y
id(X) == before
#True
```

## 06 转换为其他 Python 对象
将深度学习框架定义的张量转换为 NumPy 张量（`ndarray`）很容易，反之也同样容易。 torch 张量和 numpy 数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。
```python
A = X.numpy()
B = torch.tensor(A)
type(A), type(B)

# (numpy.ndarray, torch.Tensor) 
```

要将大小为1的张量转换为 Python 标量，我们可以调用 `item` 函数或 Python 的内置函数进行类型转换。

```python
a = torch.tensor([3.5])
a, a.item(), float(a), int(a)
#(tensor([3.5000]), 3.5, 3.5, 3)
```

# 2 数据预处理
在 Python 中常用的数据分析工具中，我们通常使用 `pandas` 软件包进行数据预处理。像庞大的 Python 生态系统中的许多其他扩展包一样，`pandas` 可以与张量兼容

## 01 读取数据集
创建一个数据集合存入CSV
```c++
import os

os.makedirs(os.path.join('..', 'data'), exist_ok=True)
data_file = os.path.join('..', 'data', 'house_tiny.csv')
with open(data_file, 'w') as f:
    f.write('NumRooms,Alley,Price\n')  # 列名
    f.write('NA,Pave,127500\n')  # 每行表示一个数据样本
    f.write('2,NA,106000\n')
    f.write('4,NA,178100\n')
    f.write('NA,NA,140000\n')
```

![[Pasted image 20231111173516.png|350]]
调用 `read_csv()` 函数即可读取改 CSV 文件
```python
import pandas as pd

data = pd.read_csv(data_file)
print(data)

#输出,最左边一排是自动生成的序号，不是数据
   NumRooms Alley   Price
0       NaN  Pave  127500
1       2.0   NaN  106000
2       4.0   NaN  178100
3       NaN   NaN  140000
```

## 02 处理缺失值
注意，“`NaN`”项代表缺失值。为了处理缺失的数据，典型的方法包括**插值法**和**删除法**，其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。**在这里，我们将考虑插值法。**

通过位置索引 `iloc`，我们将 `data`（上节中的 CSV 数据，5 行 3 列） 分成 `inputs` 和 `outputs`，其中前者为 `data` 的前两列，而后者为 `data` 的最后一列。
```python
inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]
#此时input为
   NumRooms Alley
0       NaN  Pave
1       2.0   NaN
2       4.0   NaN
3       NaN   NaN

#output为
0    127500.0
1    106000.0
2    178100.0
3    140000.0
4         NaN
Name: Price, dtype: float64
```

对于 `inputs` 中缺少的数值，我们用同一列的均值替换“NaN”项。

```python
inputs = inputs.fillna(inputs.mean())
print(inputs)

#输出
   NumRooms Alley
0       3.0  Pave
1       2.0   NaN
2       4.0   NaN
3       3.0   NaN
```

对于 `inputs` 中的类别值或离散值，我们将“NaN”视为一个类别。由于“Alley”列只接受两种类型的类别值“Pave”和“NaN”， `pandas` 可以自动将此列转换为两列“Alley_Pave”和“Alley_nan”。“Alley”列为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0。缺少“Alley”列的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1。 
```c++
inputs = pd.get_dummies(inputs, dummy_na=True)
print(inputs)
###
   NumRooms  Alley_Pave  Alley_nan
0       3.0           1          0
1       2.0           0          1
2       4.0           0          1
3       3.0           0          1
```

## 03 转换为张量格式
现在 `inputs` 和 `outputs` 中的所有条目都是数值类型，它们可以转换为张量格式, 使用 `to_numpy`。当数据采用张量格式后，可以通过张量函数来进一步操作。  
```python
import torch

X = torch.tensor(inputs.to_numpy(dtype=float))
y = torch.tensor(outputs.to_numpy(dtype=float))
X, y

###
(tensor([[3., 1., 0.],
         [2., 0., 1.],
         [4., 0., 1.],
         [3., 0., 1.]], dtype=torch.float64),
 tensor([127500., 106000., 178100., 140000.], dtype=torch.float64))
```

# 3 线性代数

> [!info] 约定
> - 列向量是向量的默认方向。在数学中，向量可以写为：$\mathbf{x}=\begin{bmatrix}x_1\\x_2\\\vdots\\x_n\end{bmatrix}$
> - 尽管单个向量的默认方向是列向量，但在表示表格数据集的矩阵中，将每个数据样本作为矩阵中的行向量更为常见。这种约定将支持常见的深度学习实践。例如，沿着张量的最外轴，我们可以访问或遍历小批量的数据样本。

## 01 标量
标量由只有一个元素的张量表示
```python
x = torch.tensor(3.0)
y = torch.tensor(2.0)

x + y, x * y, x / y, x**y

# (tensor(5.), tensor(6.), tensor(1.5000), tensor(9.))
```
## 02 向量

向量可以被视为标量值组成的列表。人们通过一维张量表示向量。一般来说，张量可以具有任意长度，取决于机器的内存限制。

```python
x = torch.arange(4) 
# tensor([0, 1, 2, 3])

#使用下标引用向量的任意元素
x[3] 
# tensor(3)
```
### 点积
```c++
x = tensor([0., 1., 2., 3.])
y = tensor([1., 1., 1., 1.])

torch.dot(x, y) = tensor(6.))
```

注意，我们也可以通过执行按元素乘法，然后进行求和来表示两个向量的点积：
```c++
torch.sum(x * y)
```

![[Pasted image 20231111205452.png]]

## 03 长度、维度和形状

> [!NOTE] 维度
> 维度（dimension）这个词在不同上下文时往往会有不同的含义，这经常会使人感到困惑。为了清楚起见，我们在此明确一下： 
> - 向量或轴的维度被用来表示向量或轴的长度，即向量或轴的元素数量。
>  - 张量的维度用来表示张量具有的轴数。在这个意义上，张量的某个轴的维数就是这个轴的长度。

- **向量的长度**通常称为向量的**维度（dimension）**。
    - 与普通的 Python 数组一样，我们可以通过调用 Python 的内置 `len()` 函数来访问张量的长度。
- **形状（shape）是一个元素组**，列出了**张量沿每个轴的长度（维数）**。对于只有一个轴的张量，形状只有一个元素。
    - 当用张量表示一个向量（只有一个轴）时，我们也可以通过 `.shape` 属性访问向量的长度。
## 04 矩阵
当调用函数来实例化张量时， 我们可以通过指定两个分量 $m$ 和 $n$ 来创建一个形状为 $m×n$ 的矩阵。
```python
A = np.arange(20).reshape(5, 4)
###
array([[ 0.,  1.,  2.,  3.],
       [ 4.,  5.,  6.,  7.],
       [ 8.,  9., 10., 11.],
       [12., 13., 14., 15.],
       [16., 17., 18., 19.]])
```

- **矩阵的转置**：`A.T`

- **矩阵-向量积**
在代码中使用张量表示矩阵-向量积，我们使用 `mv` 函数。当我们为矩阵 `A` 和向量 `x` 调用 `torch.mv(A, x)` 时，会执行矩阵-向量积。注意，`A` 的列维数（沿轴 1 的长度）必须与 `x` 的维数（其长度）相同。 
```python
torch.mv(A, x)
```

- **矩阵-矩阵积**
```c++
torch.mm(A, B)
```

## 05 张量

张量（本小节中的“张量”指代数对象）是描述具有任意数量轴的 $n$ 维数组的通用方法。例如，向量是一阶张量，矩阵是二阶张量。

```c++
X = torch.arange(24).reshape(2, 3, 4)
###
tensor([[[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]],

        [[12, 13, 14, 15],
         [16, 17, 18, 19],
         [20, 21, 22, 23]]])
```

### 张量算法
给定具有相同形状的任意两个张量，任何按元素二元运算的结果都将是相同形状的张量。例如，将两个相同形状的矩阵相加，会在这两个矩阵上执行元素加法。
```python
A = torch.arange(20, dtype=torch.float32).reshape(5, 4)
B = A.clone()  # 通过分配新内存，将A的一个副本分配给B
### 
A 
(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [12., 13., 14., 15.],
         [16., 17., 18., 19.]]),
###  
A + B 
tensor([[ 0.,  2.,  4.,  6.],
         [ 8., 10., 12., 14.],
         [16., 18., 20., 22.],
         [24., 26., 28., 30.],
         [32., 34., 36., 38.]]))

```

两个矩阵的按元素乘法称为阿达马积（Hadamard product）：
$$\mathbf{A}\odot\mathbf{B}=\begin{bmatrix}a_{11}b_{11}&a_{12}b_{12}&\ldots&a_{1n}b_{1n}\\a_{21}b_{21}&a_{22}b_{22}&\ldots&a_{2n}b_{2n}\\\vdots&\vdots&\ddots&\vdots\\a_{m1}b_{m1}&a_{m2}b_{m2}&\ldots&a_{mn}b_{mn}\end{bmatrix}$$
```c++
A * B = tensor([[  0.,   1.,   4.,   9.],
        [ 16.,  25.,  36.,  49.],
        [ 64.,  81., 100., 121.],
        [144., 169., 196., 225.],
        [256., 289., 324., 361.]])
```

将张量乘以或加上一个标量不会改变张量的形状，其中张量的每个元素都将与标量相加或相乘。
```python
a = 2
X = torch.arange(24).reshape(2, 3, 4)
###
a + X
(tensor([[[ 2,  3,  4,  5],
          [ 6,  7,  8,  9],
          [10, 11, 12, 13]],

         [[14, 15, 16, 17],
          [18, 19, 20, 21],
          [22, 23, 24, 25]]]),

### 
(a * X).shape
 torch.Size([2, 3, 4]))
```

### 降维
#### 求和
计算张量元素的总和, 张量可以为任意形状
默认情况下，调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量。

```python
x = torch.arange(4, dtype=torch.float32)

###
x
(tensor([0., 1., 2., 3.])
###
x.sum()
tensor(6.))
```

**我们还可以指定张量沿哪一个轴来通过求和降低维度**。以矩阵为例，为了通过求和所有行的元素来降维（轴0，即 x 轴），可以在调用函数时指定 `axis=0`。**由于输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失。**
```python
A  = (tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [12., 13., 14., 15.],
         [16., 17., 18., 19.]]),
         
###
A_sum_axis0 = A.sum(axis=0) #沿0轴（x轴）求和,列相加
(tensor([40., 45., 50., 55.])

 ###
A_sum_axis0, A_sum_axis0.shape
torch.Size([4]))
```

同理，指定 `axis=1` 将通过汇总所有列的元素降维（轴1，即 y 轴）。因此，输入轴1的维数在输出形状中消失。
```python
###
A_sum_axis1 = A.sum(axis=1)
(tensor([ 6.,
          22.,
          38.,
          54.,
          70.])
 
###
A_sum_axis1, A_sum_axis1.shape
torch.Size([5]))
```

沿着行和列对矩阵求和，等价于对矩阵的所有元素进行求和
```python
A.sum(axis=[0, 1])  # 结果和A.sum()相同
###
tensor(190.)
```

#### 求平均
 - 调用 `mean()` 函数来计算任意形状张量的平均值。
- 通过将总和除以元素总数来计算平均值。
```python
A.mean()
#等价
A.sum() / A.numel()
```

计算平均值的函数也可以沿指定轴降低张量的维度。
```c++
A.mean(axis=0)

A.sum(axis=0) / A.shape[0]
```

### 非降维求和
```c++
A  = (tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [12., 13., 14., 15.],
         [16., 17., 18., 19.]]),
```

有时在调用函数来计算总和或均值时保持轴数不变会很有用。

```python
sum_A = A.sum(axis=1, keepdims=True)
###
tensor([[ 6.],
        [22.],
        [38.],
        [54.],
        [70.]])
```

例如，由于 `sum_A` 在对每行进行求和后仍保持两个轴，我们可以通过广播将 `A` 除以 `sum_A`。 
```python
A / sum_A

###
tensor([[0.0000, 0.1667, 0.3333, 0.5000],
        [0.1818, 0.2273, 0.2727, 0.3182],
        [0.2105, 0.2368, 0.2632, 0.2895],
        [0.2222, 0.2407, 0.2593, 0.2778],
        [0.2286, 0.2429, 0.2571, 0.2714]])
```

如果我们想沿某个轴计算 `A` 元素的累积总和，比如 `axis=0`（按行计算），可以调用 `cumsum` 函数。此函数不会沿任何轴降低输入张量的维度。 
```python
A.cumsum(axis=0)

###
tensor([[ 0.,  1.,  2.,  3.],
        [ 4.,  6.,  8., 10.], #原来的第一行+第二行
        [12., 15., 18., 21.], #第第一行+第二行+第三行
        [24., 28., 32., 36.], #以此类推...
        [40., 45., 50., 55.]])
```

## 06 范数
**线性代数中最有用的一些运算符是范数（norm）。非正式地说，向量的范数是表示一个向量有多大。** 这里考虑的大小（size）概念不涉及维度，而是分量的大小。

在线性代数中，向量范数是将向量映射到标量的函数 $f$ （即求大小）。

给定任意向量 $x$，向量范数要满足一些属性：
- 性质一：如果我们按常数因子 $\alpha$ 缩放向量的所有元素，其范数也会按相同常数因子的绝对值缩放：$$
f(\alpha\mathbf{x})=|\alpha|f(\mathbf{x})
$$
- 性质二：是熟悉的三角不等式：$$
f(\mathbf{x}+\mathbf{y})\leq f(\mathbf{x})+f(\mathbf{y})
$$
- 性质三：范数必须是非负的，这是有道理的。因为在大多数情况下，任何东西的最小的_大小_是0。 
$$
f(\mathbf{x})\geq0
$$ 
- 性质四：要求范数最小为 0，当且仅当向量全由 0 组成。$$
\forall i,[\mathbf{x}]_i=0\Leftrightarrow f(\mathbf{x})=0.
$$
范数听起来很像距离的度量。欧几里得距离和毕达哥拉斯定理中的非负性概念和三角不等式可能会给出一些启发。**事实上，欧几里得距离是一个 $L_2$ 范数： 假设 $n$ 维向量 $x$ 中的元素是 $x_1,\ldots,x_n$，其 $L_2$ 范数是向量元素平方和的平方根：**
$$\|\mathbf{x}\|_2=\sqrt{\sum_{i=1}^nx_i^2},$$

其中，在 $L_2$ 范数中常常省略下标 $2$，也就是说 $‖x‖$ 等同于 $‖x‖_2$。在代码中，我们可以按如下方式计算向量的 $L_2$ 范数。
```python
u = torch.tensor([3.0, -4.0])
torch.norm(u)

###
tensor(5.)
```

深度学习中更经常地使用 $L_2$ 范数的平方，也会经常遇到 **$L_1$ 范数，它表示为向量元素的绝对值之和：**
```python
torch.abs(u).sum()
###
tensor(7.)
```

这些范数都是 $L_p$ 范数的特例：$\displaystyle\|\mathbf{x}\|_p=\left(\sum_{i=1}^n|x_i|^p\right)^{1/p}$

类似于向量的 $L_2$ 范数，**矩阵 $\mathbf{X}\in\mathbb{R}^{m\times n}$ 的 Frobenius 范数（Frobenius norm）是矩阵元素平方和的平方根：**
$$
\|\mathbf{X}\|_F=\sqrt{\sum_{i=1}^m\sum_{j=1}^nx_{ij}^2}
$$
Frobenius 范数满足向量范数的所有性质，它就像是矩阵形向量的 $L_2$ 范数。调用以下函数将计算矩阵的 Frobenius 范数。
```python
torch.norm(torch.ones((4, 9)))

###
tensor(6.)
```

### 范数和目标
在深度学习中，我们经常试图解决优化问题： 最大化分配给观测数据的概率; 最小化预测和真实观测之间的距离。用向量表示物品（如单词、产品或新闻文章），以便最小化相似项目之间的距离，最大化不同项目之间的距离。 **目标，或许是深度学习算法最重要的组成部分（除了数据），通常被表达为范数。**

# 4 微积分
在深度学习中，我们“训练”模型，不断更新它们，使它们在看到越来越多的数据时变得越来越好。通常情况下，变得更好意味着最小化一个损失函数（loss function），即一个衡量“模型有多糟糕”这个问题的分数。最终，我们真正关心的是生成一个模型，它能够在从未见过的数据上表现良好。但“训练”模型只能将模型与我们实际能看到的数据相拟合。

**因此，我们可以将拟合模型的任务分解为两个关键问题：**
- _优化_（optimization）：用模型拟合观测数据的过程；
- _泛化_（generalization）：数学原理和实践者的智慧，能够指导我们生成出有效性超出用于训练的数据集本身的模型。

## 梯度
梯度是一个向量，其分量是多变量函数相对于其所有变量的偏导数。

我们可以连结一个多元函数**对其所有变量的偏导数**，以得到该函数的梯度（gradient）**向量**。具体而言，设函数 $f:\mathbb{R}^n\to\mathbb{R}$ 的输入是一个 $n$ 维向量 $\mathbf{x}=[x_1, x_2,\ldots, x_n]^\top$，并且输出是一个标量。函数 $f(x)$ 相对于 $x$ 的梯度是一个包含 $n$ 个偏导数的向量:
$$
\nabla_{\mathbf{x}}f(\mathbf{x})=\left[\frac{\partial f(\mathbf{x})}{\partial x_1},\frac{\partial f(\mathbf{x})}{\partial x_2},\ldots,\frac{\partial f(\mathbf{x})}{\partial x_n}\right]^\top,
$$
其中 $\nabla_{\mathbf{x}}f(\mathbf{x})$ 通常在没有歧义时被 $\nabla f(\mathbf{x})$ 取代

![[Pasted image 20231111213813.png]]

## 链式法则
然而，上面方法可能很难找到梯度。这是因为在深度学习中，多元函数通常是复合（composite）的，所以难以应用上述任何规则来微分这些函数。幸运的是，**链式法则可以被用来微分复合函数。**

让我们先考虑单变量函数。假设函数 $:y=f(u)$ 和 $u=g(x)$ 都是可微的，根据链式法则：
$$
\frac{dy}{dx}=\frac{dy}{du}\frac{du}{dx}.
$$
现在考虑一个更一般的场景，即函数具有任意数量的变量的情况。假设可微分函数 $y$ 有变量 $u_1,u_2,...,u_3$，其中每个可微分函数 $u_i$ 都有变量 $x_1,x_2,...,x_3$。注意，$y$ 是 $x_1,x_2,...,x_3$ 的函数。对于任意 $i=1,2,\ldots,n$，链式法则给出：
$$
\begin{aligned}\frac{\partial y}{\partial x_i}&=\frac{\partial y}{\partial u_1}\frac{\partial u_1}{\partial x_i}+\frac{\partial y}{\partial u_2}\frac{\partial u_2}{\partial x_i}+\cdots+\frac{\partial y}{\partial u_m}\frac{\partial u_m}{\partial x_i}\end{aligned}
$$
## 自动微分
深度学习框架通过自动计算导数，即自动微分（automatic differentiation）来加快求导。实际中，根据设计好的模型，系统会构建一个计算图（computational graph），来跟踪计算是哪些数据通过哪些操作组合起来产生输出。自动微分使系统能够随后**反向传播梯度**。这里，_反向传播_（backpropagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。

### 例子

例子：$y=2\mathbf{x}^\top\mathbf{x}$ 关于列向量 $x$ 求导

```python
x = tensor([0., 1., 2., 3.])
```

**在我们计算 $y$ 关于 $x$ 的梯度之前，需要一个地方来存储梯度**。重要的是，我们不会在每次对一个参数求导时都分配新的内存。因为我们经常会成千上万次地更新相同的参数，每次都分配新的内存可能很快就会将内存耗尽。
>注意，一个标量函数关于向量 $x$ 的梯度是向量，并且与 $x$ 具有相同的形状。

```python
#将张量设置为需要梯度计算，这意味着在进行反向传播时，该张量的梯度将被计算和更新。
x.requires_grad_(True)  # 等价于x=torch.arange(4.0,requires_grad=True)

###
x.grad = None  # 默认值是None
```

现在计算 $y$。
```python
y = 2 * torch.dot(x, x)

###
tensor(28., grad_fn=<MulBackward0>)
```

`x` 是一个长度为4的向量，计算 `x` 和 `x` 的点积（等于 $\mathbf{x}^\top\mathbf{x}$），得到了我们赋值给 `y` 的标量输出。接下来，**通过调用反向传播函数来自动计算 `y` 关于 `x` 每个分量的梯度，并打印这些梯度。**

```python
y.backward()

###
x.grad = tensor([ 0.,  4.,  8., 12.])
```

函数 $y$ 关于 $x$ 的梯度应为 $4x$，快速验证这个梯度计算是否正确
```python
x.grad == 4 * x

###
tensor([True, True, True, True])
```

如果要继续计算 `x` 的另一个函数，要记得清空梯度
```python
# 在默认情况下，PyTorch会累积梯度，我们需要清除之前的值
x.grad.zero_()
```

### 非标量变量的反向传播
当 `y` 不是标量时，向量 `y` 关于向量 `x` 的导数的最自然解释是一个矩阵。对于高阶和高维的 `y` 和 `x`，求导的结果可以是一个高阶张量。

然而，虽然这些更奇特的对象确实出现在高级机器学习中（包括深度学习中）， **但当调用向量的反向计算时，我们通常会试图计算一批训练样本中每个组成部分的损失函数的导数。这里，我们的目的不是计算微分矩阵，而是单独计算批量中每个样本的偏导数之和。**
```python
# 对非标量调用backward需要传入一个gradient参数，该参数指定微分函数关于self的梯度。
# 本例只想求偏导数的和，所以传递一个1的梯度是合适的
x.grad.zero_()
y = x * x
# 等价于y.backward(torch.ones(len(x)))
y.sum().backward()

###
x.grad = tensor([0., 2., 4., 6.])
```

### 分离计算
有时，我们希望将某些计算移动到记录的计算图之外。例如，假设 `y` 是作为 `x` 的函数计算的，而 `z` 则是作为 `y` 和 `x` 的函数计算的。想象一下，我们想计算 `z` 关于 `x` 的梯度，但由于某种原因，希望将 `y` 视为一个常数，并且只考虑到 `x` 在 `y` 被计算后发挥的作用。

这里可以分离 `y` 来返回一个新变量 `u`，该变量与 `y` 具有相同的值，但丢弃计算图中如何计算 `y` 的任何信息。换句话说，梯度不会向后流经 `u` 到 `x`。因此，下面的反向传播函数计算 `z=u*x` 关于 `x` 的偏导数，同时将 `u` 作为常数处理，而不是 `z=x*x*x` 关于 `x` 的偏导数。 
```python
x.grad.zero_()
y = x * x
u = y.detach() # 分离y，将上一行的乘积赋给新变量u
z = u * x # 此时u不再是x*x,而只是一个乘积

z.sum().backward() 
x.grad == u # z=u*x 对x求导等于u。如果不分离y，这里应该是3x^2

###
tensor([True, True, True, True])
```

由于记录了 `y` 的计算结果，我们可以随后在 `y` 上调用反向传播，得到 `y=x*x` 关于的 `x` 的导数，即 `2*x`。
```python
x.grad.zero_()

y.sum().backward()
x.grad == 2 * x

###
tensor([True, True, True, True])
```

### Python 控制流的梯度计算
使用自动微分的一个好处是： 即使构建函数的计算图需要通过 Python 控制流（例如，条件、循环或任意函数调用），我们仍然可以计算得到的变量的梯度。

在下面的代码中，`while` 循环的迭代次数和 `if` 语句的结果都取决于输入 `a` 的值。 
```python
def f(a):
    b = a * 2
    while b.norm() < 1000:
        b = b * 2
    if b.sum() > 0:
        c = b
    else:
        c = 100 * b
    return c
```

让我们计算梯度。

```python
a = torch.randn(size=(), requires_grad=True)
#size=()表示创建一个标量（0维张量）
d = f(a)
d.backward()
```

我们现在可以分析上面定义的 `f` 函数。请注意，它在其输入 `a` 中是分段线性的。换言之，对于任何 `a`，存在某个常量标量 `k`，使得 `f(a)=k*a`，其中 `k` 的值取决于输入 `a`，因此可以用 `d/a` 验证梯度是否正确。

```python
a.grad == d / a

###
tensor(True)
```

# 5 概率
简单地说，机器学习就是做出预测。

- 我们可以从概率分布中采样。
- 我们可以使用联合分布、条件分布、Bayes定理、边缘化和独立性假设来分析多个随机变量。
- 期望和方差为概率分布的关键特征的概括提供了实用的度量形式。

# 6 查阅文档
- **查找模块中的所有函数和类**
为了知道模块中可以调用哪些函数和类，可以调用 `dir` 函数。例如，我们可以查询随机数生成模块中的所有属性：

```python
import torch
print(dir(torch.distributions))

###
['AbsTransform', 'AffineTransform', 'Bernoulli', 'Beta', 'Binomial', 'CatTransform', 'Categorical', 'Cauchy', 'Chi2'......
```

通常可以忽略以“`__`”（双下划线）开始和结束的函数，它们是Python中的特殊对象， 或以单个“`_`”（单下划线）开始的函数，它们通常是内部函数。 根据剩余的函数名或属性名，我们可能会猜测这个模块提供了各种生成随机数的方法， 包括从均匀分布（`uniform`）、正态分布（`normal`）和多项分布（`multinomial`）中采样。

- **查找特定函数和类的用法**
有关如何使用给定函数或类的更具体说明，可以调用 `help` 函数。例如，我们来查看张量 `ones` 函数的用法。
```python
help(torch.ones)
```

在Jupyter记事本中，我们可以使用`?`指令在另一个浏览器窗口中显示文档。 例如，`list?`指令将创建与`help(list)`指令几乎相同的内容，并在新的浏览器窗口中显示它。 此外，如果我们使用两个问号，如`list??`，将显示实现该函数的Python代码。