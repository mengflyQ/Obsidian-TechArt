# 1 体积渲染入门

## 1.1 前言：本课的结构和方法

体积渲染（从技术上讲，使用 "参与介质 "一词而不是 "体积 "一词会更好）是一个几乎与硬表面渲染一样庞大和复杂的主题。它有自己的方程组，实际上，这些方程组几乎是用于描述光与硬物质相互作用的方程组的一般化。  

对于不一定适应如此复杂数学公式的读者来说，这些公式可能会让他们不知所措。
按照我们在 Scratchapixel 上的教学方式，我们选择了一种 "自下而上 "的方法来应对体积渲染的教学挑战。或者换一种说法，就是一种实用的方法。我们将不从方程式开始深入研究，而是编写代码来渲染一个简单的体积球体，并希望能以直观的方式对问题进行解释。  
然后，我们将在这节课结束时总结并正式确定之前所学的所有知识。

我们将用几节课的时间来讲解体积渲染（这是一个庞大的主题）。在本入门课程中，我们将学习体积渲染和光线步进的基础知识。  接下来的课程将介绍渲染体积的其他可能方法、应用于参与介质的全局照明、多重散射、用于存储体积数据的格式（如 OpenVDB）等。

如果您对体积渲染感兴趣，也可以查看 [模拟天空的颜色](https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky.html) 一课。天空是一种体积。

## 1.2 简介


本课前两章的目的是学习如何在色彩均匀的背景上渲染一个由单一光源照射的球体。  这将帮助我们初步直观地了解什么是体积，并介绍我们将用于渲染体积的光线行进算法。

在本章中，我们将**只渲染密度均匀的普通体积**。我们将忽略物体从外部或内部投射的阴影，以及如何渲染密度不同的体积。这些内容将在接下来的章节中学习。

与其提供大量关于什么是体积以及用于渲染它们的方程的详细背景信息，不如让我们直接进入实现阶段，并从那里获得对体积渲染的更正式的理解。

![[2865a48d9620711b0008dfb9436e250f_MD5.png]]

## 1.3 内部透射率、吸收、粒子密度和比尔定律
内部透射率 (Internal Transmittance) **（透射率=透明度）**
吸收 (Absorption)
粒子密度 (Particle Density)
比尔定律 (Beer's Law)

光线经过物体反射或光源发射到达我们的眼睛时，很可能会被吸收。**空间中的粒子越多，空间就越不透明。**  

从这一简单的观察中，我们可以得出一些与体积渲染有关的基本概念：吸收、透射以及体积的不透明性与所含粒子密度之间的关系。  

**目前，我们暂且认为体积中所包含的粒子密度是均匀的。**

![[17bd89227dae8be76ebad072a304227c_MD5.png]]

当光线沿着我们眼睛的方向穿过这个体积时（我们看到的物体图像就是这样在我们的眼睛中形成的），部分光线会在穿过这个体积时被其吸收。这种现象叫做**吸收（absorption）**。我们感兴趣的是从背景穿过体积的光量，即**内部透射率（internal transmittance，光在穿过体积的光量）**。内部透射率可以看作一个从 0（没有光传过体积，即体积阻挡了所有光线）到 1（嗯，这是一个真空，所以所有光线都被透过）的值。


通过该体积传输的光量受比尔-朗伯定律（Beer-Lambert law，简称比尔定律）的支配。**在比尔-朗伯定律中，密度的概念用吸收系数（和散射系数，本章稍后将介绍散射系数）来表示。**  您可以将其理解为 "**体积越密集，吸收系数 $\sigma$ 越高**"；
可以直观地猜到，随着吸收系数的增加，体积会变得**更不透明**。比尔-朗伯定律方程是这样的
$$
T = exp(-distance * \sigma_a)=e^{(-distance * \sigma_a)}
$$

**该定律指出，光通过一个体积的内部透射率（$T$）与该体积的吸收系数（$\sigma$）和光通过材料的距离（$distance$ ）的乘积之间存在指数关系。**
![[Pasted image 20240322221153.png]]


这些系数的单位是距离的倒数或长度的倒数，如 $cm^{-1}$ 或 $m^{-1}$（这并不重要，只是比例问题）。这一点很重要，因为它有助于直观地了解这些系数所包含的信息。  如果您希望在任何给定的点/距离上发生随机事件（例如光子被吸收或散射），您可以将吸收系数（以及我们稍后将介绍的散射系数）视为一种概率或可能性。

吸收系数和散射系数表示的是一种**概率密度**（以防万一您想对这一主题进行更多研究）。由于它是一种概率，因此不应超过 1，但这取决于测量的单位。例如，如果您使用毫米，那么对于给定的介质，您可能会得到 0.2。  但如果用厘米和米来表示，就分别变成了 2 和 20。因此，在实践中，没有什么能阻止你使用大于 1 的数值。

> [!note] 系数与平均自由路径 (mean free path)之间的关系
> 
吸收系数和散射系数的单位是长度的倒数，这一点很重要，因为如果取系数的倒数（1 除以吸收系数和散射系数），就可以得到距离。 这个距离被称为平均自由路径（mean free path），**代表随机事件发生的平均距离：**
> $$
> \text{mean free path} = { {1}\over{\sigma_s}}
> $$
> 
> 该值在模拟参与介质中的多重散射时起着重要作用。查看 "次表层散射 "和 "高级体积渲染 "课程，了解更多有关这些超酷主题的信息。

![[f27f364520ea71620ffec04b57a4b6ca_MD5.png]]
>图 1：距离越远或密度越大，内部透射率值越低。


吸收系数或距离越大，$T$ 就越小。比尔-朗伯定律方程返回一个 0-1 范围内的数字。如果距离或吸收系数为 0，方程返回 1。对于固定距离，$T$ 会随着吸收系数的增大而减小。  
在吸收系数固定的情况下，$T$ 会随着距离的增加而减小。**光在体积中传播得越远，被吸收的就越多。体积中的粒子越多，吸收的光就越多**。很简单。您可以从图 1 中看到这种效果。

> [!quote] 啤酒和宝石
> 纯吸收介质是透明的（非半透明），但透过它看到的图像会变暗（例如：啤酒、葡萄酒、宝石、有色玻璃）。

## 1.4 在统一背景上渲染体积

从这里开始很容易。假设我们有一块体积板，其厚度和密度都是已知的。比如分别为 10 和 0.1。 
那么，如果背景颜色（例如我们正在观察的墙壁反射的光线）为 (xr、xg、xb)，我们通过体积看到的背景颜色的多少就是：

```c++
vec3 background_color {xr, xg, xb};
float sigma_a = 0.1; // 密度作为吸收系数
float distance = 10; //光通过材料的距离
float T = exp(-distance * sigma_a); //内部透射率

//用内部透射率T乘以背景颜色
vec3 background_color_through_volume = T * background_color; 
```

## 1.4 散射

请注意，到目前为止，我们一直假定我们的体积是黑色的。换句话说，我们只需将板块所在位置的背景颜色变暗即可。但体积并不一定是黑色的。**像固体物体一样的体积也会反射（或更准确地说散射）光线。** 
这就是为什么当你在晴天看云时，你可以看到云的形状，就好像它是一个固体物体一样。**体积也能发光**（想想蜡烛的火焰），我们只是为了完整起见才提到这一点，但**在本章中我们将忽略发光**。 
因此，假设我们的体积板具有某种颜色，例如（yr、gy、yb）。我们暂时不考虑颜色的来源，本章稍后将对此进行解释。 
在此之前，我们先假设我们的体积具有某种颜色，这是由于体积物体 "反射 "了照射它的光线（虽然不是真的反射，但我们现在还是使用 "反射 "的概念，就像固体物体一样）。那么我们的代码就变成了

```c++
vec3 background_color {xr, xg, xb}; 
float sigma_a= 0.1; 
float distance = 10; 
float T = exp(-distance * sigma_a); 
vec3 volume_color {yr, yg, yb}; 

//混合背景颜色和体积颜色
vec3 background_color_through_volume = T * background_color + (1 - T) * volume_color;
```

 
将其视为在 Photoshop 中使用 **Alpha 混合法** 混合 (A+B) 图像的过程。假设，其中 A 是背景图像（相当于我们的蓝色墙壁），B 是不透明度为 $\alpha$ 的半透明物体。 


将这两幅图组合起来的公式是
$$
C = (1 - \alpha) * A + \alpha * B
$$
其中，
-  透射率 = 1-不透明度=透明度  ，所以**透射率就是透明度**
- B 是指体积对象的颜色

我们将在研究射线行进算法时再讨论这个问题；现在，请牢记这一点。

## 1.5 渲染我们的第一个体积球


我们已经拥有了渲染第一张 3D 图像所需的一切。我们将利用目前所学的知识渲染一个球体，假定球体中充满了粒子。我们将假定在某个背景上渲染我们的球体。原理非常简单。  
 
**我们首先检查相机光线与球体之间是否有交点。如果没有交点，我们只需返回背景颜色。如果有交点，我们将计算球面上射线进入和离开球面的点。由此，我们可以计算出光线穿过球体的距离，并应用比尔定律计算出有多少光线穿过球体。** 我们暂且假设球体 "反射"（散射）的光线是均匀的。  

我们稍后将讨论光照问题。

![[25230b1d954633ec988b85087f474758_MD5.png]]
>**图 2**：穿过体积物体的摄像机光线。

![[9d91cc228041c15dd4c0feb53e2c01b4_MD5.png]]
>**图 3：** 我们利用摄像机光线与体积物体的交点来计算体积物体沿摄像机光线的不透明度。


> [!NOTE] 实现细节
从技术上讲，我们不需要计算射线进入和离开球面的点，就能得到各点之间的距离。我们只需用 "tmax "减去 "tmin"（摄像机光线与球面相交处的光线参数距离）即可。在下面的示例中，我们计算它们是为了强调我们关心的是这两点之间的距离。

```c++
class Sphere : public Object 
{ 
public: 
    bool intersect(vec3, vec3, float, float) const { /* compute ray-sphere intersection */ } 
    float sigma_a{ 0.1 }; 
    vec3 scatter{ 0.8, 0.1, 0.5 }; 
    vec3 center{ 0, 0, -4 }; 
    float radius{ 1 }; 
}; 
 
void traceScene(vec3 ray_origin, vec3d ray_direction, const Sphere *sphere) { 
    float t0, t1; 
    vec3 background_color { 0.572, 0.772, 0.921 }; 
    if (sphere->intersect(rayOrigin, rayDirection, t0, t1)) { 
        vec3 p1 = ray_origin + ray_direction * t0; 
        vec3 p2 = ray_origin + ray_direction * t1; 
        float distance = (p2 - p1).length();  // though you could simply do t1 - t0 
        float tranmission = exp(-distance * sphere->sigma_a); 
        return background_color * transmission + sphere->scatter * (1 - transmission); 
    } 
    else 
       return background_color; 
} 
 
void renderImage() { 
    Sphere *sphere = new Sphere; 
    for (each row in the image) 
        for (each column in the image) 
            vec3 ray_dir = computeRay(col, row); 
            pixel_color = traceScene(ray_orig, ray_dir, sphere); 
            image_buffer[...] = pixel_color;  // store pixel color in image buffer 
 
    saveImage(image_buffer); 
    ... 
}
```
 
非常合乎逻辑的是，随着密度的增加，透射率会趋近于 0，这意味着体积球的颜色比背景的颜色更重要。

![[f6c5eb731857aacb356cbacf43df3eb7_MD5.png]]

从上面的图片中可以看到，球体中心的体积变得越来越不透明（射线穿过球体的距离最大）。  

您还可以看到，随着密度的增加（随着 sigma_a 的增加），球体总体上变得更加不透明。尤里卡！你刚刚渲染了第一个体积球体，距离成为体积渲染专家已经不远了。

## 1.6 让我们加入光！内散射


到目前为止，我们已经有了一个很好的体积球体图像，但照明情况如何呢？如果我们将光线照射到一个体积物体上，我们可以看到，体积中直接受光的部分比阴影中的部分更亮。  

体积也会被灯光照亮。我们该如何解释呢？

原理非常简单。让我们想象一下光源发出的光穿过体积的情形。当它穿过体积时，其强度会因吸收而衰减。  

毫不奇怪，光能在体积中传播了一定距离后还剩下多少，是由比尔定律决定的。换句话说，如果我们知道光在体积中传播的距离，那么它在该距离上的强度就是：

```c++
float light_intensity = 10; // just a number, it could be anything 
float T = exp(-distance_travelled_by_light * volume->absorption_coefficient); 
light_intensity_attenuation = T * ligth_intensity;
```

首先，根据比尔定律，光的能量在穿过体积时会减少。这很符合逻辑。  

但还有另外一种情况：光源发出的光最初并不是射向眼睛的，但由于我们所说的散射效应，它也会转向眼睛（至少是一部分）。在这种特殊情况下，我们称之为内散射 (in-scattering)。**内散射指的是穿过一个体积的光，由于散射事件而被重新定向到眼睛**。这种效果如图 4 所示。散射事件是光子与构成介质/体积的粒子/原子之间相互作用的结果。  **原子并没有吸收或反射光子（这也可能发生），而是将光子 "吐 "出，吐出的方向与其进入的方向不同。** 我们将在接下来的章节中进一步了解这种现象。

![[c536a363e658f0dd28340bf7249e4065_MD5.png]]
>图 4：我们透过体积物体看到的光线来自背景物体（此处为蓝色）和光源。尽管光源发出的光束并没有射入眼睛，但由于内散射效应，一些光束在穿过体积物体时会被重新定向射入眼睛。

到达眼睛的光线（沿着图中用蓝色绘制的特定眼睛/摄像机光线），是来自背景（我们的蓝色背景）的光线和由于内向散射而散射到眼睛的来自光源的光线（黄色光线）的组合。那么，我们**如何计算光源的贡献呢？我们需要 "测量 "散射到眼睛的光线（与相机光线一起），这是内散射的效果。**  

问题是，我们需要考虑与球面相交的整个摄影光线部分的这种效应（图 5）。我们需要在 t0-t1 的范围内 "整合 "沿摄像机光线散射的光线。

![[29c2858ec126d28ebf1b007af5831185_MD5.png]]
>图 5：我们需要整合穿过体积物体的那段光线中由于内向散射而转向眼睛的光线。

**为了解决这个问题，我们将把穿过体积的摄像光线分成若干段（我们的样本，如果你愿意），然后使用以下步骤计算到达每段（样本）中心的光线数量（概念的直观表示见图 6）：**

*   我们**从采样点（我们称之为 X）向光源**射出一条射线，计算采样点到球体边界（我们称之为 P 点）的距离。  请注意，X 总是在球面（我们的体积）内，而 P 总是球面上的一点。
*   然后应用比尔定律，就能知道光能在从 P 点（该光线进入球体的点）到 X 点（该光线沿眼线散射向观众的点）的过程中衰减了多少。


![[dbf62ae2a7e66f3eeb9132729e5566d6_MD5.png]]
>图 6：沿着射线有规律地行进，使用黎曼和来估计我们的积分。

![[2280a603e4158a4df4ff84a22c562c2d_MD5.png]]
>图 7：我们可以利用黎曼和来估算曲线下的面积，**这条曲线代表了沿摄像机散射的光量**。其原理是将曲线下的面积分解成一个个小矩形的总和。 每个矩形的高度由 Li (x) 确定，宽度 dx 则由用户定义。


要了解我们要解决的问题类型，我们需要看一下图 6 和图 7。图 6 显示了沿摄像机光线射入的光线，从图的下半部分可以看出，这是一个连续函数。  我们把这个函数称为 $Li (x)$，其中 x 是指 t0-t1 范围内摄像机射线上的任意一点。我们需要计算的是曲线下方的 "面积"。在数学中，它是一个积分，我们可以把它写成
$$
\int_{x=t_0}^{t_1} Li(x) dx
$$

正如我们刚才所说，积分的结果（是一个数字）被定义为曲线（函数 Li (x)）下的（净符号）面积，如图 6 所示。在我们的案例中，问题在于我们无法用解析式计算这个面积。  

不过，我们可以用一个小窍门来近似计算这个面积，那就是把它分解成更简单的形状，我们知道矩形的面积（如图 7 所示）。  我们沿着曲线以固定的间隔对 Li (x) 进行取样，我们知道宽度为 (dx)，这样得到的矩形的面积就可以计算为 Li (x) 乘以 dx（x 位于间隔的中间）。  将所有矩形的面积相加，就得到了曲线下面积的近似值。等着瞧吧！这种方法被称为**黎曼和**（用已知的面积来近似我们不知道面积的形状的想法可以追溯到希腊人）。

更进一步。您可以在 ["Mathematics of Shading"](https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/mathematics-of-shading/mathematics-of-shading.html).  课程中找到更多关于积分和如何计算积分的信息。

那么，如何将其转化为代码呢？