---
title: 11 曲线曲面几何
aliases: []
tags: []
create_time: 2023-08-08 13:35
uid: 202308081335
banner: "[[Pasted image 20230808133603.png]]"
---

# 1 曲线与曲面
## 概述

三角形是渲染流水线中的默认图元。然而，我们可以通过曲线和曲面方程对原始三角形进行变换，从而生成更多用于渲染的表示曲面的三角形。
**使用曲面表示模型具有以下优点：**
(1) 比三角形集合具有更紧凑的表示方式；
(2) 提供可扩展的几何图元；
(3) 提供比直线和平面三角形更平滑和连续的图元；
(4) 动画和碰撞检测可能变得更简单和更快速。

**在实时渲染中，曲面具有以下优势**：可以节省模型存储内存，对曲面进行变换通常涉及较少的矩阵乘法，相较于使用网格表示曲面进行变换。如果图形硬件可以直接接受这样的曲面描述，那么主机 CPU 发送到图形硬件的数据量通常比发送三角形网格要少得多。

使用曲面还带来了可伸缩性的优点。这意味着可以根据某些因素动态决定曲面的三角形数量。

**概念总结：**
**镶嵌 (tessellation)**：在实时渲染中，我们需要计算并创建 (多个) 三角形对真实曲面进行拟合，这个过程称为镶嵌。在运行时，表面可以被镶嵌为多个小三角形。
**控制点（control point）**：控制点是定义曲面形状的关键元素。它们是二维或三维空间中的点，用于确定曲面的控制网格。一般来说，曲面通过关于控制点的方程计算生成。比如贝塞尔曲线通过控制点控制曲线，三角形可以看作时拥有 3 个控制点的面片。
**面片（patch）**：对于一个参数曲面 $p(u,v)$ ，如果定义域 $(u,v)$ 为矩形，则称该曲面为 patch。可以看成是多个顶点的集合，包含每个顶点的属性。**（属性是所有顶点共享的，不是每个顶点有独自的属性）**
## 参数曲线

**参数曲线 (parametric curve)** 使用方程作为关于参数 $t$ 的函数来描述**点**。我们将其写做 $p(t)$ ，这意味着该函数每个 $t$ 值都会生成一个点。 $t\in[a,b]$ 称为定义域。生成的点是连续的，即 $\sigma\rightarrow 0,~p(t+\sigma)\rightarrow p(t)$ 。

### 贝塞尔曲线

点 $(p_0, p_1)$ 构成的线段可以使用**线性插值方程** $p(t)$ 描述，即

$\mathbf{p}(t)=\mathbf{p_{0}}+t(\mathbf{p_{1}}-\mathbf{p_{0}})=(1-t)\mathbf{p_{0}}+\mathbf{p_{1}},~t\in[0,1]$

如下图左，线性插值对两点路径拟合较好，但对多个点的路径拟合会产生连接处的突变。

![[17f9b8be9261fec5cbba5e33bf3f0c31_MD5.jpg]]

为了解决这个问题，我们采用**重复线性插值**的方式。通过这样做，我们得到了 **Bezier 曲线**的几何构造。

为了能够进行重复插值，我们需要引入更多的点，它们被称为**控制点 (control points)**。例如下图中，我们引入 $abc$ 作为控制点。假设我们要求 $ac$曲线路径上的点 $f$。首先，在 ab 上找线性 $t=1/3$ 的点即 $d=p_{ab}(1/3)$ 。然后，在 $bc$ 上找 $e=p_{bc}(1/3)$ 。最后，在 de 上找 $f=p_{de}(1/3)$ 。

![[d7c856b385027dcfc95dd274a547da50_MD5.jpg]]

通过上述描述，我们将 $p(t)=f$ ，最终得到如下的关系：

$\begin{align} \mathbf{p}(t)&=(1-t)\mathbf{d}+t\mathbf{e}\\ &=(1-t)[(1-t)\mathbf{a}+t\mathbf{b}]+t[(1-t)\mathbf{b}+t\mathbf{c}]\\ &=(1-t)^{2}\mathbf{a}+2(1-t)t\mathbf{b}+t^{2}\mathbf{c} \end{align}$

观察发现 $t$ 的最大次数为 2，因此这是一个抛物线。**实际上，给定 $n+1$ 个控制点，曲线的次数就是 $n$**。这意味着更多的控制点为曲线提供了更多的自由度。

这种重复插值计算贝塞尔曲线的方法称为 **de Casteljau 德卡斯特里奥算法**。在这个算法中，我们定义插值次数 $k$ ，由此次插值产生的点为 $p_{i}^{k}$ ，其中 $i\in[0,n-k]$ 。那么，由 $n+1$ 个控制点定义的 $n$ 阶贝塞尔曲线可以用如下公式表示：

$p_{i}^{k}(t)=(1-t)\mathbf{p_{i}^{k-1}}(t)+t\mathbf{p_{i+1}^{k-1}}(t),~\left\{\begin{align}k&=1...n,\\i&=0...n-k.\end{align} \right.$

各点的关系可以从下图中看出：

![[34a5fa3ae5ef0669991f06e72f312b60_MD5.jpg]]

事实上，我们可以将 de Casteljau 算法展开，得到它的线性表达式。这又称为使用 **伯恩斯坦多项式 (bernstein polynomials)** 的贝塞尔曲线。

$\mathbf{p}(t)=\sum_{i=0}^{n}B_{i}^{n}\mathbf{p_{i}}$

其中， $B_{i}^{n}$ 被称为 **伯恩斯坦多项式 (bernstein polynomials)** 或 **贝塞尔基方程** 。也就是说，我们可以将这个线性展开理解为**先算出所有的基向量，再对控制点线性组合**。

$B_{i}^{n}(t)=\left(\begin{matrix}n\\i\end{matrix} \right)t^{i}(1-t)^{n-i}=\frac{n!}{i!(n-i)!}t^{i}(1-t)^{n-i}$

![[5c534229cea65ecf6a323a86d25a11a1_MD5.jpg]]

如上图，伯恩斯坦系数有如下性质。

$B_{i}^{n}(t)\in[0,1],~when t\in[0,1],~~~~and~~\sum_{i=0}^{n}B_{i}^{n}(t)=1$

这两个性质确保贝塞尔曲线会经过起点和终点。并且具有**凹包性质**，即曲线一定不会超出所有控制点构成的多边形范围。

![[ddccc1225d07d395c661f05bb6d0b121_MD5.jpg]]

另外，对曲线直接应用仿射变换 (平移，缩放，旋转) 等效于先对控制点进行相同放射变换，然后对新控制点计算新曲线。控制点的数量是小于曲线上点的数量的，所以后者计算更为高效。

我们可以将伯恩斯多项式写作矩阵形式，这在某些数学运算上更为简洁。以三次贝塞尔曲线 (cubic bezier curve) 为例，它的线性展开为：

$\mathbf{p}(t)=(1-t)^{3}\mathbf{p_{0}}+3t(1-t)^{2}\mathbf{p_{1}}+3t^{2}(1-t)\mathbf{p_{2}}+t^{3}\mathbf{p_{3}}$

我们将其重写为矩阵形式：

$p(t)=\begin{bmatrix}1&t&t^{2}&t^{3}\end{bmatrix} \begin{bmatrix}1& 0& 0 &0\\ -3& 3& 0& 0\\ 3& -6& 3& 0\\ -1& 3& -3& 1\end{bmatrix} \begin{bmatrix}p_{0}\\ p_{1}\\ p_{2}\\ p_{3}\end{bmatrix}$

我们可以运用导数的乘方与乘积运算法则来求出伯恩斯坦基函数的导数，然后将它们整理起来，最终得到贝塞尔曲线的导数为：

$\frac{d}{dt}\mathbf{p}(t)=n\sum_{i=0}^{n-1}B_{i}^{n-1}(t)(\mathbf{p}_{i+1}-\mathbf{p}_{i})$

可以发现，**贝塞尔曲线的导数是阶数比原方程少 1 的贝塞尔曲线**。

贝塞尔曲线也存在一些**缺点**，首先它不会通过所有的控制点（除了端点）。并且，随着控制点数量的增加，曲线的阶数也会增加，导致计算变得越来越昂贵。

## 参数曲面

**参数曲面 (parametric)** 是参数曲线的自然延伸，就像三角形或四边形是 1D 到 2D 的扩展，参数曲面可以用来建模具有弯曲表面的物体。一个参数曲面由少量的 **控制点 (control points)** 控制。在实时渲染中，我们需要计算并创建 (多个) 三角形对真实曲面进行拟合，这个过程称为**镶嵌 (tessellation)**。在运行时，表面可以被镶嵌为多个小三角形。因此，参数曲面非常适合在质量和速度之间进行权衡。另一个优点是控制点可以被动画化，并且随后对表面进行镶嵌处理；而直接动画化大型三角网格则可能代价更高。

### 贝塞尔曲面

**贝塞尔曲面 (bezier patches)** 由贝塞尔曲线从一个参数扩展为两个参数得到。我们先讨论如何得到一个由 4 控制点得到的参数曲面。首先给出四个控制点 $abcd$ 。并且用参数 $(u, v)$ 代替参数 $t$ ， $u$ 用来对 $a\&b$ 和 $c\&d$ 进行线性插值得到 $e$ 和 $f$ ， $v$ 用来对 $e\&f$ 线性插值得到 $p(u,v)$ 。

![[24ad1dccf80c7931734e61e9ff92463b_MD5.jpg]]

这个过程用表达式为：

$\begin{align} \mathbf{p}(u,v)&=(1-v)\mathbf{e}+v\mathbf{f}\\ &=(1-u)(1-v)\mathbf{a}+u(1-v)\mathbf{b}+(1-u)v\mathbf{c}+uv\mathbf{d} \end{align}$

注意到，这与纹理双线性插值方程相同，它描述了最简单的非平面参数曲面，其中曲面上不同的点由定义域 $(u,v)\in[0,1]^{2}$ 生成。当定义域为矩形时，我们称这个曲面为**面片 (patch)**。

贝塞尔曲面同样可以通过重复插值得到。以下图双二次 (biquadratic) 贝塞尔曲面为例，首先定义 9 个控制点，然后插值相邻 4 个控制点得到 4 个新控制点，再用 4 个新控制点插值得到最终点。

![[9cef64cf0b436748a1f7f520a261d15a_MD5.jpg]]

我们定义曲面的阶数为 $n$ ，控制点为 $p_{i,j},~i,j\in[0,n]$ ，因此该曲面共有 $(n+1)^{2}$ 个控制点。令第 k 次插值生成的控制点为 $p^{k}_{i,j}$ 。可以得到 **de Casteljau[patches]**：

$\begin{align} p_{i,j}^{k}(u,v)&=(1-u)(1-v)\mathbf{p_{i,j}}^{k-1}+u(1-v)\mathbf{p_{i,j+1}}^{k-1}+(1-u)v\mathbf{p_{i+1,j}}^{k-1}+uv\mathbf{p_{i+1,j+1}^{k-1}}\\ k&=1...n,~~i=0...n-k,~~j=0...n-k \end{align}$

我们同样可以将它展开为 **Bernstein[patches]**：

$\begin{align} p(u,v)&=\sum_{i=0}^{m}B_{i}^{m}(u)\sum_{j=0}^{n}B_{j}^{n}(v)p_{i,j}=\sum_{i=0}^{m}\sum_{j=0}^{n}B_{i}^{m}(u)B_{j}^{n}(v)\mathbf{p_{i,j}}\\ &=\sum_{i=0}^{m}\sum_{j=0}^{n}\left(\begin{matrix}m\\i\end{matrix}\right)\left(\begin{matrix}n\\j\end{matrix}\right)u^{i}(1-u)^{m-i}v^{j}(1-v)^{n-j}\mathbf{p_{i,j}} \end{align}$

再伯恩斯坦多项式中，我们定义了 $m\times n$ 的复合度数。对于第一个式子，我们可以理解为 **先算出每列的控制点，然后再将每列控制点按行加权得到最终点** 。第二个式子可以理解为**先计算出两个方向的基数，然后计算出 i,j 基向量，最后将所有基向量组合起来**。

![[865720b2550811e624dab0ec9e646c67_MD5.jpg]]

如果说 m>n，则需要先进性 n 次双线性插值，然后再进行 m-n 次线性插值，如下图。

![[030a136c1b03f3d5c7197cff63efd8c1_MD5.jpg]]

但在一般情况下，m=n，伯恩斯坦多项式可以简写为：

$\mathbf{p}(u,v)=\sum_{i=0}^{m}B_{i}^{m}(u)\sum_{j=0}^{n}B_{j}^{n}(v)p_{i,j}=\sum_{i=0}^{m}B_{i}^{m}(u)\mathbf{q_{i}}(v)$

贝塞尔曲面同样有性质

$\sum_{i=0}^{m}\sum_{j=0}^{n}B_{i}^{m}(u)B_{j}^{n}(v)=1$

这意味着贝塞尔曲面一定过对角点，并且曲面再凹包内。同样的，对贝塞尔曲面直接进行仿射变换 (缩放，平移，旋转) 等效于对控制点进行相同变换后计算新的曲面，后者更为高效。

同样运用导数的乘方与乘积运算法则来求出伯恩斯坦基函数的导数，然后将它们整理起来，最终得到贝塞尔曲面的导数为：

$\begin{align} \frac{\partial{\bf p}(u,v)}{\partial u}&=m\sum_{j=0}^{n}\sum_{i=0}^{m-1}B_{i}^{m-1}(u)B_{j}^{n}(v)[{\bf p}_{i+1,j}-{\bf p}_{i,j}], \\ \frac{\partial{\bf p}(u,v)}{\partial v}&=n\sum_{i=0}^{m}\sum_{i=0}^{n-1}B_{i}^{m}(u)B_{j}^{n-1}(v)[{\bf p}_{i,j+1}-{\bf p}_{i,j}]. \end{align}$

将两个偏导叉乘， 可以计算未归一化的法线：

$\mathbf{n}(u,v)={\frac{\partial\mathbf{p}(u,v)}{\partial u}}\times{\frac{\partial\mathbf{p}(u,v)}{\partial v}}.$

### 贝塞尔三角形

贝塞尔三角形不像贝塞尔面片那样直截了当，但它却能衍生出 **PN 三角形**和 **Phong Tessellation**，这些技术快速而简单。

**n 阶贝塞尔三角形意味着每条边有 n+1 个控制点**，它们被表示为 $p_{i,j,k}^{0}$ ，其中 $i+j+k=n,~i,j,k\geq n$ 。因此，n 阶贝塞尔的控制点个数为：

$C(n+2,2)=\frac{(n+1)(n+2)}{2}$

贝塞尔三角形同样可以通过重复插值计算得到，但是三角形的插值是通过**重心坐标插值 (barycentric coordinates)** 进行的，即

$\mathbf{p}(u,v)=\mathbf{p}_{0}+u(\mathbf{p}_{1}-\mathbf{p}_{0})+v(\mathbf{p}_{2}-\mathbf{p}_{0})=(1-u-v)\mathbf{p}_{0}+u\mathbf{p}_{1}+v\mathbf{p}_{2}$

其中， $(u,v)$ 为重心坐标，且 $u\geq 0,~v\geq 0,~w=1-(u+v)\geq 0,~u+v\leq 1$ 。

在这个基础上，可以推出 **de Casteljau [triangles]**：

$\begin{align} \mathbf{p}_{i,j,k}^{l}(u,v)&=u{\bf p}_{i+1,j,k}^{l-1}+v{\bf p}_{i,j+1,k}^{l-1}+(1-u-v){\bf p}_{i,j,k+1}^{l-1},\\ l&=1... n,\quad i+j+k=n-l \end{align}$

贝塞尔三角形的最终顶点在 $\mathbf{p}_{000}^{n}(u,v)$ 。

![[ca8d7aff54c0242d03f140d941d7fe33_MD5.jpg]]

将 de Casteljau 展开为 **Bernstein [triangles]**：

${\bf p}(u,v)=\sum_{i+i+k=n}B_{i j k}^{n}(u,v){\bf p}_{i j k}.$

由于伯恩斯坦项基于重心坐标插值，它与贝塞尔面片的表达式有所不同：

$B_{i j k}^{n}(u,v)=\frac{n!}{i!j!k!}u^{i}v^{j}(1-u-v)^{k},\ \ \ i+j+k=n.$

同样地，可以求出 **Derivatives [triangles]**：

$\begin{align} \frac{\partial\mathrm{p}(u,v)}{\partial u}&=\sum_{i+j+k=n-1}n B_{i j k}^{n-1}(u,v){\big(}\mathrm{p}i{+}1,j,k-\mathrm{p}i,j,k+1{\big)},\\ \frac{\partial\mathrm{p}(u,v)}{\partial v}&=\sum_{i+j+k=n-1}n B_{i j k}^{n-1}(u,v){\big(}\mathrm{p}i,j+1,k-\mathrm{p}i,j,k+1{\big)}. \end{align}$

同贝塞尔面片，贝塞尔三角形一定过三个原控制点，并且曲面在控制点凹包内。

### PN 三角形
P：point  N：normal
**PN 三角形方案旨在通过使用点和法线来构建曲面，以改善三角网格的阴影和轮廓。** 该算法**不需要邻居信息即可从每个三角形的点和法线生成曲面，并且可以在硬件上进行细分。**

![[f709f22cd4bb8a1213101237d27f806d_MD5.jpg]]

PN 三角形需要且**仅需要**一个三角形的如下信息：顶点位置 $\mathbf{p}{300}, ~\mathbf{p{030}},~ \mathbf{p}{003}$ 和顶点法线 $\mathbf{n}{200},~\mathbf{n}{020},~\mathbf{n}{002}$ 。根据这些数据，生成如下图 7 个控制点。然后根据这总共 10 个控制点，得到贝塞尔三角面上的顶点。对法线做类似的处理，我们后面再讨论。

![[f39655381c0738b733680e825e65741b_MD5.jpg]]

令 $w=1-u-v$ ，则三次 (cubic) 贝塞尔三角形的表达式为：

$\begin{align} {\bf p}(u,v)&=\sum_{i+j+k=3}B_{i j k}^{3}(u,v){\bf p}_{i j k}\\ &=u^{3}{\bf p}_{300}+v^{3}{\bf p}_{030}+w^{3}{\bf p}_{003}+3u^{2}v{\bf p}_{210}+3u^{2}w{\bf p}_{201} \\ &+3u v^{2}{\bf p}_{120}+3v^{2}w{\bf p}_{021}+3v w^{2}{\bf p}_{012}+3u w^{2}{\bf p}_{102}+6u v w{\bf p}_{111}. \end{align}$

为了计算曲面顶点位置，我们需要先生成剩下的七个控制点的位置。为了保证贝塞尔曲面的 $C^{0}$ **连续性** (相邻贝塞尔曲面的边界处控制点相同)，边缘六个控制点可以由对角三个控制点的位置计算得到，而重心控制点可以由剩余控制点计算得到。

注意到由顶点法线够成的**顶点切线空间**都是相应的局部几何。假设我们要计算控制点 $\mathbf{p}{210}$ 的位置，可以简单地将 $\frac{2}{3}\mathbf{p}{300}+\frac{1}{3}\mathbf{p}{030}$ 投影到由顶点 $\mathbf{p}{300}$ 和对应法线 $\mathbf{n}_{200}$ 的切线空间中。

![[1b6d96c7e3c569672b2cf29ca59d9d9b_MD5.jpg]]

假设都是归一化向量，那么：

$\mathbf{p}_{210}={\frac{1}{3}}(2{\bf p}_{300}+{\bf p_{030}}-({\bf n}_{200}\cdot({\bf p}_{030}-{\bf p}_{300})){\bf n}_{200}).$

其他边缘控制点的计算类似。中心控制点可以由其他控制点计算得到：

$\mathbf{p}_{111}=\frac{1}{4}(\mathbf{p}_{210}+\mathbf{p}_{120}+\mathbf{p}_{102}+\mathbf{p}_{201}+\mathbf{p}_{021}+\mathbf{p}_{012})-\frac{1}{6}(\mathbf{p}_{300}+\mathbf{p}_{030}+\mathbf{p}_{003})$

下面讨论法线的计算。简单来说，首先，线性插值不足以描述曲面变化后的法线。由于曲面是三次贝塞尔面，所以法线应该是二次贝塞尔曲面插值。即：

$\begin{align} \mathbf{n}(u,v)&=\sum_{i+j+k=2}B_{i j k}^{2}(u,v)\mathbf{n}_{i j k}\\ &=u^{2}{\bf n}_{200}+v^{2}{\bf n}_{020}+w^{2}{\bf n}_{002}+2(u v{\bf n}_{110}+u w{\bf n}_{101}+v w{\bf n}_{011}). \end{align}$

为了完成上述公式的计算，我们需要额外的 3 个法线控制点。（只有下图三角形绕序为逆时针，下面给的公式绕序为顺时针，懒得改图了）

![[7640bd2fd2ee3fe360454317287a95fc_MD5.jpg]]

以 $p_{300}$ 法线 $n_{200}$ 和 $p_{030}$ 法线 $n_{020}$ 法线控制点 $n_{110}$ 为例。首先取它们的平均值，然后再将平均法线取平面 $\pi$ 反射向量为 $n_{110}$ 。其中，平面 $\pi$ 为过原点的法线平行于 $\vec{p_{300}p_{030}}$ 的平面。

![[5307719a668392a585f002bb1b31f95b_MD5.jpg]]

最终，计算得到 $n_{110}$ 表达式为：

${\bf n}_{110}={\bf n}_{200}+{\bf n}_{020}-2{\frac{({\bf p}_{030}-{\bf p}_{300})\cdot({\bf n}_{200}+{\bf n}_{020})}{({\bf p}_{030}-{\bf p}_{300})\cdot({\bf p}_{030}-{\bf p}_{300})}}({\bf p}_{030}-{\bf p}_{300}).$

在原 paper 中，使用因子 3/2 而不是 2，这在肉眼上很难区分差别，但因子 2 更能描述它反射的性质。

由于 PN 三角形的连续性仅为 $C^{0}$ ，这意味着在多个 PN 三角形连接处可能有折痕。

### Phong Tessellation

Phong Tessellation 与 PN 三角形类似，它主要用来平滑 Phong 着色结果，减少 artifaction。并且尽可能少的生成额外三角形，以减少消耗。相对于 PN 三角形，它的计算速度更快且更容易实现。但 PN 三角形带来的效果更好。

![[b27a0dffbe47447fcb52d15cc6f22337_MD5.jpg]]

注意到由顶点法线定义的顶点切线空间处于对应的局部几何。我们将重心坐标插值的顶点 $p(u,v,w)$ 分别投影到三个顶点的切线空间中得到 $p_{i}$ ，然后将 $p_{i}$ 利用重心坐标系数 $(u,v,w)$ 插值得到最终点 $p^{*}$ 。

![[fb10740fe3b073ef42e8faa5eda183a7_MD5.jpg]]

对于点 p，投影到经过三角形顶点 $v_{i}$ 的法线为 $n_{i}$ 的切线空间，其方程为 (向量均归一化)(向投影方向偏移)：

$\pi_{i}(\mathbf{p})=\mathbf{p}-\left((\mathbf{p}-\mathbf{v}_{i})^{T}\mathbf{n}_{i}\right)\mathbf{n}_{i}$

进一步可以求得曲面点：

$p^{*}(u,v)=(u,v,w)\left( \begin{matrix} \pi_{i}(\mathbf{p}(u,v))\\ \pi_{j}(\mathbf{p}(u,v))\\ \pi_{k}(\mathbf{p}(u,v)) \end{matrix} \right)$

最后，引入曲率因子 $\alpha$ ，用于在平面和曲面上进行插值。经过实验， $\alpha=0.75$ 效果最佳。

$p^{*}(u,v)=(1-\alpha)\mathbf{p}(u,v)+\alpha(u,v,w)\left( \begin{matrix} \pi_{i}(\mathbf{p}(u,v))\\ \pi_{j}(\mathbf{p}(u,v))\\ \pi_{k}(\mathbf{p}(u,v)) \end{matrix} \right)$

由于将上式展开后得到的是一个二次贝塞尔曲面，所以它不能提供拐点，但在实际应用中足以使用。



# 2 曲面细分着色器

曲面细分着色器又分为 **外壳着色器 (Hull Shader)** ，**镶嵌器阶段（Tessellation Stage)** 和 **域着色器 (Domain Shader)** 三个子阶段。下面我们一一讨论。

![[5a01668b34084b4417a94bdb1a1b21bf_MD5.jpg]]

### 外壳着色器 (Hull Shader)

外壳着色器接收顶点着色器传递的控制点数据，向镶嵌器 (tessllator) 输出**常量细分因子**，向域着色器传递经过变换和增删后的控制点数据。

![[ac3f411e4ea2eee9cd83fa9dc4da417d_MD5.jpg]]

外壳着色器实际上由两种着色器组成：常量外壳着色器和控制点外壳着色器。注意，这两个 phase 在硬件上 **并行 (parallel)** 执行。

**常量外壳着色器**

**常量外壳着色器 (constant hull shader)** **逐 patch** 调用，即每处理一个 patch 就被调用一次。它的输入是顶点着色器传递的该 patch 的控制点数据，并向镶嵌器 (tessellator) 输出**曲面细分因子 (tessellation factor)**。曲面细分因子指示在曲面细分阶段中将 patch 镶嵌处理后的份数。

下面是一个具有 3 个控制点的三角形面片示例，我们将它从各个方面均匀地镶嵌细分为 3 份。

```cs
struct PatchTess{
    float edgeTess[3] : SV_TessFactor;
    float insideTess : SV_InsideTessFactor

    // 可以在下面为每个买牛排你附加所需的额外信息 例如额外的控制点等
};

PatchTess ConstantHS(InputPatch<VertexOut, 3> patch,// 处理3个控制点的面片
    unit patchID : SV_PrimitiveID){
    PatchTess pt;

    // 将该面片从各方面均匀地镶嵌处理为3等份
    pt.edgeTess[0] = 3;// 三角形面片的左侧边缘
    pt.edgeTess[1] = 3;// 三角形面片的上侧边缘
    pt.edgeTess[2] = 3;// 三角形面片的右侧边缘
    pt.edgeTess[3] = 3;// 三角形面片的下侧边缘

    pt.insideTess = 3;// 三角形内部细分的份数

    return pt;
}
```

常量外壳着色器以面片的所有控制点作为输入，在此用 `InputPatch<VertexOut, 4>` 对此进行定义。常量外壳着色器接受的是顶点着色器传递的控制点，因此它们的类型由顶点着色器输出类型 `VertexOut` 来确定。在此例中，我们的三角形面片拥有 3 个控制点，所以就将 `InputPatch` 模板的第二个参数指定为 3. 系统还通过 `SV_PrimitiveID` 语义提供了面片的 ID 之，此 ID 值唯一地标识了绘制调用过程中的各个面片。

常量外壳着色器必须输出曲面细分因子，该因子取决于面片的拓扑结构。常量外壳着色器阶段对所有输入和输出控制点具有**只读访问权限**。另外，还可以给输出结构体添加额外的信息，例如可以指定额外的控制点等。

对 **三角形面片 (triangle patch)** 执行镶嵌化处理的过程分为两部分：

*   3 个边缘曲面细分因子控制对应边上镶嵌后的份数
*   一个内部曲面细分因子指示着三角形面片内部的镶嵌份数

对 **四边形面片 (quad patch)** 进行镶嵌化处理的过程同样分为两部分：

*   4 个边缘曲面细分因子控制着对应边缘镶嵌后的份数
*   两个内部曲面细分因子指示如何来对该四边形面片内部进行镶嵌化处理（一个指示横向维度，一个指示纵向维度）

一般硬件支持的最大曲面细分因子为 64。若指定的曲面细分因子为 0，则该 patch 将被剔除，不会送到后面的阶段。这使得我们可以在常量外壳着色器执行 **视锥体剔除** 和 **背面剔除** 等优化手段。

另外，常量着色器中定义的曲面细分因子可以是动态的，以下是一些确定镶嵌次数的常用衡量标准：根据与摄像机之间的距离；根据占用屏幕的范围；根据三角形的朝向；根据粗糙程度。在 Unity URP 包中附带了前两种的算法，我们后面再讨论。

有关细分因子如何镶嵌化 patch，我们在镶嵌化阶段进行讨论。

**控制点外壳着色器**

**控制点外壳着色器 (control point hull shader)** **逐控制点** 调用，即顶点着色器每输出一个控制点，此着色器就会被调用一次。它用来对控制点进行进一步转换，并且可以增加或减少控制点的数量。例如在 **PN 三角形** 中，可以利用控制点外壳着色器将一个 3 个控制点的三角形网格转换为具有 10 个控制点的贝塞尔曲面片。

下面是一个控制点外壳着色器仅仅充当一个简单的 **传递着色器 (pass-through shader)** 的例子，它不会对控制点进行任何的修改。

```cs
struct HullOut{
    float3 positionOS : TEXCOORD0;
}

[domain("tri")]
[partitioning("interger")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(4)]
[patchconstantfunc("ConstantHS")]
[maxtessfactor(64.0)]
HullOut HS(InputPatch<VertexOut, 3> input, // 处理3个控制点的面片
    uint controlPointId : SV_OutputControlPointID, uint patchId : SV_PrimitiveID){
    HullOut output;

    output.positionOS = input[i].positionOS;

    return output;
}
```

通过 `InputPatch` 参数可以将 patch 所有控制点都传至外壳着色器之中。系统值 `SV_OutputControlPointID` 索引的正是在被外壳着色器所处理的输出控制点。输入控制点和输出控制点数量**未必**相同。例如，可以输入 4 个控制点，输出 16 个控制点（话虽这么说，我并没找到如何在 HS 中真正意义上的衍生控制点，一般都是塞进 uniform 数据和顶点数据了）。

一个控制点外壳着色器还需要定义如下属性：

*   domain：patch 的类型。可选用的参数有 tri (三角形面片)、quad (四边形面片) 或 isoline (等值线)。
*   partitioning：曲面细分的模式。
*   interger：新顶点的添加或一处仅取决于曲面细分因子的整数部分，**向上取整**。这样一来，在网格随着曲面细分级别而改变时，会容易发生明显的突跃 (popping) 情况。
*   非整数曲面细分 (fractional_even/fractional_odd)。新顶点的添加或移除取决于曲面细分因子的整数部分，但是细微的“渐变” 调整就要根据因子的小数部分。具体见后面的图片。
*   outputpology：通过细分所创的三角形的绕序
*   triangle_cw：顺时针方向的绕序
*   triangle_ccw：逆时针方向的绕序
*   line：针对线段曲面细分
*   outputcontrolpoints：外壳着色器执行的次数，每次执行都输出 1 个控制点。系统值 `SV_OutputControlPointID` 给出的索引标明当前正在工作的外壳着色器所输出的控制点。
*   patchconstantfunc：指定常量外壳着色器函数名称的字符串。
*   maxtessfactor：告知驱动程序，用户在着色器所用的曲面细分因子的最大值。一般硬件最大值为 64。

下面进一步讨论不同的细分因子。

interger 表明边缘上的所有镶嵌段长度都相等，向上取整。

![[30fd17d818e177aba75fba36f7a7ca21_MD5.gif]]

fractional_even 表明向上取最近的偶数 n，并将整段分为 n-2 个相等长度的整数部分，和两端较短的小数部分。

![[1b9cc2e89c92b0014a8ba27a91e8dc02_MD5.gif]]

fractional_even 表明向上取最近的奇数 n，并将整段分为 n-2 个相等长度的整数部分，和两端较短的小数部分。

![[0742cd9f509d67a06a35ed4e42bd82df_MD5.gif]]

通常使用 fractional_odd 模式，因为它可以处理 1 的因数，而 fractional_even 模式则被迫使用最小级别 2。

### 镶嵌器阶段 (Tessellator Stage)

在实时渲染中，我们需要计算并创建 (多个) 三角形对真实曲面进行拟合，这个过程称为镶嵌。在运行时，表面可以被镶嵌为多个小三角形。

镶嵌器是一个**固定功能阶段**，这意味我们无法对这一阶段进行任何控制，它全权交由给硬件处理。镶嵌器阶段接收常量外壳着色器输出的曲面细分因子，对面片进行镶嵌化处理。然后，它将镶嵌后生成的顶点传递给域着色器。

对于三角形面片，常量着色器的边缘细分因子分别指示右 / 下 / 左边的段数，内部细分因子指示三角形各边中线的段数。

![[006a25fd43a2e925bcbe5478c572a470_MD5.jpg]]

对于四边形面片，常量着色器的边缘细分因子分别指示左 / 上 / 右 / 下边的段数，内部细分因子分别指示横向和纵向中线的段数。

![[6c2ff1467762965e072debc6b158739f_MD5.jpg]]

### 域着色器 (Domain Shader)

域着色器接收镶嵌器阶段输出的所有顶点与三角形和控制点外壳着色器输出的经过变换后的控制点。在**镶嵌器阶段中创建的顶点**，都会逐一调用域着色器进行后续处理。随着曲面细分功能的开启，顶点着色器便化为 “处理每个控制点的顶点着色器”，而域着色器的本质实为 “针对已经过镶嵌化的面片进行处理的顶点着色器”。特别的是，我们可以在此将经镶嵌化处理的面片顶点变换到齐次裁剪空间（如果打开几何着色器，则在几何着色器进行）。

![[138f09a14aab6998abb1cd66517b2749_MD5.jpg]]

对于三角形面片来讲，域着色器以曲面细分因子、控制点外壳着色器所输出的所有面片控制点以及镶嵌化处理后的顶点位置重心插值坐标 (u, v, w) 作为输入。是否利用这些参数坐标以及控制点来求取真正的 3D 顶点位置，完全取决于用户自己。下面代码中，根据控制点外壳着色器输出 patch 的控制点和镶嵌器提供的重心插值坐标计算当前镶嵌器阶段创建顶点的真正 3D 坐标，并变换到齐次裁剪空间中，最后将数据传输给顶点着色器。

```
struct DomainOut {
    float4  positionCS : SV_POSITION;
};

[domain("tri")]      
DomainOut DS (PatchTess patchTess, float3 bary : SV_DomainLocation, 
const OutputPatch<HullOut, 3> patch) {// 处理3个控制点的三角面片
    DomainOut output;

    float3 positionOS = patch[0].positionOS * bary.x + patch[1].positionOS * bary.y + patch[2].positionOS * bary.z; 
    output.positionCS = TransformObjectToHClip(positionOS);

    return output; 
}
```

对于四边形面片，不同地是用镶嵌化处理后的顶点位置参数坐标 (u, v) 作为输入。它的用法类似于纹理线性过滤的双线性插值。

```cs
struct DomainOut {
    float4  positionCS : SV_POSITION;
};

[domain("quad")]      
DomainOut DS (PatchTess patchTess, float3 bary : SV_DomainLocation, 
const OutputPatch<HullOut, 4> patch) {// 处理4个控制点的四边形面片
    DomainOut output;

    float3 v1 = lerp(patch[0].positionOS, patch[1].positionOS, uv.x);
    float3 v2 = lerp(patch[2].positionOS, patch[3].positionOS, uv.x);
    float positionOS = lerp(v1, v2, uv.y);
    output.positionCS = TransformObjectToHClip(positionOS);

    return output; 
}
```

### 总结

![[5a01668b34084b4417a94bdb1a1b21bf_MD5.jpg]]

曲面细分着色器分为三个子阶段，hull shader，tessellator 和 domain shader。顶点着色器将控制点输出给 hull shader，它逐控制点将变换后的控制点传递给 domain shader，逐 patch 将细分因子传递给 tessellator。Tessellator 接收 hull shader 传递的 patch 类型和曲面细分因子，将 patch 镶嵌为更多的子 patch，并将生成的顶点传递给 domain shader。domain shader 接收 hull shader 传递的控制点和细分因子，以及 tessellator 生成的顶点。tessellator 每生成一个顶点，domain shader 调用一次。domain shader 对顶点进行最终的变换，并输出给下一个阶段。

## 例子

### Flat Tessellation

![[ac072547df6ee35fe438829e694870a5_MD5.gif]]

下面，使用最基础的曲面细分着色器为例子。它仅仅在曲面细分着色器中对 patch 进行镶嵌化，其他着色器多充当传递着色器的作用。另外，为了观察具体的细分，加入 Geometry Shader 进行三角形描边，具体算法参考 [catlikecoding](https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading/)。

主要代码如下：

```c
// 顶点着色器：接收IA控制点数据，向Hull Shader传递控制点数据
VertexOut FlatTessellationPassVertex(Attributes input) {
    VertexOut output;

    output.positionOS = input.positionOS;

    return output;
}

// Constant Hull Shader：接收顶点着色器传递的patch，向Tessellator传递细分因子
PatchTess FlatTessellationPassConstantHull(InputPatch<VertexOut, 3> patch, uint patchID : SV_PrimitiveID) {
    PatchTess pt;

    pt.edgeTess[0] = _TessFactor.x;
    pt.edgeTess[1] = _TessFactor.y;
    pt.edgeTess[2] = _TessFactor.z;
    pt.insideFactor = _TessFactor.w;

    return pt;
}

[domain("tri")]
#if defined(_PARTITIONING_INTERGER)
[partitioning("integer")]// 整数分割 向上取整
#elif defined(_PARTITIONING_FRACTIONAL_ODD)
[partitioning("fractional_odd")]// 奇数分割
#elif defined(_PARTITIONING_FRACTIONAL_EVEN)
[partitioning("fractional_even")]// 偶数分割
#else
[partitioning("integer")]// 整数分割 向上取整
#endif
#if defined(_ORDER_CW)
[outputtopology("triangle_cw")]
#elif defined(_ORDER_CWW)
[outputtopology("triangle_ccw")]
#else
[outputtopology("triangle_cw")]
#endif
[patchconstantfunc("FlatTessellationPassConstantHull")]
[outputcontrolpoints(3)]
[maxtessfactor(64.0)]
// Control Point Hull Shader：接收顶点着色器传递的控制点，对控制点进行变换后输出给Domain Shader
HullOut FlatTessellationPassHull(InputPatch<VertexOut, 3> patch, uint id : SV_OutputControlPointID) {
    HullOut output;

    output.positionOS = patch[id].positionOS;

    return output;
}

// Domain Shader：接收Tessellator镶嵌化后的patch和常量外壳着色器输出的细分因子，将曲面顶点传递给下个阶段
[domain("tri")]
DomainOut FlatTessellationPassDomain(PatchTess patchTess, float3 bary : SV_DomainLocation, OutputPatch<HullOut, 3> patch) {
    DomainOut output;
    output.positionOS = patch[0].positionOS * bary.x + patch[1].positionOS * bary.y + patch[2].positionOS * bary.z;

    return output;
}
```

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/FlatTessellation)

Flat Tessellation 通常与位移贴图一起使用，具体教程可以参考 [catlikecoding](https://catlikecoding.com/unity/tutorials/advanced-rendering/surface-displacement/)。

![[9dd32c104b85ad147693b2457172acdd_MD5.jpg]]

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/Displacement)

### 三次贝塞尔曲面

![[398d8ae3f47d9b72c266039d4749e90e_MD5.gif]]

下面通过贝塞尔曲面的例子来理解控制点与曲面的作用，并为后面的 Phong Tessellation 铺垫。有关贝塞尔曲面的详细几何计算，可以参考我的文章：

[TheTus：计算机图形学：曲线与曲面](https://zhuanlan.zhihu.com/p/629202115)

首先，我们需要在 CPU 端通过 C# 脚本向 Shader 传递控制点数据。由于 Unity 支持的图元拓扑类型仅仅只有点、线、三角形和四边形，我们无法直接创建控制点类型的图元拓扑。所以这里采用创建一个 4 控制点 quad 的图元，然后将剩余控制点通过 uniform 数组的方式传递给 GPU。 C# 脚本：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/blob/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Scripts/BezierGenerator.cs)

在顶点着色器中，我们仅仅将 quad 的控制点传给 Hull Shader。

```
// Vertex Shader：将quad的4个control point传给Hull Shader
VertexOut QuadTessPassVertex(Attributes input) {
    VertexOut output;

    output.positionOS = input.positionOS;

    return output;
}
```

在 Hull Shader 中，Constant Hull Shader 定义细分因子，Control Point Hull Shader 仅仅传递 quad 的控制点。注意，这里并没有在 control point hull shader 里创建额外的控制点，因为它被存在全局数组里供 Domain Shader 使用。

```
// Constant Hull Shader: 定义quad的细分因子，传递给Tessellator
PatchTess QuadTessPassConstantHull(InputPatch<VertexOut, 4> patch, uint patchID : SV_PrimitiveID) {
    PatchTess pt;

    // Uniform Tessellation
    pt.edgeTess[0] = _EdgeTess;
    pt.edgeTess[1] = _EdgeTess;
    pt.edgeTess[2] = _EdgeTess;
    pt.edgeTess[3] = _EdgeTess;

    pt.insideTess[0] = _InsideTess;
    pt.insideTess[1] = _InsideTess;

    return pt;
}

// Control Point Hull Shader: 仅传递Vertex Shader传递的quad的control point给Tessellator
[domain("quad")]
[partitioning("fractional_even")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(4)]
[patchconstantfunc("QuadTessPassConstantHull")]
[maxtessfactor(64.0f)]
HullOut QuadTessPassHull(InputPatch<VertexOut, 4> patch, uint id : SV_OutputControlPointID) {
    HullOut output;

    output.positionOS = patch[id].positionOS;

    return output;
}
```

在域着色器中，我们用矩阵形式表示三次伯恩斯坦系数，然后用这些系数和控制点的方程计算出 Hull Shader 传递的该 quad 顶点的在曲面上的坐标。偏导数同理，法线由两个偏导数叉乘得到。

```
// 计算伯恩斯坦基函数的4个系数（三阶）
float4 BernsteinBasis(float t) {
    float invT = 1.0f - t;

    return float4(invT * invT * invT,
                  3.0f * t * invT * invT,
                  3.0f * t * t * invT,
                  t * t * t);
}

// 通过伯恩斯坦系数计算控制点坐标
float3 CubicBezierSum(float4 basisU, float4 basisV) {
    float3 sum = float3(0.0f, 0.0f, 0.0f);
    sum = basisV.x * (basisU.x * _ControlPoints[0] + basisU.y * _ControlPoints[1] + basisU.z * _ControlPoints[2] + basisU.w * _ControlPoints[3]);
    sum += basisV.y * (basisU.x * _ControlPoints[4] + basisU.y * _ControlPoints[5] + basisU.z * _ControlPoints[6] + basisU.w * _ControlPoints[7]);
    sum += basisV.z * (basisU.x * _ControlPoints[8] + basisU.y * _ControlPoints[9] + basisU.z * _ControlPoints[10] + basisU.w * _ControlPoints[11]);
    sum += basisV.w * (basisU.x * _ControlPoints[12] + basisU.y * _ControlPoints[13] + basisU.z * _ControlPoints[14] + basisU.w * _ControlPoints[15]);

    return sum;
}

// 计算贝塞尔系数的导系数
float4 dBernsteinBasis(float t) {
    float invT = 1.0f - t;

    return float4(-3 * invT * invT,
                  3 * invT * invT - 6 * t * invT,
                  6 * t * invT - 3 * t * t,
                  3 * t * t);
}

// Domain Shader: 逐patch处理Tessllator传递的细分后的patch顶点
// 对于quad 输入的是uv坐标(顶点patch位置uv，而非纹理uv)
[domain("quad")]
DomainOut QuadTessPassDomain(PatchTess patchTess, float2 uv : SV_DomainLocation, const OutputPatch<HullOut, 4> patch) {
    DomainOut output;

    // 由于uv in [0, 1]线性，刚好对应Bezier Curve的t，所以直接将uv带进Bernstein公式得到两轴系数，然后再将系数组合为Bezier Curved Surfaces

    // 计算曲面点坐标
    float4 basisU = BernsteinBasis(uv.x);
    float4 basisV = BernsteinBasis(uv.y);
    float3 positionOS = CubicBezierSum(basisU, basisV);

    // 计算曲面点偏导
    float4 dBasisU = dBernsteinBasis(uv.x);
    float4 dBasisV = dBernsteinBasis(uv.y);
    float3 dPu = CubicBezierSum(dBasisU, basisV);
    float3 dPv = CubicBezierSum(basisU, dBasisV);

    output.positionOS = positionOS;
    output.normalOS = cross(dPu, dPv);

    return output;
}
```

由于打开几何着色器进行描边，所以顶点变换齐次裁剪空间在几何着色器中进行。片元着色器负责光照计算。

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/Bezier)

### Phong Tessellation

![[40a16f1e5fb8d7a945ab7487c9ec4d97_MD5.gif]]

下面通过 Phong Tessellation 的例子进一步理解如何在域着色器中应用控制点计算曲面顶点。

Phong Tessellation 用来平滑 Phong Shading 的着色结果，减少 artifaction。并且尽可能少的生成额外三角形，以减少消耗。

![[b27a0dffbe47447fcb52d15cc6f22337_MD5.jpg]]

有关 Phong Tessellation 的详细几何计算，可以参考我的文章：

[TheTus：计算机图形学：曲线与曲面](https://zhuanlan.zhihu.com/p/629202115)

顶点着色器依然充当传递着色器：

```
VertexOut PhongTessellationPassVertex(Attributes input) {
    VertexOut output;

    output.positionOS = input.positionOS;
    output.normalOS = input.normalOS;

    return output;
}
```

在 Hull Shader 中，Constant Hull Shader 定义细分因子，Control Point Hull Shader 仅仅传递 quad 的控制点。

```
PatchTess PhongTessellationPassConstantHull(InputPatch<VertexOut, 3> patch, uint patchID : SV_PrimitiveID) {
    PatchTess pt;

    pt.edgeTess[0] = _TessFactor.x;
    pt.edgeTess[1] = _TessFactor.y;
    pt.edgeTess[2] = _TessFactor.z;
    pt.insideFactor = _TessFactor.w;

    return pt;
}

[domain("tri")]
[partitioning("integer")]
[outputtopology("triangle_cw")]
[patchconstantfunc("PhongTessellationPassConstantHull")]
[outputcontrolpoints(3)]
[maxtessfactor(64.0)]
HullOut PhongTessellationPassHull(InputPatch<VertexOut, 3> patch, uint id : SV_OutputControlPointID) {
    HullOut output;

    output.positionOS = patch[id].positionOS;
    output.normalOS = patch[id].normalOS;

    return output;
}
```

在域着色器中，我们将三角形的三个控制点分别投影到对应法线定义的切线空间中，再对投影点进行重心坐标插值计算得到曲面上的点。

投影公式如下：

$\pi_{i}(\mathbf{p})=\mathbf{p}-\left((\mathbf{p}-\mathbf{v}_{i})^{T}\mathbf{n}_{i}\right)\mathbf{n}_{i}$

曲面坐标计算方程如下：

$p^{*}(u,v)=(1-\alpha)\mathbf{p}(u,v)+\alpha(u,v,w)\left( \begin{matrix} \pi_{i}(\mathbf{p}(u,v))\\ \pi_{j}(\mathbf{p}(u,v))\\ \pi_{k}(\mathbf{p}(u,v)) \end{matrix} \right)$

```
#define DOMAIN_PROGRAM_INTERPOLATE(fieldName) \
patch[0].fieldName * bary.x + \
patch[1].fieldName * bary.y + \
patch[2].fieldName * bary.z;

// 计算三角形点Q投影到顶点vi切线平面P的点Q'
float3 PhongProjectedPosition(float3 position, float3 triVertexPosition, float3 normal) {
    return position - dot(position - triVertexPosition, normal) * normal;
}

// 计算应用Phong Tessellation后点p的位置
// 所有点应在同一空间
float3 CalculatePhongPosition(float3 position, float3 p0Position, float3 p0Normal, float3 p1Position, float3 p1Normal, float3 p2Position, float3 p2Normal, float3 bary, float smoothing = 0.75) {
    float3 output = bary.x * PhongProjectedPosition(position, p0Position, p0Normal) +
        bary.y * PhongProjectedPosition(position, p1Position, p1Normal) +
        bary.z * PhongProjectedPosition(position, p2Position, p2Normal);
    return lerp(position, output, smoothing);
}

[domain("tri")]
DomainOut PhongTessellationPassDomain(PatchTess patchTess, float3 bary : SV_DomainLocation, OutputPatch<HullOut, 3> patch) {
    DomainOut output;

    float3 positionOS = DOMAIN_PROGRAM_INTERPOLATE(positionOS);

    output.positionOS = CalculatePhongPosition(positionOS, patch[0].positionOS, patch[0].normalOS, patch[1].positionOS, patch[1].normalOS, patch[2].positionOS, patch[2].normalOS, bary, _Smoothing);

    return output;
}
```

顶点转化到齐次裁剪空间同样在几何着色器中完成。

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/PhongTessellation)

在此基础上，加上光照。

![[f1770435e5721bbd3503b3c573dc40bb_MD5.gif]]

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/PhongTessellationLighting)

由于 Phong Tessellation 基于二次贝塞尔三角形，无法提供拐点，所以效果于 PN Triangles 较差。并且，它只保证 C0 连续性，对于硬边过渡可能产生裂缝。一种简单解决方法是利用顶点色等遮罩判断某顶点是否需要进行 Phong Tessellation。

### PN Triangles

![[37b91f2e2a14508f43f5d4fbfc7b1c2d_MD5.gif]]

在之前的例子中，control point hull shader 都仅仅充当传递着色器。下面，我们通过 PN Triangles 的例子说明在 hull shader 中计算并添加控制点。

PN Triangles 与 Phong Tessellation 类似，但它基于三次贝塞尔三角形，所以能提供更精细的曲面。

![[f709f22cd4bb8a1213101237d27f806d_MD5.jpg]]

关于 PN Triangles 详细的几何计算，可以参考我的文章：

[TheTus：计算机图形学：曲线与曲面](https://zhuanlan.zhihu.com/p/629202115)

顶点着色器依旧充当控制点的传递着色器。

```
VertexOut PNTrianglesPassVertex(Attributes input) {
    VertexOut output;

    output.positionOS = input.positionOS;
    output.normalOS = input.normalOS;

    return output;
}
```

Conostant Hull Shader 传递曲面细分因子。一种做法是在 constant hull shader 的输出结构体中存储额外控制点，但我们这里选择在 control point hull shader 里进行。

```
PatchTess PNTrianglesPassConstantHull(InputPatch<VertexOut, 3> patch, uint patchID : SV_PrimitiveID) {
    PatchTess pt;

    pt.edgeTess[0] = _TessFactor.x;
    pt.edgeTess[1] = _TessFactor.y;
    pt.edgeTess[2] = _TessFactor.z;
    pt.insideFactor = _TessFactor.w;

    return pt;
}
```

在 control point hull shader 中，我们需要计算额外的 6 个控制点坐标 (中心控制点可以由其他 9 个控制点计算出来)。对于每个 patch 的输出结构体，我们按照顺时针绕序添加两个控制点。将其带入投影公式即可。对于法线同理。（这部分原理描述起来有点麻烦，建议看我给出的链接）

![[55ef26192fffd9be03fa14cac486ef58_MD5.jpg]]

顶点投影公式如下：

$\mathbf{p}_{210}={\frac{1}{3}}(2{\bf p}_{300}+{\bf p_{030}}-({\bf n}_{200}\cdot({\bf p}_{030}-{\bf p}_{300})){\bf n}_{200}).$

法线投影公式如下：

${\bf n}_{110}={\bf n}_{200}+{\bf n}_{020}-2{\frac{({\bf p}_{030}-{\bf p}_{300})\cdot({\bf n}_{200}+{\bf n}_{020})}{({\bf p}_{030}-{\bf p}_{300})\cdot({\bf p}_{030}-{\bf p}_{300})}}({\bf p}_{030}-{\bf p}_{300}).$

```
// 计算cubic bezier (p0, p1)的第一个控制点
float3 CalculateCubicBezierControlPoint(float3 p0, float3 p1, float3 n0) {
    return (2.0 * p0 + p1 - dot(n0, p1 - p0) * n0) / 3.0;
}

// 计算quadratic bezier (p0, p1)的控制点
float3 CalculateQuadraticBezierControlNormal(float3 n0, float3 n1, float3 p0, float3 p1) {
    float3 d = p1 - p0;
    float v = 2.0 * dot(d, n0 + n1) / dot(d, d);
    return normalize(n0 + n1 - v * d);
}

[domain("tri")]
[partitioning("integer")] // 整数分割 向上取整
[outputtopology("triangle_cw")]
[patchconstantfunc("PNTrianglesPassConstantHull")]
[outputcontrolpoints(3)]
[maxtessfactor(64.0)]
HullOut PNTrianglesPassHull(InputPatch<VertexOut, 3> patch, uint id : SV_OutputControlPointID) {
    HullOut output;

    output.positionOS = patch[id].positionOS;
    output.normalOS = patch[id].normalOS;

    // 计算两控制点坐标 在Constant Hull Shader里进行也可以
    // 计算邻接顶点patchId
    const uint adjVertexId = id < 2 ? id + 1 : 0;
    output.positionOS0 = CalculateCubicBezierControlPoint(patch[id].positionOS, patch[adjVertexId].positionOS, patch[id].normalOS);
    output.positionOS1 = CalculateCubicBezierControlPoint(patch[adjVertexId].positionOS, patch[id].positionOS, patch[adjVertexId].normalOS);
    output.normalOS0 = CalculateQuadraticBezierControlNormal(patch[id].normalOS, patch[adjVertexId].normalOS, patch[id].positionOS, patch[adjVertexId].positionOS);

    return output;
}
```

在域着色器中，我们先计算出中心控制点的坐标，然后将这 10 个控制点带入曲面方程计算镶嵌器传递的该 patch 顶点的真正曲面位置。对于法线同理。

中心控制点坐标计算公式如下：

$\mathbf{p}_{111}=\frac{1}{4}(\mathbf{p}_{210}+\mathbf{p}_{120}+\mathbf{p}_{102}+\mathbf{p}_{201}+\mathbf{p}_{021}+\mathbf{p}_{012})-\frac{1}{6}(\mathbf{p}_{300}+\mathbf{p}_{030}+\mathbf{p}_{003})$

三次 (cubic) 贝塞尔三角曲面公式如下：

$\begin{align} {\bf p}(u,v)&=\sum_{i+j+k=3}B_{i j k}^{3}(u,v){\bf p}_{i j k}\\ &=u^{3}{\bf p}_{300}+v^{3}{\bf p}_{030}+w^{3}{\bf p}_{003}+3u^{2}v{\bf p}_{210}+3u^{2}w{\bf p}_{201} \\ &+3u v^{2}{\bf p}_{120}+3v^{2}w{\bf p}_{021}+3v w^{2}{\bf p}_{012}+3u w^{2}{\bf p}_{102}+6u v w{\bf p}_{111}. \end{align}$

二次 (quadratic) 贝塞尔曲面公式如下：

$\begin{align} \mathbf{n}(u,v)&=\sum_{i+j+k=2}B_{i j k}^{2}(u,v)\mathbf{n}_{i j k}\\ &=u^{2}{\bf n}_{200}+v^{2}{\bf n}_{020}+w^{2}{\bf n}_{002}+2(u v{\bf n}_{110}+u w{\bf n}_{101}+v w{\bf n}_{011}). \end{align}$

```
// 根据重心坐标计算 三次贝塞尔三角patch顶点 注意向量应在同一空间
float3 CalculateCubicBezierPosition(float3 controlPoints[10], float3 bary, float smoothing = 0.75) {
    float3 flatSurfacePosition = bary.x * controlPoints[0] + bary.y * controlPoints[3] + bary.z * controlPoints[6];
    float3 bezierSurfacePosition =
        bary.x * bary.x * bary.x * controlPoints[0] + 3.0 * bary.x * bary.x * bary.y * controlPoints[1] + 3.0 * bary.x * bary.y * bary.y * controlPoints[2] +
        bary.y * bary.y * bary.y * controlPoints[3] + 3.0 * bary.y * bary.y * bary.z * controlPoints[4] + 3.0 * bary.y * bary.z * bary.z * controlPoints[5] +
        bary.z * bary.z * bary.z * controlPoints[6] + 3.0 * bary.x * bary.z * bary.z * controlPoints[7] + 3.0 * bary.x * bary.x * bary.z * controlPoints[8] +
        6.0 * bary.x * bary.y * bary.z * controlPoints[9];

    return lerp(flatSurfacePosition, bezierSurfacePosition, smoothing);
}

// 根据重心坐标计算 二次贝塞尔三角patch法线 注意向量应在同一空间
float3 CalculateQuadraticBezierNormal(float3 controlPoints[6], float3 bary, float smoothing = 0.75) {
    float3 flatSurfaceNormal = bary.x * controlPoints[0] + bary.y * controlPoints[2] + bary.z * controlPoints[4];
    float3 bezierSurfaceNormal =
        bary.x * bary.x * controlPoints[0] + 2.0 * bary.x * bary.y * controlPoints[1] +
        bary.y * bary.y * controlPoints[2] + 2.0 * bary.y * bary.z * controlPoints[3] +
        bary.z * bary.z * controlPoints[4] + 2.0 * bary.x * bary.z * controlPoints[5];
    return normalize(lerp(flatSurfaceNormal, bezierSurfaceNormal, smoothing));
}

// 计算二次贝塞尔插值后的切线
float3 CalculateTangentAfterQuadraticBezier(float3 t0, float3 t1, float3 t2, float3 flatSurfaceNormal, float3 bezierSurfaceNormal, float3 bary) {
    float3 flatSurfaceTangent = bary.x * t0 + bary.y * t1 + bary.z * t2;
    float3 flatBitangent = cross(flatSurfaceNormal, flatSurfaceTangent);
    return normalize(cross(flatBitangent, bezierSurfaceNormal));
}

[domain("tri")]
DomainOut PNTrianglesPassDomain(PatchTess patchTess, float3 bary : SV_DomainLocation, OutputPatch<HullOut, 3> patch) {
    DomainOut output;

    // 计算cubic triangle bezier patch position
    // 计算控制点位置
    float3 controlPoints[10];
    float3 avgBezier = 0.0, avgVertices = 0.0;
    // 让编译器将循环展开
    UNITY_UNROLL
    for (int i = 0; i < 3; i++) {
        controlPoints[i * 3] = patch[i].positionOS;
        controlPoints[i * 3 + 1] = patch[i].positionOS0;
        controlPoints[i * 3 + 2] = patch[i].positionOS1;
        avgBezier += patch[i].positionOS0 + patch[i].positionOS1;
        avgVertices += patch[i].positionOS;
    }
    avgBezier /= 6.0;
    avgVertices /= 3.0;
    controlPoints[9] = avgBezier + (avgBezier - avgVertices) * 0.5;

    // 计算quadratic bezier patch normal
    // 计算控制点位置
    float3 controlNormals[6];
    UNITY_UNROLL
    for (int i = 0; i < 3; i ++) {
        controlNormals[i * 2] = patch[i].normalOS;
        controlNormals[i * 2 + 1] = patch[i].normalOS0;
    }

    // 计算贝塞尔点
    output.positionOS = CalculateCubicBezierPosition(controlPoints, bary, _Smoothing);
    output.normalOS = CalculateQuadraticBezierNormal(controlNormals, bary, _Smoothing);

    return output;
}
```

顶点变换到齐次裁剪空间同样在几何着色器里进行。

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/PN%20Triangles)

在这个基础上，加上光照。可以发现效果还是挺明显的。

![[325340e8ad9bd806fc9572db6f5db12b_MD5.gif]]

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/PNTrianglesLighting)

## 优化手段

### 动态细分因子

曲面细分阶段的一个重要应用就是进行 LOD，从而减少远处物体不必要的细节渲染。

下面将讨论两种动态细分因子的方法，一种基于相机距离，一种基于屏幕占用范围。它们的代码可以在 URP 库的 [Tessellation.hlsl](https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl) 中找到。

**基于相机距离**

![[e98e2e9917477d4bac1b0da1d5ed5369_MD5.gif]]

基于相机距离即离相机仅细分因子大，离相机远细分因子小。在 `Tessellation.hlsl` 中，提供了一个 `GetDistanceBasedTessFactor` 用来根据相机距离输出细分因子，具体代码如下：

```
real3 GetDistanceBasedTessFactor(real3 p0, real3 p1, real3 p2, real3 cameraPosWS, real tessMinDist, real tessMaxDist) {
    real3 edgePosition0 = 0.5 * (p1 + p2);
    real3 edgePosition1 = 0.5 * (p0 + p2);
    real3 edgePosition2 = 0.5 * (p0 + p1);

    // In case camera-relative rendering is enabled, 'cameraPosWS' is statically known to be 0,
    // so the compiler will be able to optimize distance() to length().
    real dist0 = distance(edgePosition0, cameraPosWS);
    real dist1 = distance(edgePosition1, cameraPosWS);
    real dist2 = distance(edgePosition2, cameraPosWS);

    // The saturate will handle the produced NaN in case min == max
    real fadeDist = tessMaxDist - tessMinDist;
    real3 tessFactor;
    tessFactor.x = saturate(1.0 - (dist0 - tessMinDist) / fadeDist);
    tessFactor.y = saturate(1.0 - (dist1 - tessMinDist) / fadeDist);
    tessFactor.z = saturate(1.0 - (dist2 - tessMinDist) / fadeDist);

    return tessFactor;
}
```

在代码中，首先计算每条边中点与相机距离，然后根据相机距离，将细分因子从 tessMinDist 的 1 逐渐缩减到 tessMaxDist 的 0。

并且提供了一个 `CalcTriTessFactorsFromEdgeTessFactors` 函数用来根据边缘细分因子平均加权得到内部细分因子。

```
real4 CalcTriTessFactorsFromEdgeTessFactors(real3 triVertexFactors) {
    real4 tess;
    tess.x = triVertexFactors.x;
    tess.y = triVertexFactors.y;
    tess.z = triVertexFactors.z;
    tess.w = (triVertexFactors.x + triVertexFactors.y + triVertexFactors.z) / 3.0;

    return tess;
}
```

在我们的 Shader 中，应用这些函数。

```
PatchTess DynamicTessellationFactorsPassConstantHull(InputPatch<VertexOut, 3> patch, uint patchID : SV_PrimitiveID) {
    PatchTess pt;
    float4 tessFactors = _TessFactor;
 #if defined(_DYNAMIC_CAMERA)
    float3 cameraPositionWS = GetCameraPositionWS();
    real3 distanceBasedTessFactor = GetDistanceBasedTessFactor(patch[0].positionWS, patch[1].positionWS, patch[2].positionWS, cameraPositionWS, _TessMinDist, _TessMinDist + _TessFadeDist);
    tessFactors = _TessFactor * CalcTriTessFactorsFromEdgeTessFactors(distanceBasedTessFactor);
    pt.edgeTess[0] = max(1.0, tessFactors.x);
    pt.edgeTess[1] = max(1.0, tessFactors.y);
    pt.edgeTess[2] = max(1.0, tessFactors.z);
    pt.insideFactor = max(1.0, tessFactors.w);
 #endif

    pt.edgeTess[0] = max(1.0, tessFactors.x);
    pt.edgeTess[1] = max(1.0, tessFactors.y);
    pt.edgeTess[2] = max(1.0, tessFactors.z);
    pt.insideFactor = max(1.0, tessFactors.w);

    return pt;
}
```

**基于屏幕占用范围**

![[4169546c7a873339697b8e767f3c5789_MD5.gif]]

基于屏幕占用范围的想法是获取屏幕上每边的长度，如果长度小于设定的 triangleSize，则细分因子进行衰减。

在 `Tessellation.hlsl` 中，提供了一个 `GetScreenSpaceTessFactor` 用于计算基于屏幕占用范围的细分因子。

```
// Compute both screen and distance based adaptation - return factor between 0 and 1
real3 GetScreenSpaceTessFactor(real3 p0, real3 p1, real3 p2, real4x4 viewProjectionMatrix, real4 screenSize, real triangleSize)
{
    // Get screen space adaptive scale factor
    real2 edgeScreenPosition0 = ComputeNormalizedDeviceCoordinates(p0, viewProjectionMatrix) * screenSize.xy;
    real2 edgeScreenPosition1 = ComputeNormalizedDeviceCoordinates(p1, viewProjectionMatrix) * screenSize.xy;
    real2 edgeScreenPosition2 = ComputeNormalizedDeviceCoordinates(p2, viewProjectionMatrix) * screenSize.xy;

    real EdgeScale = 1.0 / triangleSize; // Edge size in reality, but name is simpler
    real3 tessFactor;
    tessFactor.x = saturate(distance(edgeScreenPosition1, edgeScreenPosition2) * EdgeScale);
    tessFactor.y = saturate(distance(edgeScreenPosition0, edgeScreenPosition2) * EdgeScale);
    tessFactor.z = saturate(distance(edgeScreenPosition0, edgeScreenPosition1) * EdgeScale);

    return tessFactor;
}
```

它通过 `ComputeNormalizedDeviceCoordinates` 计算得到顶点 screen space 坐标，然后乘以屏幕尺寸得到 window space 坐标。最后，根据三角形长度对屏幕顶点长度进行缩放得到细分因子。

在我们的 Shader 中，应用这些函数。

```
PatchTess DynamicTessellationFactorsPassConstantHull(InputPatch<VertexOut, 3> patch, uint patchID : SV_PrimitiveID) {
    PatchTess pt;
    float4 tessFactors = _TessFactor;
 #if defined(_DYNAMIC_SCREEN)
    real3 screenSpaceTessFactor = GetScreenSpaceTessFactor(patch[0].positionWS, patch[1].positionWS, patch[2].positionWS, GetWorldToHClipMatrix(), _ScreenParams, _TriangleSize);
    tessFactors = _TessFactor * CalcTriTessFactorsFromEdgeTessFactors(screenSpaceTessFactor);
 #endif

    pt.edgeTess[0] = max(1.0, tessFactors.x);
    pt.edgeTess[1] = max(1.0, tessFactors.y);
    pt.edgeTess[2] = max(1.0, tessFactors.z);
    pt.insideFactor = max(1.0, tessFactors.w);

    return pt;
}
```

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/DynamicTessellationFactors)

### patch 剔除

我们可以通过在 constant hull shader 中指定细分因子为 0，将该 patch 剔除，进而不送到后面的阶段。这使得我们可以在常量外壳着色器执行 **视锥体剔除** 和 **背面剔除** 等优化手段。

我们首先进行视锥体剔除，这意味着我们不会看见视锥体外的三角形。为了实现这一点，我们可以使用三角形顶点的齐次裁剪空间位置。

如果某点向量与视锥体某平面的点积为负数，则说明它在这个平面的外部。如果该点向量在所有平面外部，则说明它在视锥体外部。引入 bias 调整容忍度。

```
bool TriangleIsBelowClipPlane(float3 p0, float3 p1, float3 p2, int planeIndex, float bias) {
    float4 plane = unity_CameraWorldClipPlanes[planeIndex];
    // 结果为负，则在平面外部
    return dot(float4(p0, 1), plane) < bias && dot(float4(p1, 1), plane) < bias && dot(float4(p2, 1), plane) < bias;
}
```

我们只需要对所有视锥体平面进行判断并取或即可。

然后进行背面剔除，它是根据三角形 **绕序 (winding order)** 进行判断的。假定顺时针为正方向，那么绕序为逆时针的就是背面。这可以通过三角形两边向量的叉乘进行判断。引入 bias 调整容忍度。

```
bool TriangleIsBackFace(float4 p0CS, float4 p1CS, float4 p2CS, float bias) {
    float3 p0 = p0CS.xyz / p0CS.w;
    float3 p1 = p1CS.xyz / p1CS.w;
    float3 p2 = p2CS.xyz / p2CS.w;
    #if UNITY_REVERSED_Z
    return cross(p1 - p0, p2 - p0).z < bias;
    #else
        return cross(p1 - p0, p2-p0).z > -bias;
    #endif
}
```

将这两个判断杂交在一起，判断某三角形是否需要进行剔除。

```
// 根据视锥平面进行剔除
bool TriangleIsCulled(float3 p0WS, float3 p1WS, float3 p2WS, float bias) {
    float4 p0CS = TransformWorldToHClip(p0WS);
    float4 p1CS = TransformWorldToHClip(p1WS);
    float4 p2CS = TransformWorldToHClip(p2WS);
    return TriangleIsBackFace(p0CS, p1CS, p2CS, bias) ||
        TriangleIsBelowClipPlane(p0WS, p1WS, p2WS, 0, bias) ||
        TriangleIsBelowClipPlane(p0WS, p1WS, p2WS, 1, bias) ||
        TriangleIsBelowClipPlane(p0WS, p1WS, p2WS, 2, bias) ||
        TriangleIsBelowClipPlane(p0WS, p1WS, p2WS, 3, bias);
}
```

最后，在 constant hull shader 中判断是否需要剔除三角形，如果需要剔除则将细分因子设为 0，否则进行正常的细分因子传递。

```
// 常量外壳着色器，传递细分因子
PatchTess DisplacementPassConstantHull(InputPatch<VertexOut, 3> patch, uint patchID : SV_PrimitiveID) {
    PatchTess pt;

    float3 p0 = TransformObjectToWorld(patch[0].positionOS);
    float3 p1 = TransformObjectToWorld(patch[1].positionOS);
    float3 p2 = TransformObjectToWorld(patch[2].positionOS);
    float bias = -0.5 * _DisStrength;
    // 判断是否要剔除三角形
    if (TriangleIsCulled(p0, p1, p2, bias)) {
        pt.edgeTess[0] = pt.edgeTess[1] = pt.edgeTess[2] = pt.insideTess = 0;
    }
    else {
        pt.edgeTess[0] = TessellationEdgeFactor(p1, p2);
        pt.edgeTess[1] = TessellationEdgeFactor(p2, p0);
        pt.edgeTess[2] = TessellationEdgeFactor(p0, p1);
        // 编译器优化
        pt.insideTess = (TessellationEdgeFactor(p1, p2) + TessellationEdgeFactor(p2, p0) + TessellationEdgeFactor(p0, p1)) * 0.333;
    }

    return pt;
}
```

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/TessellationShaders/Displacement)

# 3 几何着色器

## 概述

在顶点着色器和片元着色器之间有一个可选的**几何着色器 (geometry shader)** 阶段。几何着色器可以将输入图元转换为其他图元，这是曲面细分等阶段无法做到的。几何着色器在输入的几何图元 (如点、线段、三角形) 级别上进行操作，并根据需要生成零个、一个或多个输出的新的几何图元。这使得在几何着色器阶段可以实现诸如几何图元的细分、几何的放大缩小、草地生成、粒子系统等各种复杂的效果。

几何着色器的输入是完整的图元，输出是新的图元。例如，如果要绘制一个三角形列表 (triangle list)，则几何着色器程序实际将对列表中的每个三角形 T 执行下列操作：

```c
for(UINT i = 0; i < numTriagnles; ++i){
    OutputPrimitiveList = GeometryShader(T[i].vertexList);
}
```

**几何着色器保证按照输入的相同顺序输出图元的结果，这很影响性能，因为结果必须保存和排序。同时，它又是完全可编程的。所以通常很少使用，因为它不能很好体现 GPU 优势。在移动设备上，甚至会被阻止。**

不同 API 的几何着色器写法各不同，Unity 与 DirectX 的类似，所以这里更多讨论 hlsl 几何着色器在 Unity 里的写法。并且简单给出几个 Unity 几何着色器的例子，当然不会涉及到什么更炫酷的效果，这些在网上也能搜到。

## 图元拓扑类型

在应用阶段，CPU 需要向 GPU 提交一系列数据和命令供其渲染。  
应用阶段最重要的任务是**输入装配 (input assembler)**。输入装配阶段会从显存中读取几何数据 (顶点和索引)，再将它装配为**几何图元 (geometry primitive)**。  
可是，单凭顶点和索引数据，GPU 无法知道顶点究竟如何组成几何图元。例如，我们应将顶点 2 个一组解释成线段，还是 3 个一组解释为三角形呢？对此，我们需要通过指定**图元拓扑 (primitive topology)** 来告诉 GPU 如何利用顶点数据来表示几何图元。

在 DirectX 中，基础图元拓扑类型有以下五种：**点列表 (point list)**，**线条带 (line strip)**，**线列表 (line list)**，**三角形带 (triangle strip)**，**三角形列表 (triangle list)**。  
在 DirectX 10 以后的版本中，加入了一种**邻接图元 (primitive adjacency)** 类型。任何基础图元类型都可以扩展成邻接图元版本。  
各种图元拓扑类型如下图，可以先只关注实线顶点，并且注意所有三角类型的顶点都是相同的。

![[c9142dfe823e9050ce5108e9c46866ad_MD5.jpg]]

上图中各符号意义如下表所示。

![[1666bcb6d044ca030bfdb440a218ef6d_MD5.jpg]]

我们可以将拓扑类型简单分类。  
根据图元的类型，我们可以将其分为点、线和三角形。而根据连接方式，我们可以将其分为列表 (list) 和带 (strip)。  
列表类型指的是孤立图元类型的列表。对于三角形列表而言，我们可以将输入顶点序列每三个一组组成一个三角形。例如，对于输入顶点序列 012345，我们可以组成两个三角形：[0, 1, 2] 和 [3, 4, 5]。线列表的处理方式类似。  
带类型指的是一系列相连的图元类型。对于三角形带而言，当我们输入一个三角形后，在绘制完第一个三角形后，每个后续顶点都将会与上一个三角形的边相连，生成另一个三角形。我们可以使用一个长度为 3 的窗口在输入顶点序列中滑动，观察每个生成的三角形。例如，对于输入序列 012345，生成的三角形序列如下：[0, 1, 2], 3, 4, 5; 0, [1, 2, 3], 4, 5; 0, 1, [2, 3, 4], 5; 0, 1, 2, [3, 4, 5]。线条带的处理方式类似。

大多数场景中物体的图元拓扑类型都是三角形带，因为 N 个顶点序列就可以表示 N-2 个三角形。可以用来指定复杂的物体，并且有效地利用内存和处理时间。下面进一步讨论三角形带。  
在几何处理阶段，光栅化阶段之前，三角形的顶点会执行背面剔除，忽略那些看不见的三角形面片。背面剔除算法通常使用三角形的顶点顺序和观察者的视点方向来确定面片的朝向。也就是说，三角形的**绕序 (winding order)** 也是拓扑类型的一个重要因素。  
以微软 DirectX (Unity 也是) 文档中配图可以看出，三角形列表的绕序为顺时针。但三角形带无法保证每个三角形的绕序相同。经过观察发现，三角形带中，奇次序的三角形绕序为顺时针，偶次序三角形的绕序为逆时针。为了解决这个问题，**GPU 内部会对偶数三角形的后两个顶点顺序进行调换**，以此使它们与奇数三角形的绕序都保持**顺时针**。

![[85156af39fe4c9468793d859d676906e_MD5.jpg]]

以上图为例，GPU 实际处理的绕序应该是：123 243 345 465 567。

邻接图元可以在任何基础拓扑类型衍生出来。注意，邻接图元你的顶点只能用作几何着色器的输入数据，却并**不会被绘制出来**。即便程序没有用到几何着色器，但依旧不会绘制邻接图元。

注意，以上的讨论都是针对应用阶段输入装配阶段，CPU 告诉 GPU 如何将顶点组成图元类型的图元拓扑类型，而并非向几何着色器输入的图元类型。

## 编写几何着色器

几何着色器的一般编写格式如下：

```c
[maxcertexcount(N)]
void ShaderName (PrimitiveType InputVertexType InputName[NumElements],
                inout StreamOutputObjectVertexType) OutputName){
    // 几何着色器具体实现
}
```

### 最大顶点数量

`[maxvertexcount(N)]` 用来指定几何着色器单词调用所输出的顶点数量最大值。其中，N 是几何着色器**单次调用**所输出的顶点数量最大值。几何着色器每次输出的顶点个数都可能不同，但是这个数量却不能超过之前定义的最大值。  
出于对性能方面的考虑，我们应当令 maxvertexcount 的值尽可能小。线管资料显示，GS 每次输出的标量数量在 1-20 时，它将发挥出最佳的性能；而当 27-40 时，它的性能将下降到峰值性能的 50%。

**每次调用几何着色器所输出的标量个数为：maxvertexcount 与输出顶点类型结构体中标量个数的乘积**。例如，如果顶点结构体定义了 `float3 pos : POSITION` 与 `float2 tex : COORD0`，即顶点元素中含有 5 个标量。假设此时将 maxvertexcount 设置为 4，则几何着色器每次输出 20 个标量，以峰值性能执行。

### 输入输出

**几何着色器的输入参数**必须是一个定义有特定图元的顶点数组，点应输入一个顶点，线条列表 / 带应输入两个顶点，三角形列表 / 带应输入 3 个顶点，线及邻接图元为 4 个顶点，三角形及其邻接图元则为 6 个顶点。  
输入参数以图元类型作为前缀，用以描述输入到几何着色器的具体图元类型。并且注意，**输入图元类型必须对应输入装配阶段的图元拓扑类型**，否则会出现顶点不匹配的现象。该前缀可以是下列类型之一：

*   `point`：输入图元拓扑类型为点列表
*   `line`：输入图元拓扑类型为线列表或线条带
*   `triangle`：输入的图元拓扑类型为三角形列表或三角形带
*   `lineadj`：输入的图元拓扑类型为线条列表 / 带及其邻接图元
*   `triangleadj`：输入的图元为三角形列表 / 带及其邻接图元

**几何着色器的输出参数**是标有 `inout` 修饰符的**流类型 (stream type)** 。流类型存有一系列顶点，它们定义了几何着色器输出的几何图形。  
流类型的本质是一种模板类型 (template type)，其模板参数用以指定输出顶点的具体类型。流类型有如下 3 种：

*   `PointStream<OutputVertexType>`：一系列顶点所定义的点列表
*   `LineStream<OutputVertexType>`：一系列顶点所定义的线条带
*   `TriangleStream<OutputVertexType>`：一系列顶点所定义的三角形带

几何着色器输出的多个顶点会够成图元，图元的输出类型由流类型来指定。对于线条与三角形来说，几何着色器输出的对应图元拓扑类型必须是**线条带与三角形带**。而线条列表与三角形列表可以借助内置函数 `RestarStrip` 输出。

由于大多数模型图元拓扑类型都是三角形带，所以其实输入一般都是 `triangle`。

### Append

`Append` 函数用来将几何着色器的输出数据追加到一个现有的流中。

```c
[maxcertexcount(N)]
void ShaderName (PrimitiveType InputVertexType InputName[NumElements],
                inout StreamOutputObjectVertexType) OutputName){
    // 几何着色器具体实现
    StreamOutputObjectVertexType gout;
    OutputName.Append(gout);
}
```

### RestartStrip

`RestartStrip` 函数用来结束当前的基元条带，开始一个新的条带。如果当前的条带没有足够的顶点被追加出来以填满基元拓扑结构，那么末端的不完整基元将被丢弃。  
前面提到，几何着色器输出的图元拓扑类型只能是线条带或三角形带，但总有带状结构无法表示的情况 (或者说过载了想不出来)，这时候就可以用 `RestartStrip` 来重置输出流，采用类似三角形列表的方式追加几个三角形。

```c
[maxcertexcount(N)]
void ShaderName (PrimitiveType InputVertexType InputName[NumElements],
                inout StreamOutputObjectVertexType) OutputName){
    // 几何着色器具体实现
    StreamOutputObjectVertexType gout;
    OutputName.Append(gout);
    OutputName.RestartStrip();
    OutputName.Append(gout);
}
```

## 广告牌 (Billboard)

**使用几何着色器将输入点图元扩展为三角形带。**

![[922cbce45f88fe282575f6c858222a4b_MD5.gif]]

广告牌（Billboard）技术是一种常用的图形渲染技术，用于在三维场景中渲染面向摄像机的平面对象，通常用于表示树木、草地、粒子效果等。  
在广告牌技术中，每个平面对象（如树木）实际上是一个只有一个面的矩形，该面始终面向摄像机。这样可以通过简化几何模型来提高性能，并在保持物体外观的同时实现高效渲染。

**我们可以通过几何着色器来实现多个广告牌的渲染。这使得我们在 CPU 阶段只需要发送由顶点组成的图元，GPU 再将它扩展成四边形面片，并让它朝向相机。**

在这个例子中，我们用 C# 脚本绘制随机位置点列表组成的 mesh，然后用几何着色器将它扩展为一个房子 (LearnOpenGL 的例子)，并朝向摄像机。

在 C# 脚本中，只需要创建由随机位置点拓扑组成的 Mesh 即可。代码：[github](https://github.com/dyxdyxdyx/TA-100/tree/master/Assets/3.3%20TESS%26GS/Scripts)  
在 Shader 中，首先定义各个阶段的输入与输出。

```c
struct Attributes {
    float4 positionOS : POSITION;
};

struct VertexOut {
    float4 positionOS : TEXCOORD0;
    float3 positionWS : TEXCOORD1;
};

struct Varyings {
    float4 positionCS : SV_POSITION;
    float2 uv : TEXCOORD0;
    float3 positionWS : TEXCOORD1;
    uint primID: SV_PrimitiveID;
};
```

顶点着色器负责将顶点数据传给几何着色器。

```c
VertexOut HouseBuildingPassVertex(Attributes input) {
    VertexOut output;

    VertexPositionInputs vertexInputs = GetVertexPositionInputs(input.positionOS);
    output.positionOS = input.positionOS;
    output.positionWS = vertexInputs.positionWS;

    return output;
}
```

在几何着色器中，将顶点扩展为三角形带。计算面朝向相机的 up 和 right 向量，然后用它计算出其他四边形的位置。

![[09a0bb578071251b22dbb32dff52a6ad_MD5.jpg]]

```c
// 输出最大顶点数量：5
[maxvertexcount(5)]
void HouseBuildingPassGeometry(point VertexOut input[1],// 输入图元类型：点
                               uint primID : SV_PrimitiveID,// 当前处理图元的ID
                               inout TriangleStream<Varyings> triStream) {// 输出流
    // 计算朝向摄像机的上方向和右方向向量
    float3 up = float3(0.0, 1.0, 0.0);
    float3 look = -GetWorldSpaceViewDir(input[0].positionWS.xyz);
    look.y = 0.0;
    look = normalize(look);
    float3 right = cross(up, look);

    float4 v[5];
    float width = _Width * 0.5, height = _Height * 0.5;
    // 顺时针
    v[0] = float4(input[0].positionWS.xyz + 1.7 * up * height, 1.0); // 顶部
    v[1] = float4(input[0].positionWS.xyz + width * right + height * up, 1.0); // 右上
    v[2] = float4(input[0].positionWS.xyz - width * right + height * up, 1.0); // 左上
    v[3] = float4(input[0].positionWS.xyz + width * right - height * up, 1.0); // 右下
    v[4] = float4(input[0].positionWS.xyz - width * right - height * up, 1.0); // 左下

    float2 texcoords[5];
    texcoords[0] = float2(0.0, 0.0);
    texcoords[1] = float2(1.0, 1.0);
    texcoords[2] = float2(0.0, 1.0);
    texcoords[3] = float2(1.0, 0.0);
    texcoords[4] = float2(0.0, 0.0);

    //  static loop，把循环展开
    Varyings gout;
    UNITY_UNROLL
    for (uint i = 0; i < 5; ++i) {
        VertexPositionInputs positionInputs = GetVertexPositionInputs(v[i]);
        gout.positionCS = TransformWorldToHClip(v[i]);
        gout.positionWS = v[i];
        gout.primID = primID;
        gout.uv = texcoords[i];

        triStream.Append(gout);
    }
}
```

几何着色器中，对纹理数组采样，用 primID 取模作为索引。

```c
half4 HouseBuildingPassFragment(Varyings input) : SV_Target {
    half4 var_MainTex = SAMPLE_TEXTURE2D_ARRAY(_Textures, sampler_Textures, input.uv, input.primID % _TextureCount);
    half3 finalCol = var_MainTex.rgb;

    return half4(finalCol, 1.0);
}
```

完整代码：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/GeometryShaders/HouseBuilding)

## 法线渲染

使用几何着色器将三角形带扩展为线条带。

![[efa98efca409b1f8e3db2ded52e34ca9_MD5.jpg]]

其中涉及到线条顶点位置的计算，法线起点应该在三角形重心位置。  
代码如下：[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/GeometryShaders/NormalShading)

把材质放到 RendererFeature 中，以便该 Layer 的物体可以用这个 Pass 渲染法线。

## Flat Wireframe

使用几何着色器将三角形带转换为三角形带，计算并传递额外信息。

![[aabcd31cd821041794b6470b4f44c586_MD5.jpg]]

这个例子的详细教程在 [catlikecoding](https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading/)，这里仅仅给出代码。[github](https://github.com/dyxdyxdyx/TheTus-Unity-Projects/tree/master/TheTus-Unity-Projects/Assets/Tessellation%26Geometry/Shaders/GeometryShaders/FlatWireframe)

## 细分

这是龙书的一个练习，我的做法也不一定是最好的 (项目里肯定不能这么用)，放这里主要想说明一下 `RestartStrip` 的用法。

![[3dad522c2efbac125374581e75db736b_MD5.gif]]

题目描述如下：

![[14bf7e51298becfde119cc7962e78c8c_MD5.jpg]]

正二十面体模型就不用代码生成了，直接导进来。

下面先讨论一次细分的写法。

![[e976bd8840fdb0e6c3990ef1a62de3b7_MD5.jpg]]

由于是正三角形，我们只需要在每条边找到一个中点，然后将中点连起来组成新三角形即可。一个三角形可以生成 4 个子三角形。

![[39eb83f1a0a53461f8d17a78083ff9fa_MD5.jpg]]

如上图三角形，v0-v1-v2，将中点 m0-m1-m2 连接，一共生成 4 个子三角形。我们就需要在几何着色器中先计算出三个中点，然后依次追加到输出三角形带里。  
但是，上述子三角形是无法一次性用三角形带输出的。我们换一种思路，将下面一层当作三角形带，上面一层当作三角形列表，中间用 `RestartStrip` 分开。  
也就是说，添加给输出流的顺序如下：(v0, m0, m2, m1, v2) `RestartStrip` (m0, v1, m1)。

```
[maxvertexcount(9)]
void LODPassGeometry(triangle VertexOut gin[3], uint primID : SV_PrimitiveID, inout TriangleStream<Varyings> triStream) {
    // 计算中点坐标
    VertexOut m[3];
    UNITY_UNROLL
    for (int i = 0; i < 3; i++) {
        // 计算中点坐标
        m[i].positionOS = (gin[i].positionOS + gin[(i + 1) % 3].positionOS) * 0.5;
        // 中点法线即模型空间位置(球)
        m[i].normalOS = normalize(m[i].positionOS);
        // 将顶点投影到半径为1的球面上
        m[i].positionOS = m[i].normalOS;
    }

    // 组装输出顶点
    VertexOut vout[6];
    vout[0] = gin[0];
    vout[1] = m[0];
    vout[2] = m[2];
    vout[3] = m[1];
    vout[4] = gin[2];
    vout[5] = gin[1];

    Varyings gout[6];
    VertexPositionInputs vertexInputs;
    VertexNormalInputs normalInputs;

    float3 coordsX = {1.0, 0.0, 0.0};
    float3 coordsY = {0.0, 1.0, 0.0};

    // 计算输出图元顶点序列
    UNITY_UNROLL
    for (uint i = 0; i < 6; ++i) {
        vertexInputs = GetVertexPositionInputs(vout[i].positionOS);
        normalInputs = GetVertexNormalInputs(normalize(vout[i].positionOS));
        gout[i].positionCS = vertexInputs.positionCS;
        gout[i].normalWS = normalInputs.normalWS;
        gout[i].baryCoord = float2(coordsX[i % 3], coordsY[i % 3]);
    }

    // 输出下方三角形带
    UNITY_UNROLL
    for (uint i = 0; i < 5; ++i)
        triStream.Append(gout[i]);

    // 输出顶三角形
    triStream.RestartStrip();
    triStream.Append(gout[1]);
    triStream.Append(gout[5]);
    triStream.Append(gout[3]);
}
```

下面讨论多次细分的写法。  
明显可以感觉到，这是一个递归的过程。一个三角形分成 4 个子三角形，1 个子三角形又细分成 4 个子子三角形。但是在 Shader 里面递归还是有点抽象的，还是寻找一种线性的解法。

![[e15e33f51df5c210928f45ab8cfd684f_MD5.jpg]]

观察二次细分，我们可以得到一个规律：当细分 n 次时，一共有 $depth=2^{n}$ 行三角形，且每个小三角形的边长为 $len=distance(v_{0},v_{1})/depth$ 。底行线性顶点数为 $vcnt=depth*2+1$ ，往上一行顶点数少 2。然后，我们还需要计算两个基向量 $\hat{x}=\hat{v_{2}v_{0}},~\hat{y}=\hat{v_{1}v_{0}}$ ，这样就可以根据 $v_{0}$ 算出所有点的坐标了。  
将两行看作一层，从最底层开始处理到最顶层。对于每一层，三角形带添加的顺序应该是下 - 上 - 下... 输出完一层后，使用 `RestartStrip` 添加新的一层。

```
// 根据模型空间位置计算Varyings，并输出到流
void AppendVertex(float3 positionOS, float2 baryCoord, inout TriangleStream<Varyings> triStream) {
    VertexOut vout;

    vout.positionOS = positionOS;
    vout.normalOS = normalize(vout.positionOS);
    vout.positionOS = normalize(vout.normalOS);

    Varyings gout;
    VertexPositionInputs vertexInputs = GetVertexPositionInputs(vout.positionOS);
    VertexNormalInputs normalInputs = GetVertexNormalInputs(vout.normalOS);
    gout.positionCS = vertexInputs.positionCS;
    gout.normalWS = normalInputs.normalWS;
    gout.baryCoord = baryCoord;

    triStream.Append(gout);
}

// 进行cnt次细分
void Subdivide(int cnt, VertexOut gin[3], inout TriangleStream<Varyings> triStream) {
    float depth = pow(2, cnt);// 层数
    uint vcnt = depth * 2 + 1; // 每层下行顶点数
    float len = distance(gin[0].positionOS, gin[1].positionOS) / depth; // 每个小三角形边长
    float3 rightup = normalize(gin[1].positionOS - gin[0].positionOS); // 右上向量
    float3 right = normalize(gin[2].positionOS - gin[0].positionOS); // 右向量

    float3 coordsX = {1.0, 0.0, 0.0};
    float3 coordsY = {0.0, 1.0, 0.0};

    // 用来当前层每行三角形的基准位置
    float3 down = gin[0].positionOS;
    float3 up = down + rightup * len;

    UNITY_UNROLL
    for (uint i = 0; i < depth; ++i) {
        for (uint j = 0; j < vcnt; ++j) {
            // 下行
            if (j % 2 == 0)
                AppendVertex(down + right * len * (j / 2), float2(coordsX[j % 3], coordsY[j % 3]), triStream);
            // 上行
            else
                AppendVertex(up + right * len * (j / 2), float2(coordsX[j % 3], coordsY[j % 3]), triStream);
        }
        // 迭代下一层
        vcnt -= 2;
        down = up;
        up += rightup * len;
        triStream.RestartStrip();
    }
}

[maxvertexcount(80)]
void LODPassGeometry(triangle VertexOut gin[3], uint primID : SV_PrimitiveID, inout TriangleStream<Varyings> triStream) {
    // 计算世界空间中心点与相机距离
    float3 centerW = mul(unity_ObjectToWorld, float3(0.0, 0.0, 0.0));
    float3 vDir = GetWorldSpaceViewDir(centerW);
    float dis = length(vDir);

    // 根据距离设置细分次数
    uint subCnt = 0;
    if (dis < 4)
        subCnt = 3;
    else if (dis < 8)
        subCnt = 2;
    else if (dis < 12)
        subCnt = 1;

    Subdivide(subCnt, gin, triStream);
}
```

这里的最大顶点数量限制了细分次数，再往上写就报错了，理论来说是可以进行无数次细分的。

# 4 曲面细分 Shader

本文主要介绍 URP 下 Tessellation 的实现。曲面细分位于渲染管线几何阶段，VertexShader 之后，GeometryShader 之前，主要分为三个阶段：Hull, Tessellation, 和 Domain。其中 Hull 和 Domain 是可编程的。其详细的渲染流程如下：

![[136b9af1a24ccc1c359f187dfd31c172_MD5.jpg]]

下面开始一步步实现 Tessellation 的 URP Shader。
## 声明
1. 首先，需要一个 URP 下的基础 Shader，如下：

[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@8.2/manual/writing-shaders-urp-basic-unlit-structure.html](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@8.2/manual/writing-shaders-urp-basic-unlit-structure.html)

2. 使用细分时的最低着色器目标级别为 4.6。如果我们不手动设置，Unity 将发出警告并自动使用该级别

```c
#pragma target 4.6
```

3. 使用 `#pragma` 声明相关的着色器方法

```c
#pragma vertex BeforeTessVertProgram
#pragma hull HullProgram
#pragma domain DomainProgram
#pragma fragment FragmentProgram
```

## 顶点着色器

**顶点着色器不再像以前那样负责把顶点坐标从 ObjectSpace 转换到 ClipSpace，或是贴图 UV 转换等工作，此处只是简单得将 Attributes 中的数据传递给曲面细分阶段**

```c
// 顶点着色器，此时只是将Attributes里的数据递交给曲面细分阶段
ControlPoint BeforeTessVertProgram(Attributes v) {
     ControlPoint p;
        
     p.vertex = v.vertex;
     p.uv = v.uv;
     p.normal = v.normal;
     p.color = v.color;
        
     return p;
}
```

ControlPoint 的结构如下：

```c
struct ControlPoint
{
     float4 vertex : INTERNALTESSPOS;
     float2 uv : TEXCOORD0;
     float4 color : COLOR;
     float3 normal : NORMAL;
};
```

可以和 Attributes 的结构比较一下

```c
struct Attributes
{
     float4 vertex : POSITION;
     float3 normal : NORMAL;
     float2 uv : TEXCOORD0;
     float4 color : COLOR;
};
```

可见两个结构几乎相同的，只是 ControlPoint 中的 vertex 使用 **`INTERNALTESSPOS` 代替 `POSITION` 语义**，否则编译器会报位置语义的重用

## Hull 着色器

细分阶段非常灵活，可以处理三角形，四边形或等值线。我们必须告诉它必须使用什么表面并提供必要的数据。这是 hull 程序的工作。

```c
ControlPoint HullProgram(InputPatch<ControlPoint, 3> patch, uint id : SV_OutputControlPointID)
{
     return patch[id];
}
```

`InputPatch` 参数是向 Hull 程序传递曲面 Patch 的参数。Patch 是网格顶点的集合。必须指定顶点的数据格式。现在，我们将使用 ControlPoint 结构。在处理三角形时，每个 Patch 将包含三个顶点，此数量必须指定为 InputPatch 的第二个模板参数，所以第二个参数设置为 3。

Hull 程序的工作是将所需的顶点数据传递到细分阶段。尽管向其提供了整个 Patch，但该函数一次仅应输出一个顶点。Patch 中的每个顶点都会调用一次它，并带有一个附加参数，该参数指定应该使用哪个控制点（顶点）。该参数是具有 `SV_OutputControlPointID` 语义的无符号整数。

**仅仅是这样的函数声明是不行的，编译器会报错，要求我们指定详细的参数，具体如下：**

```c
[domain("tri")]
```

`domain`: 指定 patch 的类型，可选的有：tri (三角形)、quad（四边形）、isoline（线段，苹果的 metal api 不支持：2018/8/21）。不同的 patch 类型，细分的方式也有差别，此处指定为三角形类型

```c
[outputcontrolpoints(3)]
```

`outputcontrolpoints`：输出的控制点的数量（每个图元），不一定与输入数量相同，也可以新增控制点。此处设置为 3，是明确地告诉编译器每个 Patch 输出三个控制点

```c
[outputtopology("triangle_cw")]
```

`outputtopology`：输出拓扑结构。当 GPU 创建新三角形时，它需要知道我们是否要按顺时针或逆时针定义它们。有三种：triangle_cw（顺时针环绕三角形）、triangle_ccw（逆时针环绕三角形）、line（线段）。

```c
[partitioning("fractional_odd")]
```

`partitioning`：分割模式，起到告知 GPU 应该如何分割 Patch 的作用呢，共有三种：integer，fractional_even，fractional_odd。

```c
[patchconstantfunc("MyPatchConstantFunction")]
```

`patchconstantfunc`：指定 Patch 常数函数。GPU 必须知道应将 Patch 切成多少部分。这不是一个恒定值，每个 Patch 可能有所不同。必须提供一个评估此值的函数，称为 Patch 常数函数（Patch Constant Functions）

### Patch 常数函数
Patch Constant function
**Patch 常数函数决定 Patch 的属性是如何细分的**。这意味着它每个 Patch 仅被调用一次，而不是每个控制点被调用一次。这就是为什么它被称为常量函数，在整个 Patch 中都是常量的原因。

```c
TessellationFactors MyPatchConstantFunction(InputPatch<ControlPoint, 3> patch) {
    float minDist = _MinTessDistance;
    float maxDist = _MaxTessDistance;

    TessellationFactors f;

    float edge0 = CalcDistanceTessFactor(patch[0].vertex, minDist, maxDist, _Tess);
    float edge1 = CalcDistanceTessFactor(patch[1].vertex, minDist, maxDist, _Tess);
    float edge2 = CalcDistanceTessFactor(patch[2].vertex, minDist, maxDist, _Tess);

    // make sure there are no gaps between different tessellated distances, by averaging the edges out.
    f.edge[0] = (edge1 + edge2) / 2;
    f.edge[1] = (edge2 + edge0) / 2;
    f.edge[2] = (edge0 + edge1) / 2;
    f.inside = (edge0 + edge1 + edge2) / 3;
    return f;
}
```

**为了确定如何细分三角形，GPU 使用了四个细分因子。三角形面片的每个边缘都有一个因数。三角形的内部也有一个因素。** 
三个边缘向量必须作为具有 `SV_TessFactor` 语义的 float 数组传递。内部因素使用 `SV_InsideTessFactor` 语义

```c
struct TessellationFactors
{
     float edge[3] : SV_TessFactor;
     float inside : SV_InsideTessFactor;
};
```

实际上，**此功能是与 HullProgram 并行运行的子阶段。**

![[957ebed4a6a6f7dfabae62a878af584f_MD5.jpg]]

## Domain 着色器

HUll 着色器只是使曲面细分工作所需的一部分。**一旦细分阶段确定了应如何细分 Patch，则由 Domain 着色器来评估结果并生成最终三角形的顶点。对于每个顶点，都会调用一次 Domain 着色器**。一般来讲，这里会涉及到大量的计算，所有的顶点信息都会在这里重新计算，最后会将顶点坐标转换到投影空间。

```c
[domain("tri")]//Hull着色器和Domain着色器都作用于相同的域，即三角形。我们通过domain属性再次发出信号
Varyings DomainProgram(TessellationFactors factors, OutputPatch<ControlPoint, 3> patch, float3 barycentricCoordinates : SV_DomainLocation)
{
    Attributes v;
        
    //为了找到该顶点的位置，我们必须使用重心坐标在原始三角形范围内进行插值。
    //X，Y和Z坐标确定第一，第二和第三控制点的权重。
    //以相同的方式插值所有顶点数据。让我们为此定义一个方便的宏，该宏可用于所有矢量大小。
     #define DomainInterpolate(fieldName) v.fieldName = \
                        patch[0].fieldName * barycentricCoordinates.x + \
                        patch[1].fieldName * barycentricCoordinates.y + \
                        patch[2].fieldName * barycentricCoordinates.z;
    
     //对位置、颜色、UV、法线等进行插值
     DomainInterpolate(vertex)
     DomainInterpolate(uv)
     DomainInterpolate(color)
     DomainInterpolate(normal)
                    
     //现在，我们有了一个新的顶点，该顶点将在此阶段之后发送到几何程序或插值器。
     //但是这些程序需要Varyings数据，而不是Attributes。为了解决这个问题，
     //我们让域着色器接管了原始顶点程序的职责。
     //这是通过调用其中的AfterTessVertProgram（与其他任何函数一样）并返回其结果来完成的。
     return AfterTessVertProgram(v);
}

Varyings AfterTessVertProgram (Attributes v)
{
    Varyings o;
    o.vertex = TransformObjectToHClip(v.vertex);
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    o.posWS = TransformObjectToWorld(v.vertex);

    return o;
}
```

`[domain("tri")]` ->Hull 着色器和 Domain 着色器都作用于相同的域，即三角形。我们通过 domain 属性再次发出信号。

参数说明：
1. `TessellationFactors` ：由 Patch Constant Function (Patch 常数函数) 输入，细分参数。
2. `OutputPatch`：由 Hull 着色器传入的 patch 数据，尖括号的第二个参数与 Hull 着色器中的 InputPatch 对应。
3. `SV_DomainLocation`：由曲面细分阶段阶段传入的顶点位置信息。

Hull 着色器确定 Patch 的细分方式时，不会产生任何新的顶点。相反，它会为这些顶点提供重心坐标。使用这些坐标来导出最终顶点取决于 Domain 着色器。为了使之成为可能，每个顶点都会调用一次域函数，并为其提供重心坐标。

现在，我们有了一个新的顶点，该顶点将在此阶段之后发送到几何程序或插值器。但是这些程序需要 Varyings 数据，而不是 Attributes。为了解决这个问题，我们**让 Domain 着色器接管了原始顶点程序的职责**。这是通过调用其中的 AfterTessVertProgram 并返回其结果来完成的。

## 总结

```c
Shader "V/URP/Tessellation"
{
    Properties
    {
        _Color("Color(RGB)",Color) = (1,1,1,1)
        _MainTex("MainTex",2D) = "gary"{}
        _Tess("Tessellation", Range(1, 32)) = 20
        _MaxTessDistance("Max Tess Distance", Range(1, 32)) = 20
        _MinTessDistance("Min Tess Distance", Range(1, 32)) = 1
    }
    SubShader
    {
        Tags
        {
            "RenderPipeline"="UniversalPipeline"
            "RenderType"="Opaque"
            "Queue"="Geometry+0"
        }
        
        Pass
        {
            Name "Pass"
            Tags 
            { 
                
            }
            
            // Render State
            Blend One Zero, One Zero
            Cull Back
            ZTest LEqual
            ZWrite On

            HLSLPROGRAM

            #pragma require tessellation
            #pragma require geometry
            
            #pragma vertex BeforeTessVertProgram
            #pragma hull HullProgram
            #pragma domain DomainProgram
            #pragma fragment FragmentProgram

            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 4.6

            // Includes
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            CBUFFER_START(UnityPerMaterial)
            half4 _Color;
            float _Tess;
            float _MaxTessDistance;
            float _MinTessDistance;
            CBUFFER_END
            
			Texture2D _MainTex;
            float4 _MainTex_ST;
            
            //为了方便操作 定义预定义
            #define smp SamplerState_Point_Repeat
            // SAMPLER(sampler_MainTex); 默认采样器
            SAMPLER(smp);

            // 顶点着色器的输入
            struct Attributes
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float2 uv : TEXCOORD0;
                float4 color : COLOR;
            };

            // 片段着色器的输入
            struct Varyings
            {
                float4 color : COLOR;
                float3 normal : NORMAL;
                float4 vertex : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 posWS:TEXCOORD1;
            };

            // 为了确定如何细分三角形，GPU使用了四个细分因子。三角形面片的每个边缘都有一个因数。
            // 三角形的内部也有一个因素。三个边缘向量必须作为具有SV_TessFactor语义的float数组传递。
            // 内部因素使用SV_InsideTessFactor语义
            struct TessellationFactors
            {
                float edge[3] : SV_TessFactor;
                float inside : SV_InsideTessFactor;
            };

            // 该结构的其余部分与Attributes相同，只是使用INTERNALTESSPOS代替POSITION语意，否则编译器会报位置语义的重用
            struct ControlPoint
            {
                float4 vertex : INTERNALTESSPOS;
                float2 uv : TEXCOORD0;
                float4 color : COLOR;
                float3 normal : NORMAL;
            };

            // 顶点着色器，此时只是将Attributes里的数据递交给曲面细分阶段
            ControlPoint BeforeTessVertProgram(Attributes v)
            {
                ControlPoint p;
        
                p.vertex = v.vertex;
                p.uv = v.uv;
                p.normal = v.normal;
                p.color = v.color;
        
                return p;
            }

            // 随着距相机的距离减少细分数
            float CalcDistanceTessFactor(float4 vertex, float minDist, float maxDist, float tess)
            {
                float3 worldPosition = TransformObjectToWorld(vertex.xyz);
                float dist = distance(worldPosition,  GetCameraPositionWS());
                float f = clamp(1.0 - (dist - minDist) / (maxDist - minDist), 0.01, 1.0) * tess;
                return (f);
            }
            
            // Patch Constant Function决定Patch的属性是如何细分的。这意味着它每个Patch仅被调用一次，
            // 而不是每个控制点被调用一次。这就是为什么它被称为常量函数，在整个Patch中都是常量的原因。
            // 实际上，此功能是与HullProgram并行运行的子阶段。
            // 三角形面片的细分方式由其细分因子控制。我们在MyPatchConstantFunction中确定这些因素。
            // 当前，我们根据其距离相机的位置来设置细分因子
            TessellationFactors MyPatchConstantFunction(InputPatch<ControlPoint, 3> patch)
            {
                float minDist = _MinTessDistance;
                float maxDist = _MaxTessDistance;
            
                TessellationFactors f;
            
                float edge0 = CalcDistanceTessFactor(patch[0].vertex, minDist, maxDist, _Tess);
                float edge1 = CalcDistanceTessFactor(patch[1].vertex, minDist, maxDist, _Tess);
                float edge2 = CalcDistanceTessFactor(patch[2].vertex, minDist, maxDist, _Tess);
            
                // make sure there are no gaps between different tessellated distances, by averaging the edges out.
                f.edge[0] = (edge1 + edge2) / 2;
                f.edge[1] = (edge2 + edge0) / 2;
                f.edge[2] = (edge0 + edge1) / 2;
                f.inside = (edge0 + edge1 + edge2) / 3;
                return f;
            }

            //细分阶段非常灵活，可以处理三角形，四边形或等值线。我们必须告诉它必须使用什么表面并提供必要的数据。
            //这是 hull 程序的工作。Hull 程序在曲面Patch上运行，该曲面Patch作为参数传递给它。
            //我们必须添加一个InputPatch参数才能实现这一点。Patch是网格顶点的集合。必须指定顶点的数据格式。
            //现在，我们将使用ControlPoint结构。在处理三角形时，每个Patch将包含三个顶点。此数量必须指定为InputPatch的第二个模板参数
            //Hull程序的工作是将所需的顶点数据传递到细分阶段。尽管向其提供了整个Patch，
            //但该函数一次仅应输出一个顶点。Patch中的每个顶点都会调用一次它，并带有一个附加参数，
            //该参数指定应该使用哪个控制点（顶点）。该参数是具有SV_OutputControlPointID语义的无符号整数。
            [domain("tri")]//明确地告诉编译器正在处理三角形，其他选项：
            [outputcontrolpoints(3)]//明确地告诉编译器每个Patch输出三个控制点
            [outputtopology("triangle_cw")]//当GPU创建新三角形时，它需要知道我们是否要按顺时针或逆时针定义它们
            [partitioning("fractional_odd")]//告知GPU应该如何分割Patch
            [patchconstantfunc("MyPatchConstantFunction")]//GPU还必须知道应将Patch切成多少部分。这不是一个恒定值，每个Patch可能有所不同。必须提供一个评估此值的函数，称为Patch常数函数（Patch Constant Functions）
            ControlPoint HullProgram(InputPatch<ControlPoint, 3> patch, uint id : SV_OutputControlPointID)
            {
                return patch[id];
            }

			Varyings AfterTessVertProgram (Attributes v)
			{
				Varyings o;
				o.vertex = TransformObjectToHClip(v.vertex);
				o.uv = TRANSFORM_TEX(v.uv, _MainTex);
				o.posWS = TransformObjectToWorld(v.vertex);

                return o;
			}

            //HUll着色器只是使曲面细分工作所需的一部分。一旦细分阶段确定了应如何细分Patch，
            //则由Domain着色器来评估结果并生成最终三角形的顶点。
            //Domain程序将获得使用的细分因子以及原始Patch的信息，原始Patch在这种情况下为OutputPatch类型。
            //细分阶段确定Patch的细分方式时，不会产生任何新的顶点。相反，它会为这些顶点提供重心坐标。
            //使用这些坐标来导出最终顶点取决于域着色器。为了使之成为可能，每个顶点都会调用一次域函数，并为其提供重心坐标。
            //它们具有SV_DomainLocation语义。
            //在Demain函数里面，我们必须生成最终的顶点数据。
            [domain("tri")]//Hull着色器和Domain着色器都作用于相同的域，即三角形。我们通过domain属性再次发出信号
            Varyings DomainProgram(TessellationFactors factors, OutputPatch<ControlPoint, 3> patch, float3 barycentricCoordinates : SV_DomainLocation)
            {
                Attributes v;
        
                #define DomainInterpolate(fieldName) v.fieldName = \
                        patch[0].fieldName * barycentricCoordinates.x + \
                        patch[1].fieldName * barycentricCoordinates.y + \
                        patch[2].fieldName * barycentricCoordinates.z;
    
                    //对位置、颜色、UV、法线等进行插值
                    DomainInterpolate(vertex)
                    DomainInterpolate(uv)
                    DomainInterpolate(color)
                    DomainInterpolate(normal)
                    
                    return AfterTessVertProgram(v);
            }
            
            // 片段着色器
            half4 FragmentProgram(Varyings i) : SV_TARGET 
            {    
                half4 mainTex = _MainTex.Sample(smp,i.uv);
                half4 c = _Color * mainTex;

                return c;
            }

            ENDHLSL
        }
    }
}
```