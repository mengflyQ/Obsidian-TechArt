**1. 渲染管线**：应用阶段（场景数据 CPU 整理）—图元数据—几何阶段（GPU 处理数据）顶点着色器 - 曲面细分着色器 - 几何着色器 - 投影 - 裁剪 - 屏幕映射—收集顶点信息—光栅化阶段（图元装配—三角形遍历—片元着色器—逐片元操作）—后处理阶段——屏幕图像

**几何阶段**

顶点着色器：高度可配置，GPU 需要模型转换和相机转换（因为需要相机来接受图像以及世界空间计算的复杂度）把场景的物体坐标空间通过 MVP 矩阵变换映射到相机的观察空间。还可以做顶点动画，顶点色彩处理。

曲面细分着色器：Vertex—Hill 配置如何细分—Tessellation 细分—Domain 对细分后的顶点做处理—Geometry

投影：GPU 将顶点从摄像机观察空间转换到裁剪空间（透视投影裁剪空间与正交投影裁剪空间）。

裁剪：将裁剪空间外的顶点剔除，剔除后，对透视裁剪空间来说，GPU 需要对裁剪空间中的顶点执行齐次除法（其实就是将齐次坐标系中的 w 分量除 x、y、z 分量），得到顶点的归一化设备坐标（NDC）【即 x、y、z 三个坐标都在 [-1,1] 区间内的立方体】此时 xy 分量已经接近屏幕位置了，z 坐标会被写入深度缓冲。

屏幕映射：尽管 GPU 已经得到了顶点的 x、y 坐标，但他们处于 [-1,1] 区间中的，GPU 还需要进行一定的计算才能把他们真正的样子呈现到我们使用的屏幕上。得到的新坐标系称为屏幕坐标系。

**光栅化阶段**

GPU 也只是完成了渲染的一半工作，因为现在我们只是得到了一些顶点，他们还不是能被显示在屏幕上的像素。

图元装配：把顶点数据收集并组装为点、线、三角面）

三角形遍历：将检验一个三角形覆盖了屏幕上的那些像素，被覆盖的区域将生成一个**片元（**片元不是真正意义上的像素集合，而是包含了很多种状态的集合（譬如屏幕坐标、深度、法线、纹理等，这些都是几何阶段顶点储存的数据），这些数据用于计算最终的每个像素颜色**）**因为片元边缘与像素的契合问题，需要抗锯齿算法处理，常用的有：多重采样抗锯齿（MSAA 这种抗锯齿方法对中心点不在三角形内的边缘像素部分采用不同程度的浓度进行计算。）除此以外，GPU 还将对覆盖区域的每个像素的深度进行插值计算。

TAA 与 SSAA 的方式不同在于，TAA (Temporal Anti-Aliasing) 综合历史帧的数据来实现抗锯齿，这样会将每个像素点的多次采样均摊到多个帧中，相对的开销要小得多。我们需要在光栅化 G-Buffer 的阶段，在 Projection Matrix 之后再加上一个 Jittered Matrix。这个 Jitttered Matrix 会根据一个样本分布的 pattern 对当前采样位置进行一个微小的偏移

片元着色器：高度可配置，利用三角形遍历后的数据做着色处理，还可以自己引入纹理采样，法线，AO，高度，光照等等

逐片元操作：对片元进行测试和合并，测试决定了片元显示形式，主要有透明度测试，模板测试，深度测试。测试完成后片元颜色就会被送到颜色缓冲区。GPU 会使用双重缓冲。

**2. 坐标空间定义与变换**

M model—>world 缩放矩阵、旋转矩阵、移动矩阵

模型空间：物体自身的坐标空间

世界空间：w 物体在世界坐标中的位置

V world—>camera （view）

观察空间：摄像机为原点的坐标空间，+x 轴指向右方，+y 轴指向上方，+z 轴指向后方。

P camera—>clip

裁剪空间：摄像机成像的空间，有近裁剪平面和远裁剪平面，将空间外的点剔除

屏幕空间：将裁剪后的顶点通过透视投影（齐次除法）投影到 xyz 为 - 1 到 1 的 NDC 空间，将 x，y 通过计算得到顶点的最终屏幕位置

（TBN 矩阵：是帮法线（因为朝向 z 方向所有一般呈现 b 蓝色）从模型空间转换到世界空间）

变换矩阵的每一列表示变换后的 xyz 的单位向量

齐次坐标的作用，把各种变换都统一了起来，即 把缩放，旋转，平移等变换都统一起来，都表示成一连串的矩阵相乘的形式。保证了形式上的线性一致性。实现坐标平移。1 是点，0 是向量

**3. 光照部分**

光线追踪：

**直接光**

**环境光**

IBL 环境贴图就是在场景中任意一点往四周看去可看到的光照，将其记录在一张图上这就是环境光照，或者也可以叫做 IBL(image-based lighing)。通常我们用 spherical map 或 cube map 来存储环境光照。

**CubeMap 如何实现？**→ 采样反射向量与立方体的交点

**光照贴图** 光照贴图过程将预先计算场景中表面的亮度，并将结果存储在称为 “光照贴图” 的纹理中供以后使用。

光照贴图可以包含直射光和间接光。该光照纹理可与颜色（反照率）和浮雕（法线）之类的对象表面信息材质相关联的着色器一起使用。

![[6df3fe7568add1979236be63b37d3fe3_MD5.jpg]]

**光照模型**

Lambert 总漫反射 = _反射系数 × 环境光 ambient + _反射系数 × （顶点法向量 N · 入射光反方向向量 L)

Half Lambert 漫反射 = _反射系数 × 环境光 + _反射系数 × （顶点法向量 · 入射光反方向向量 * 0.5 + 0.5） 可以用偏移因子来替代取半

Phong 高光 =_镜面反射系数 × _光源强度 × （观察方向 V · 反射光方向）^ 高光指数

Blinn-Phong 高光 = _镜面反射系数 × _光源强度 × （法线方向 N · 视点方向和光源方向的半角向量 V+L）^ 高光指数

Wrap 基于兰伯特的一种深化

```
float wrap diffuse = max(0, (dot(L, N) + wrap) / (1 + wrap));
```

Banded lighting 将连续的灯光变为离散的一段一段的

```
float   NdotL = max( 0.0 , dot(s.Normal, lightDir));
 
float   lightBandsMultiplier = _LightSteps /  256 ;
float   lightBandsAdditive = _LightSteps /  2 ;
fixed bandedNdotL = (floor((NdotL *  256   + lightBandsAdditive) / _LightSteps))
     * lightBandsMultiplier;
 
float3 lightingModel = bandedNdotL * s.Albedo;
float3 attenColor = atten * _LightColor0.rgb;
float4 finalDiffuse = float4(lightingModel * attenColor,  1 );
return   finalDiffuse;
```

Minnaert lighting 适合天鹅绒或月亮，这类多孔可渗透性或纤维状的表面，这类表面会导致大量光反向散射

```
float3 viewDirection = viewDir;
float   NdotL = max( 0 , dot(s.Normal, lightDir));
float   NdotV = max( 0 , dot(s.Normal, viewDirection));
 
float3 minnaert = saturate(NdotL * pow(NdotL*NdotV, _Roughness));
 
float3 lightingModel = minnaert * s.Albedo;
float3 attenColor = atten * _LightColor0.rgb;
float4 finalDiffuse = float4(lightingModel * attenColor,  1 );
return   finalDiffuse;
```

Oren–Nayar lighting 光线向各个角度非均匀辐射

```
float   roughness = _Roughness;
float   roughnessSqr = roughness * roughness;
float3 o_n_fraction = roughnessSqr / (roughnessSqr + float3( 0.33 ,  0.13 ,  0.09 ));
float3 oren_nayar = float3( 1 ,  0 ,  0 ) + float3(- 0.5 ,  0.17 ,  0.45 ) * o_n_fraction;
float3 viewDirection = viewDir;
float   cos_ndotl = saturate(dot(s.Normal, lightDir));
float   cos_ndotv = saturate(dot(s.Normal, viewDirection));
float   oren_nayar_s = saturate(dot(lightDir, viewDirection)) - cos_ndotl * cos_ndotv;
oren_nayar_s /= lerp(max(cos_ndotl, cos_ndotv),  1 , step(oren_nayar_s,  0 ));
 
 
//lighting and final diffuse
float   attenuation = atten;
float3 lightingModel = s.Albedo * cos_ndotl * (oren_nayar.x + s.Albedo * oren_nayar.y + oren_nayar.z * oren_nayar_s);
float3 attenColor = attenuation * _LightColor0.rgb;
float4 finalDiffuse = float4(lightingModel * attenColor,  1 );
return   finalDiffuse;
```

PBR 是指使用基于物理原理和微平面理论建模的着色 / 光照模型，以及使用从现实中测量的表面参数来准确表示真实世界材质的渲染理念。

![[9eef047a40796a6f17d29a0cacd0901d_MD5.jpg]]

微平面理论: 微平面理论是将物体表面建模成做无数微观尺度上有随机朝向的理想镜面反射的小平面的理论。在实际的 PBR 工作流中，这种物体表面的不规则性用粗糙度贴图或者高光度贴图来表示。

能量守恒: 出射光线的能量永远不能超过入射光线的能量。随着粗糙度的上升镜面反射区域的面积会增加，作为平衡，镜面反射区域的平均亮度则会下降。

菲涅尔反射: 光线以不同角度入射会有不同的反射率。相同的入射角度，不同的物质也会有不同的反射率。万物皆有菲涅尔反射。F0 是即 0 度角入射的菲涅尔反射值。大多数非金属的 F0 范围是 0.02-0.04，大多数金属的 F0 范围是 0.7-1.0。

线性空间: 光照计算必须在线性空间完成，shader 中输入的 gamma 空间的贴图比如漫反射贴图需要被转成线性空间，在具体操作时需要根据不同引擎和渲染器的不同做不同的操作。而描述物体表面属性的贴图如粗糙度，高光贴图，金属贴图等必须保证是线性空间。

色调映射: 也称色调复制，是将宽范围的照明级别拟合到屏幕有限色域内的过程。因为基于 HDR 渲染出来的亮度值会超过显示器能够显示最大亮度，所以需要使用色调映射，将光照结果从 HDR 转换为显示器能够正常显示的 LDR。

物质的光学特性: 现实世界中有不同类型的物质可分为三大类：绝缘体，半导体和导体。在渲染和游戏领域，我们一般只对其中的两个感兴趣：导体（金属）和绝缘体（电解质，非金属）。其中非金属具有单色 / 灰色镜面反射颜色。而金属具有彩色的镜面反射颜色。即非金属的 F0 是一个 float。而金属的 F0 是一个 float3.

渲染方程

![[13c91232f955e561cc25171cd15a2c3c_MD5.jpg]]

BRDF 利用局部光学平坦表面，没有相互反射的假设，可以推导出一个被称为 Microfacet Cook-Torrance BRDF 的一般形式的 Specular BRDF 项。此 Specular BRDF 具有以下形式：其中 v 为反射方向 (观察方向)，l 为入射方向，n 为宏观表面法向，h 为微平面法向

![[9f8699c56c10593df79b1328bad4d297_MD5.jpg]]

D(h): 其代表了所有微观角度下微小镜面法线的分布情况，粗糙表面法线分布相对均匀，光滑表面法线分布相对集中法线分布函数主流模型是 GGX

![[f68569a5bf10917ab053aec0c52d6bfb_MD5.jpg]]

F(l,h): 菲涅尔方程描述了物体表面在不同入射光角度下反射光线所占的比率 一般都采用 Schlick 的 Fresnel 近似

![[7efbb4c1a562b9641173c1b7df1a5d6b_MD5.png]]

G(l,v,h): 几何函数描述了微平面自遮挡的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。 目前较为常用的是分离遮蔽阴影。该形式将几何项 G 分为两个独立的部分，光线方向和视线方向

![[9a7db2d7f0372ee54cedf4d52b00e2e0_MD5.jpg]]

4(n·l)(n·v）：校正因子

**4. 纹理与 uv**

纹理

定义 宏观的角度上来说就是一张 2D 图片，每个像素上都有 RGB 值

作用 降低建模工作量，牺牲几何细节 降低存储空间 提高读取速度

采样设置 wrap：Repeat 重复， Mirror 重复左右镜像，上下反转 ，Clamp 超出的部分为 Texture 的边， Border 使用定值进行填充

采样过滤设置 Filter：当纹理通过变化产生拉伸的时候，要使用哪种滤波来进行纹理的表现 最近邻（向最近的像素进行纹理取样表现，这个形式带来的问题就是，因为是从邻近像素采集的信息，所以很容易出现块状像素，也就让纹理 变得像素化，处理效果最差，但是因为是从邻近纹理取样的，所以所涉及的计算要少很多，在性能上表现不错），双线性插值（双线性插值 —— 对于每一个像素点都寻找邻近的四个像素点，在二维空间进行的线性插值得到的最终混合值），立方卷积（立方卷积插值 —— 相比较双线性插值，在这个计算方法中不仅采取周围一圈的像素点，还考虑到了它们变化率的影响，画面表现效果比前两种都要好，也正是牺牲了性能提高了表现效果，从 128*128 就近取 4 个点的像素，然后从 64*64 在就近取 4 个点两部分像素叠加除以 2，丢弃的像素更少、更平滑）

MipMap：预处理纹理，创建数据结构。实时计算中快速计算一组纹理对一个像素效果的近似值，将 2x2 的 4 个相邻的纹理平均值作为下一级的新的纹理值，所以新一级的纹理是上一级的 1/4 大。直到 1x1 ，在存储空间多了 1/3 大 。

CPU 纹理优化方式：纹理图集和数组

BumpMapping（凹凸贴图）：改变几何体表面各点的法线

Lightmap（光照贴图 ）：将场景中的灯光与物体产生的光照与阴影信息烘焙在一张或者多张 Lightmap 贴图中，这些物体将不再参与实时光照计算，从而减少了大量的性能开销。

纹理压缩：纹理格式是能被 GPU 所识别的像素格式，能被快速寻址并采样。压缩纹理，是一种 GPU 能直接读取并显示的格式，使得图像无需解压即可进行渲染，节约大量的内存。ASTC 自适应扩展纹理压缩，综合性能和使用便捷性最好的系列。

法线与法线贴图：法线图的存储一般分为在切线空间和模型空间。

模型空间优点：1. 不需要 TBN 转换 2. 相较切线空间法线，模型空间法线插值出来的值更平滑，因为处于同一个空间。因为坐标系的不同，插值的精确度降低了。有更光滑的边界。

切线空间优点：1. 自由度高，因为存的是相对法线的信息，在不同的网格上也会有合理的效果。2. 可进行 UV 动画。模型空间就不行，还是因为相对法线的优势。3. 可重用。砖头六个面使用同样的法线贴图。4. 可压缩，法线空间中的法线 Z 总是正方向，可以只存 xy 方向，推导出 Z 方向

UV

指 u,v 纹理贴图坐标的简称 (它和空间模型的 X, Y, Z 轴是类似的). 它定义了图片上每个点的位置的信息. 这些点与 3D 模型是相互联系的, 以决定表面纹理贴图的位置. UV 就是将图像上每一个点精确对应到模型物体的表面. 在点与点之间的间隙位置由软件进行图像光滑插值处理. 这就是所谓的 UV 贴图。

5. 各种 buffer

CommandBuffer 命令缓冲区：可以在指定的渲染节点内获取摄像机的颜色缓冲区（GrabPass 也可以起到类似效果 GrabPass{"TextureName"} 的写法抓取图片储存为贴图。）。可以在摄像机渲染 的几个节点中插入, 并执行一些操作。 Command Buffer 在渲染目标的时候，是支持我们使用自定义材质的。

StencilBuffer 模板缓冲区：模板测试

6. 色调映射算法 ： 指对图像颜色进行映射变换的算法。目的， 调整图像的灰度，使得处理后的图像人眼看起来更加舒适，能更好的表达原图里的信息与特征。理解 ： 通常被理解为将颜色值从高动态范围（HDR）映射到低动态范围（LDR） 的过程。在 Unity 中，这意味着对于大多数平台上任意 16 位的浮点型颜色值将被映射为 [0，1] 范围内的传统 8 位颜色值。

7. 描边 法线的延伸 深度偏移

边缘检测

Roberts 算子是利用局部差分寻找边缘的一种算子，是最简单的边缘检测算子。Roberts 算子利用对角线方向相邻两像素之差近似梯度幅值来检测边缘，检测垂直边缘的效果要优于其他方向边缘，定位精度高，但对噪声的抑制能力较弱。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正 45 度或负 45 度时，该算法处理效果更理想。它适用于边缘明显而且噪声较少的图像分割，在应用中经常用 Roberts 算子来提取道路。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。

Prewitt 算子是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测。由于 Prewitt 算子采用 3×3 大小的模板对区域内的像素值进行计算，而 Roberts 算子的模板为 2×2，故 Prewitt 算子的边缘检测结果在水平方向和垂直方向均比 Roberts 算子更加明显。Prewitt 算子适合用来识别噪声较多、灰度渐变的图像。Prewitt 算子在一个方向求微分，而在另一个方向求平均，因而对噪声相对不敏感，有抑制噪声的作用。但是像素平均相当于对图像的低通滤波，所以 Prewitt 算子对边缘的定位不如 Roberts 算子。

Laplacian 算子是 n 维欧几里德空间中的一个二阶微分算子，常用于图像增强领域和边缘提取。它通过灰度差分计算邻域内的像素，基本流程是：判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作。在算法实现过程中，Laplacian 算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系，最后通过梯度运算的结果对像素灰度进行调整。

8.SDF（有向距离场）有向距离场，英文名 Signed Distance Field，简称 SDF，把空间中与物体表面的距离进行采样，使用负值表示物体内部，使用正值表示物体外部，与物体的表面的距离为 0，大于 0，小于 0 和等于 0 区分物体的区域，你很快可以联想到之前使用的 step 函数和 smoothstep 函数，是的，通过与这两个函数的配合，就可以像前面样绘制图形了

卡渲脸部 计算脸部朝向与光照方向的夹角的值和一张单色的 FaceMap 来作判断。FaceMap 的每个像素表示：该像素判断为阴影时候需要达到的夹角。当方向光向角色右脸旋转，到达 36°（归一化值为 0.2，36° 除以 180°），那么 0.2 对应的那条线左边的像素值都小于 0.2，判断为阴影区域。右侧为亮部。

9. 水渲染：Gerstner 波 **波形叠加**是模拟水面的很常见的一种方法，它是通过叠加多个不同周期、不同振幅的周期函数来模拟水体表面的波动。

10. 反射

反射探针：将储存的反射数据插值传给物体

屏幕空间反射：在实时渲染当中，完整地计算求解间接光照下的反射是很困难的，因此需要通过各种技术手段模拟和近似反射效果。

环境贴图反射；cubemap 或者八面映射 float3 L = reflect(-V, N); float3 Color = CubeMap.SampleLevel(LinearSampler, L, 0).xyz;

平面反射；其中$d$ 是$P$ 点到$S$ 的距离，$\vec n$ 是$\vec{PP'}$ 的单位向量。

![[4fc507df5d2fbb418c795c8fccf87e50_MD5.jpg]]

![[90a83c7563c1d94576cee3e26bdbc632_MD5.png]]

*   从深度图重建当前世界坐标，将重建的世界坐标以反射平面为基准进行翻转处理
*   计算翻转后的世界坐标的屏幕 UV
*   对当前屏幕纹理进行采样暂存为一个 ReflectColor
*   将 ReflectColor 存入 ColorRT，但索引是反射后的屏幕像素值，也就是翻转后的世界坐标的屏幕 UV * ColorRT.size，这样在最后 Shader 中采样的时候就可以采样到反射后的颜色了
*   在反射平面的 Shader 中用模型的屏幕 UV 对 ColorRT 进行采样
*   在反射平面的 Shader 中采样噪声图进行混合，采样 Reflection Probe 进行混合来尽可能的让穿帮不会太明显

屏幕空间反射

*   对于屏幕空间上的物体的每个像素，根据该像素对应的法线和视线信息，求解出反射向量
*   当前点沿着反射向量在屏幕空间进行步进，判断步进后的坐标深度与深度缓存中存储的物体深度是否相交
*   若相交，取交点处的物体颜色作为最终的反射颜色

屏幕空间光线步进，将屏幕空间的点还原到世界空间，按照反射方向做步进，将步进的结果传回与起点相减获取步进方向，将坐标步进结果与屏幕物体深度做判断，相交且没出屏幕边界则返回该点的 uv 和深度，取该点的颜色作为物体的反射颜色

Hi-Z Screen-Space Reflections 一种计算动态 3D 场景反射的新方法，适用于任意形状（不仅是平面）的表面

*   Hierarchical-Z（Hi-Z） 加速光追
*   光泽反射所需的所有预计算通道
*   屏幕空间椎体跟踪的技术，用于近似粗糙表面，从而产生模糊的反射

11. 后处理（Post-Process Effect）是一种对渲染之后的画面进行再加工的技术 针对每一个摄像机，在绘制到用户窗口之前，都有机会对整个画面进行二次夹工，再将装饰后的画面呈现给用户，后处理能方便地制作全局效果，也会带来性能消耗。

将摄像机照射出的内容渲染到一张图中，就是 RT（RenderTexture，渲染图）将摄像机内容绘制到渲染图的过程被称为 RTT（Render to Texture）

```
unity的渲染接口  Void OnRenderImage(RenderTextrue sourceTextrue, RenderTexture destTexture_）
```

其中 sourceTexture 就是 RT，可通过下面的接口函数直接渲染给 destTexture，则就是默认的渲染方式

```
Graphics.Blit(sourceTexture, destTexture);//blit 位块传送
```

也可以指定某个材质 renderMaterial 进行渲染，输出到 destTextrue 中

```
Graphics.Blit(sourceTexture, destTexture, renderMaterial);
```

高斯模糊：用正态分布对点进行计算，得到周围点的正态分布值，"中间点" 取 "周围点" 的平均值。在数值上，这是一种 "平滑化"。在图形上，就相当于产生 "模糊" 效果，"中间点" 失去细节。

bloom：用一个阈值提取出当前渲染图像中较亮的部分，对该区域进行高斯模糊操作，用于模拟光的扩散，叠加到当前图像上。

12.shader 变体：在写 shader 时，往往会在 shader 中定义多个宏，并在 shader 代码中控制开启宏或关闭宏时物体的渲染过程。最终编译的时候也是根据这些不同的宏来编译生成多种组合形式的 shader 源码。其中每一种组合就是这个 shader 的一个变体 (Variant)。

预编译 shader_feature 和 multi_complie 是两个很相似的预编译指令，在 Editor 模式下，他们是几乎没有区别的。区别在于如果使用 shader_feature，build 时没有用到的变体会被删除，不会打出来。也就是说，在 build 以后环境里，运行代码 Material.EnableKeyword("B") 可能不起作用，因为没有 Material 在使用变体 B，所以变体 B 没有被 build 出来，运行时也找不到变体 B。

13. 延迟渲染 ：将着色计算延迟到深度测试之后进行处理的一种渲染方法。延迟着色技术的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开，能够在渲染拥有成百上千光源的场景的同时依然保持很高的帧率，给我们渲染拥有大量光源的场景提供了很多可能性。可以将延迟渲染 (Deferred Rendering) 理解为先将所有物体都先绘制到屏幕空间的缓冲（即 G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的⽚元的着色而产⽣的不必要的开销。也就是说延迟渲染基本思想是，先执行深度测试，再进行着色计算，将本来在物空 间（三维空间）进行光照计算放到了像空间（二维空间）进行处理。

过程：几何处理阶段，将物体信息储存到多个 G-buff 中。光照处理阶段，只需渲染出一个屏幕大小的二维矩形，使用第一步在 G-buffer 中存储的数据对此矩阵的每一个片段计算场景的光照；光照计算的过程还是和正向渲染以前一样，只是现在我们需要从对应的 G-buffer 而不是顶点着色器 (和一些 uniform 变量) 那里获取输入变量了。

优点：

*   复杂度仅 O(n+m)。
*   只渲染可见的像素，节省计算量。
*   用更少的 shader。
*   对后处理支持良好。
*   在大量光源的场景优势尤其明显。

缺点：

*   内存开销较大。
*   读写 G-buffer 的内存带宽用量是性能瓶颈。
*   对透明物体的渲染存在问题。在这点上需要结合正向渲染进行渲染。
*   对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启 MRT。（MSAA 将一个像素细分后再计算插值，计算量成倍增加，MRT 无法接受成倍的采样）
*   由于 Deferred Shading 的 Deferred 阶段是在完全基于 G-Buffer 的屏幕空间进行，这也导致了物体材质信息的缺失，这样在处理多变的渲染风格时就需要额外的操作。

延迟渲染的改进 : 延迟光照 Light Pre-Pass（即 Deferred Lighting, 分块延迟渲染 Tile-BasedDeferred Rendering

**前向渲染**

优点

*   支持半透明渲染——之前做的半透明效果的透明度测试和透明度混合都是前向渲染实现的
*   支持多个光照 Pass——这里的多个我觉得是指对于不同的光源（平行光、点光源等）可以分别进行处理吧，毕竟大多数时候还是有两个 Pass（双面渲染需要两个 Base Pass 除外）
*   支持自定义光照计算方式

缺点

*   计算复杂度很大——相比延迟渲染，只要影响到物体的光源它都给计算了，这计算量能不大嘛
*   访问深度需要额外的计算——这是因为不同于延迟渲染，直接将信息储存在了一个 G-buffer 中，只要不 clear，每次需要用的时候直接调用即可；前向渲染需要每次用到深度信息的时候都需要额外计算

几何缓冲区（G-buffer）全称 Geometric Buffer ，译作几何缓冲区，它主要用于存储每个像素对应的位置（Position），法线（Normal），漫反射颜色（Diffuse Color）以及其他有用材质参数。根据这些信息，就可以在像空间（二维空间）中对每个像素进行光照处理。

MRT: OpenGL ES 多目标渲染（MRT），即多重渲染目标，是 OpenGL ES 3.0 新特性，它允许应用程序一次渲染到多个缓冲区。利用 MRT 技术，片段着色器可以输出多个颜色，可以用于保存 RGBA 颜色、 法线、 深度信息或者纹理坐标，每个颜色连接一个颜色缓冲区。就目前接触的 MRT 技术，在图形图像算法中比较常用，主要用于获取算法中间结果、底图或者 Mask ，也用于多种高级渲染算法中，例如延迟着色和快速环境遮蔽估算。

ForwardBase：ForwardBase 通道渲染一个逐像素方向光和所有的顶点 / 球面调和光。此通道还负责渲染着色器中的光照贴图，环境光和自发光。在此通道中渲染的方向光可以产生阴影。AEGH

ForwardAdd：其他的像素广在附加通道中进行渲染，每个光源都需要一个通道。在这些通道中渲染的光源无法产生阴影。BCD

![[02e52e4782f2733d93163f93062e693c_MD5.jpg]]

球谐光照：一种低频的光照处理

14.PBR

*   PBR 是基于物理渲染的着色模型，PBR 着色模型分为材质和灯光两个属性。
*   材质部分由：基础色、法线、高光、粗糙度、金属度来定义材质表面属性的。
*   灯光部分是由：直接照明、间接照明、直接高光、间接高光、阴影、环境光闭塞来定义照明属性的。
*   通常我们写材质的时候只需要关注材质部分的属性即可，灯光属性都是引擎定义好的直接使用即可。
*   PBR 渲染模型不但指的是 PBR 材质，还有灯光，两者缺一不可。

金属 / 粗糙度工作流（简写为 M/R 工作流）采用了三张贴图来表示 PBR 所需的参数：

baseColor，RGB 贴图，表示非导体（电介质）的反照率颜色（Albedo）或金属的 F0，它不应该含有任何光照信息。metallic，灰度贴图，可以视为一个遮罩，表示金属成分的占比：1 表示 100% 的纯金属，0 表示 100% 的非金属，metallic 贴图可以用于表示金属 - 非金属的混合状态；roughness，灰度贴图，数值越大越粗糙；

M/R 工作流的优劣：主流的工作流，用途广泛；非金属的 F0 固定为 0.04，无法调整；

镜面反射 / 光泽度工作流（简写为 S/G 工作流）

Diffuse 漫反射，即 Albedo，RGB 贴图，表示非金属的 Albedo，如果是金属，Diffuse 贴图给出的值是纯黑。Specular 反射，RGB 贴图，定义金属和非金属的 F0。Glossiness 光泽度，灰度贴图，数值越大月光滑，跟 M/R 工作流的 roughness 刚好相反；

S/G 工作流的优劣：可以对金属、非金属的 F0 自由调整，但是这也非常容易做出违反能量守恒定律的材质；两张 RGB 贴图，对性能的要求会更高；

![[edad2bd5b4284fad5ba1b95e6b0ccfb5_MD5.jpg]]

shadowmap（阴影映射纹理） 原理第一次渲染时，将摄像机放置于光源处，用 depth test 获得一幅带有深度值的纹理。第二次渲染时，将摄像机放置原处，再次记录看到的点到光源的距离。将第二次得到的值与第一次得到的深度值进行比较，如果大于第一次的深度值则说明该点在阴影中，如果等于则说明不在阴影中

自遮挡 Shadow map 上面记录的是一格一格像素的不连续的深度值。

软阴影方法：PCF 对阴影进行过滤，对点周围的像素进行采样，例如为 3✖3 的每一格的深度值都与点进行比较（即判断是否被遮挡），得出一组为 3✖3 的值为 0 或 1 的表（比较得出的结果非 0 即 1），然后对这些 01 值进行加权平均（即滤波操作），最终得到一个值（大于 0 小于 1）

渐变阴影方案：PCSS 即根据遮挡物的距离来对阴影的软硬程度进行调节 PCSS 的全部操作可以概括为：

1.  计算平均 blocker 深度
2.  计算 w 值
3.  使用 PCF

第一步和第三步比较慢（因为需要大量的采样，阴影越软，采样范围越大）

VSSM（Variance Soft Shadow Mapping）VSSM 则是对第一步和第三步采样慢的一个解决思路。第三步 PCF 的本质是加权平均比较得出的 01 值，即可近似看作，有百分之多少的 texel 的深度比 shading point 的深度浅。于是我们可以把采样的问题转化成正态分布上找大概所占的百分比。但是会造成漏光。

Mipmap 多级渐远纹理（Mipmap）本质上是根据距离选择不同的纹理（但不是 LOD）Mipmap 原理类似于基于距离的线性纹理过滤（Opengl 中分为线性过滤与邻近过滤）线性过滤可以理解为对周围像素进行加权插值，得到的是一个平均颜色，邻近过滤可以理解为选择最近的一个像素颜色，Mipmap 可以避免远距离采样频率低和数据频率高造成的摩尔纹或者失真，同时具有良好的性能。

Unity 实时阴影实现——Cascaded Shadow Mapping（CSM）方向光实时阴影技术 CSM 通过把相机的视锥体按远近划分为几个级别，处于各个级别下的物体深度信息绘制到各级阴影图中，显示时采样各自对应的阴影图。获取主相机视锥顶点——计算灯光相机包围盒——构造灯光相机——主相机视锥分割——级联阴影图生成——级联阴影图采样

shadowmask：是静态的阴影，是预先计算的遮挡信息。

一张光照图由两部分组成：辐照度 (光照) 和方向性(主要光线方向编码)。

各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。

Unity 批次合并渲染

为了减少 CPU 与 GPU 交流的成本，减少 DrawCall 的数量，优化渲染，Unity 提供了合并批次进行渲染的方式，其支持**动态批次合并、静态批次合并、GPU 实例化**三种合并批次方式，这些合并批次的方式是通过操作顶点缓冲区对象（VBO）和索引缓冲区对象（EBO）等数据来进行合并处理的。相较于手动合并，unity 内置的批处理方法最大的优点是每一个物体仍然支持单独剔除。由于在 Unity 渲染优化过程中合并批次渲染非常重要

顶点缓冲区对象（VBO）：主要用于存储顶点以及顶点附带的各种属性信息，比如顶点位置、法线、颜色、UV 等

顶点数组对象（VAO）：规定 VBO 中数据的格式。比如多少空间存储顶点坐标，多少空间存储顶点法线等等

索引缓冲区对象（EBO）：负责缓存 VBO 中顶点的索引，用来解决顶点数据重复使用的问题，避免顶点数据被重复存储。举个例子，绘制一个长方形需要四个顶点、两个三角形，在没有 EBO 的情况下需要在 VBO 中存储 6 个顶点的数据（其中两个是重复的）。存在 EBO 时，VBO 中存储四个顶点的数据，通过 EBO 中的索引顺序重复调用 VBO 中相应顶点数据绘制三角形

GPU 实例化

原理：只提交一个模型的 VBO 信息，但关于多个同种模型的不同信息（位置、大小和颜色等简单数据结构的信息）另外组成 Per Instance Attribute(PIA) 缓存并提供给 GPU。当然，这个缓存是不能存储贴图信息的。GPU Instancing 技术，在模型的批处理上相当有用，比如地形上大量的草，树等，当然对于这部分可以直接静态合批处理成一整个网格，但是顶点数目又会有 65000 个的限制。这时候 GPU Instancing 就有一定的优势（关键还支持材质球上属性的差异性，比如官网的例子中就提供了颜色值的差异性）

缺点：GPU instancing 可以有效地减少 CPU 的占用率，降低显示驱动的 CPU 开销，但会在一定程度上增加 GPU 端的负担。同时，由于 GPU 实例化的原理，在同一批次处理的物体必须拥有相同的网格（动态合批没有这个限制）

SP 导入到 unity 会生成 8 张图，为 AO，基础色，高度，法线 x2，金属度，粗糙度，AOmixed，其中 unityPBR 需要 4 张

Billboard(广告牌, 公告牌)：就是使物体永远面对摄像机, 摄像机旋转, 物体也跟着旋转, 使其始终朝向摄像机. 我们在渲染树木, 灌木丛, 云，烟等效果时都会用到. 问题的实质就是我们知道结果是物体面对摄像机, 然后求物体的世界变换矩阵

蒙特卡洛算法

*   构造概率模型，使得待求解问题恰好是概率模型的某个参数，比如概率模型的期望
*   依据构造的概率模型生成样本
*   由样本建立估计量，给出问题近似解

毛发渲染 毛发的渲染：

phong, 就不必多说优点：算法简单好实现，无技术难度，计算量不大性能消耗低；缺点：经验模式，不真实。

KaijiyaKay，基于卡通的毛发渲染，是基于经验的着色模型，也就是并不是完全的着色物理正确。在 Kajiya-Kay 模型中，头发纤维被抽象化为一个不透明的圆柱体，不能够透射和产生内部反射。因此，Kajiya-Kay 模型不能表现一些肉眼观察到的头发效果，同时也是能量不守恒的。在 kajiya 中，光照主要分为 diffuse 和 Specular。现代动画中常见。缺点：莫名的高光，不是基于真是的渲染是 NPR。

Marschner(siggraph03) 是除 Kajiya-Kay 模型外另一个应用广泛的头发着色模型。Marschner 模型将头发纤维抽象为一个透明的椭圆柱体。优点：真实，经典算法；缺点：消耗大；

多 pass 的渲染：把毛发分成了很多层。每一层，顶点往法线方向 “生长” 一点点，通过控制每一层的 alpha 值来实现毛发从根部到尖部逐渐变小，每一层只渲染 alpha 大于 0 的顶点，再利用一张噪波图来控制 alpha 值，就可以调出一个毛发模型。

SSAO，即屏幕空间环境光遮蔽（Screen-Space Ambient Occlusion） 对于铺屏四边形 (Screen-filled Quad) 上的每一个片段，我们都会采样周边的深度值计算一个遮蔽因子 (Occlusion Factor)。这个遮蔽因子之后会被用来减少片段的环境光照分量。遮蔽因子是通过采集片段周围半球型核心(Kernel) 的多个深度样本，并和当前片段深度值对比而得到的。高于片段深度值样本的个数就是我们想要的遮蔽因子。

Early-Z ：提前深度测试 用来解决过多不必要的片元计算问题，顶点着色器 -> 曲面细分 -> 几何着色器 -> 光栅化 -> 提前深度测试 -> 片元着色器 -> 透明度测试 -> 模板测试 -> 深度测试 -> 混合，没有通过 Early-Z 的片元会被丢弃，不进入片元着色器进行计算，在提前阶段的位置也可以添加模板测试