这是一篇关于本人 2022 秋招（2023 届）的经历的分享帖，总计超过了两万五千字，曾经受益于许多前辈的面经分享，现在也希望自己也想分享出来，算是回馈给大家！有任何问题都可以私信或者评论~

## **1. 本人背景：**

本人 2023 届 211 硕，机械生，非科班，本科纯纯机械设计制造相关方向，读研后才开始做计算机相关的内容，研究生方向是机器视觉，刚读研时候，计算机基础知识几乎为 0，后续在学校课题组内用 C++ 做过实时三维重建，图像融合等图像相关的项目，积累了一点并行开发、CUDA、MFC 以及 OpenGL 的相关知识。通过参考许多前辈的帖子（部分链接放在文章结尾），从 2021 年春天正式决定想要走图形的方向，自学了一些图形学相关知识。有过两段实习经历，一段网易互娱暑期图形工程师的实习经历以及一段中央电视台的体育媒体工作的实习经历（纯爱好与技术无关）。

## **2. 技术栈：**

编程语言：C++

图形学学习内容：Games101 , Games202 , 部分 Games104, unity shader 入门精要, 软光追，GPU Gems3，LearnOpenGL

其他：CUDA, MFC, 数字图像处理基本知识, OpenCV

项目方面：在学校跟导师的图像相关项目、在网易实习时期间做了一些工作、自学的过程中自己尝试做了一个软光追渲染器以及用 OpenGL 实现了一些基本的简单算法。

## **3. 找工作全经历：**

（按进展程度顺序）

同花顺 视觉算法岗 简历挂

oppo 提前批 图形学工程师 简历挂

鹰角网络提前批 图形渲染算法工程师 简历挂

小红书 图形图像算法工程师 简历挂

字节跳动提前批 渲染引擎研发工程师 简历挂

联想 图形工程师 简历挂

网易雷火提前批 引擎研发工程师 简历挂

网易互联网 渲染引擎开发工程师 简历挂

鹰角网络正式批 图形渲染工程师 简历挂

Garena 图形渲染工程师 简历挂

叠纸 引擎开发工程师 简历挂

完美世界 游戏引擎开发 简历挂

紫龙游戏黑杰克 游戏研发工程师 投递无回应 (本人天地劫死忠玩家，很伤心，为投紫龙还特地花了好多时间做了一版天地劫皮肤简历)

网易雷火正式批 游戏研发工程师 笔试挂

酷家乐 图形渲染引擎工程师 一面挂

蚂蚁 技术美术 一面挂

字节跳动正式批 多媒体图形图像研发工程师 二面挂

Funplus 游戏引擎开发 二面挂

B 站 游戏算法工程师 二面后面试官告诉我最近有新项目要上线，过一阵子再继续后面的流程，此后就再无消息

米哈游 游戏客户端 三面挂 (痛，太痛了)

华为 媒体算法 泡池子

快手游戏 游戏图形学算法工程师 意向

海康威视 计算机图形工程师 offer

广联达 图形开发工程师 offer

搜狐畅游 引擎开发工程师 offer

vivo 图形驱动工程师 offer

（其中快手游戏，funplus 和米哈游给我的面试体验最为专业，让人十分舒适，遇到不会或者不确定的问题，面试官会加以引导甚至会和你一起讨论）

## **4. 个人反思及总结：**

经历了秋招大大小小的笔试面试，一次次的简历挂，说没有挫败感是不可能的，从大环境的角度来看，身边的大佬依旧一往无前，但更多的像我这样的普通人，确实是感觉寒气十足。仅从今年我个人的情况来看，只靠力扣刷题，背 C++ 八股，准备最基础的图形学理论知识，可能已经不足以底气十足地去面对图形引擎岗位了，更多的实践是必不可少的，实践是夯实自己的必要路径。这些失败确实让我看清自己很多不足之处，我总跟朋友调侃自己是个速成的理论大兵八股战士，积累和实践都远远不够，也的确如此。图形，引擎都是需要非常强动手能力的门类，我自身缺乏足够多的图形引擎项目、对商业引擎的了解深度太过浅薄以及非科班有可能是我一半公司都简历挂的主要原因，关于面试部分的失误我也会在后面面经分享中进行一点总结。

## **5. 面经分享：**

以下面经全部来自于我自己面试遇到的问题，出于很多公司保密问题，我不会标明公司，也不会完全一模一样，但表达的意思是大致相同的。有许多老生常谈的八股，我还是在这里把答案或者是答案的相关链接也一起附上，方便大家浏览。

### **5.1 C++ 及常规计算机八股部分：**

C++ 部分的学习，从我个人角度来说当初我最早入门时是看的 B 站的黑马程序员的从 0 到 1 学习 C++ 的课程（该课程我认为短小精悍，常用的东西都提了怎么用，但没有深入去讲解，不过作为完全没有基础的新手学习 C++ 的使用，我仍然十分推荐，不会一上来就把人给劝退了），之后主要来自平时项目锻炼以及侯捷的视频课程全家桶（面向对象高级开发，STL，泛型编程）。

C++ 十分博大精深，很多东西都需要慢慢在写代码过程中提升，面试常问问题也只是 C++ 的冰山一角，但这些仍然十分重要。

**1. 内存分区有哪些? 堆栈有哪些区别？**

C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：栈、堆、全局 / 静态存储区、常量存储区、代码区。

**栈**：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的局部变量、函数参数、返回地址等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。

**堆**：动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，如果进程结束后还没有释放，操作系统会自动回收。

**全局区 / 静态存储区**：存放全局变量和静态变量，程序运行结束操作系统自动释放。

**常量存储区**：存放的是常量，不允许修改，程序运行结束自动释放。

**代码区**：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

**2. 编译的过程，静态链接库和动态链接库有什么区别**

**静态链接**：代码在生成可执行文件时，将该程序所需要的全部外部调用函数全部拷贝到最终的可执行程序文件中，在该程序被执行时，该程序运行时所需要的全部代码都会被装入到该进程的虚拟地址空间中

**动态链接：**代码在生成可执行文件时，该程序所调用的部分程序被放到动态链接库或共享对象的某个目标文件中在程序执行时，当需要调用这部分程序时，操作系统会从将这些动态链或者共享对象进行加载，并将全部内容会被映射到该进行运行的虚拟地址的空间。

**二者的优缺点：**静态链接浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难），优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容；动态链接节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。

**3.new 和 malloc 有什么区别？**

1.new 在申请内存的同时，会调用对象的构造函数，对象会进行初始化，malloc 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。

2.new 可以指定内存空间初始化对象 (replacement new)，而 malloc 只能从堆中申请内存。

3.new 是 c++ 中的一个操作符，而 malloc 是 C 中的一个函数。

4.new 内存分配成功，返回该对象类型的指针，分配失败，抛出 bad_alloc 异常；而 malloc 成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。

5.new 作为一个运算符可以进行重载，而 malloc 作为一个函数不支持重载。

6.new 的空间大小由编译器会自动计算，而 malloc 则需要指定空间大小。

**4.delete 和 free 有什么区别？**

1.delete 是 C++ 中的一个操作符，可以进行重载；而 free 是 C 中的一个函数，不能进行重载。

2.free 只会释放指向的内存，不会执行对象的析构函数；delete 则可以执行对象的析构函数。

**5. 指针和引用的区别？**

1. 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向[内存](https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3D%25E5%2586%2585%25E5%25AD%2598%26spm%3D1001.2101.3001.7020)的一个存储单元，即指针是一个实体；而引用跟原来的变量实质上是一个东西，只不过是原变量的一个别名而已。

2. 可以有 const 指针，但是没有 const 引用；

3. 指针可以有多级，但是引用只能是一级；

4. 指针的值可以为空，但是引用的值不能为 NULL，并且引用在定义的时候必须初始化；

5. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变。

**6. 指针常量和常量指针，底层 const 和顶层 const？**

指针常量：

```
int * const p = &a; 
*p = 30; // p指向的地址是一定的，但其内容可以修改
```

常量指针：

```
const int *p = &a;
p = &b; // 指针可以指向其他地址，但是内容不可以改变
```

顶层 const 和底层 const 的概念：顶层 const，本身是 const（指针常量），底层 const（常量指针），指向的对象是 const 的。

**7. 三种智能是什么？智能指针原理是什么？**

C++11 中智能指针包括以下三种：

**共享指针**（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。

**独占指针**（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。

**弱指针**（weak_ptr）：指向 share_ptr 指向的对象，能够解决由 shared_ptr 带来的循环引用问题。

**8.C++ 的虚函数机制是怎样的？**

虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为 “虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。

**9. 构造函数和析构函数能不能为虚函数？**

**构造函数一般不能定义为虚函数：**

构造函数：你要有虚表指针才能找到我！

类：我没有你创建不了虚表指针！

构造函数：你必须先要有对象！！

类：我必须要找到你才能构造对象！！

构造函数：对象！！！（掀桌. jpg）

**析构函数一般定义成虚函数**，原因：析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。

**10. 虚函数表存放在哪个内存区？**

全局数据区。

这里想提一句，我第一次面试到这个问题的时候并不知道在哪个内存区，当时下意识脱口而出地说不确定了，面试官就引导我想一想，应该在哪个内存区。我们前面提到过内存分区一般总共就分五个栈、堆、全局 / 静态存储区、常量存储区、代码区。仔细一想就会发现，全局区是最靠谱的。

在这里提这个就是想提醒大家，面试官问一个问题并不用着急说不会，可以先多思考一点，也许就可以自己得出答案，就算得不出，让面试官看到你的思考过程也总之是好的。

**11.struct（int char）大小，加一个静态变量之后呢？加一个虚函数之后呢？**

8 字节（内存对齐），还是 8 字节（静态变量在全局 / 静态区），12 字节（多了一个虚函数表指针）。

**12. 创建 10 个实例有几个虚函数表？**

1 个，虚函数表数量与实例的对象数量无关。

**13. 哪些不能是虚函数：**

构造、内联、静态成员、lamda 函数

**14.i++ 和 ++i 的区别**

如果有表达式 a = i++ ；它等价于 a = i；i = i + 1；

如果有表达式 a = ++i；它等价于 i = i + 1；a = i；

++i 是一个左值（可被寻址的值）；i++ 的后面一步是自增，不是左值

**15. 左值和右值分别是什么？移动语义和完美转发是什么？**

[从 4 行代码看右值引用](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/qicosmos/p/4283455.html)

**16.std::move 实现原理？**

利用引用折叠原理将右值经过 T&& 传递类型保持不变还是右值，而左值经过 T&& 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；

然后通过 remove_refrence 移除引用，得到具体的类型 T；

最后通过 static_cast<> 进行强制类型转换，返回 T&& 右值引用。

**17. 常见容器都说一遍，插入查找算法复杂度**

[STL 中常用容器操作时间复杂度小结](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_36631379/article/details/108833192)

**18.map 和 unordered_map 区别, 讲一下 C++ 的 map 容器**

**内部实现机理不同**

**map**： map 内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而 AVL 是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。

**unordered**_map: 内部实现了一个哈希表（也叫散列表，通过把关键码值映射到 Hash 表中一个位置来访问记录，查找的时间复杂度可达到 O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。

**关于 map 容器：优点：**

有序性，这是 map 结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作

红黑树，内部实现一个红黑树使得 map 的很多操作在 logn 的时间复杂度下就可以实现，因此效率非常的高。

缺点： 空间占用率高（但 map 的空间利用率一般是高于 unordered_map 的），因为 map 内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红 / 黑性质，使得每一个节点都占用大量的空间

适用处：对于那些有顺序要求的问题，用 map 会更高效一些。

**19. 红黑树你了解多少?**

网上老梗说，面试官如果让你手撕红黑树，那你的面试多半是已经完蛋了。但一般面试中提到红黑树，都是让你说一说特性，使用场合等等，不至于要手撕的~。

下面这篇文章讲得比较清晰，关于 AVL 树和红黑树对比，红黑树的一些特性以及具体的红黑树左旋右旋的操作都有详细讲解。

[红黑树详解_晓之木初的博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/u014454538/article/details/120120216)

**20.vector 的扩容，哈希表扩容？**

vector 的扩容通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。根据编译器不同，这个扩大的倍数有所不同，以 GCC 为例，是两倍扩容。

哈希表的扩容和 vector 也很类似，在哈希表中负载因子 = 元素个数 / 散列表长度，当负载因子达到阈值，则需要进行扩容，扩容也是分配更大的散列表，然后进行 rehash，最终再将新元素插入。

**21.vector 里加入 10 万数据，游戏中有对象的指针指向这些数据，这可能有什么问题？**

这和上一个问题，vector 的扩容息息相关，vector 发生扩容时会分配更大的内存，将原内存数据拷贝过来，然后释放之前的内存，如果有指针指向此前的地址，释放之后，指针将不能正常访问到此前的数据。

**22. vector 如何快速删除内部对象。（要求 O(1) 时间复杂度）**

将要删除的对象和尾部对象 swap，然后直接 pop_back 即可。

**23. 刚刚我们聊过 vector 的扩容，那 vector 怎么减容？pop_back 之后，vector 会自动减容嘛？如果不会减容，那我们怎么释放不必要的内存呢？C++ 是否提供了我们什么接口呢？**

vector 并不会自动减容，pop_back 后 vector 也不会减容。即使我们调用 clear，也只是 size 清零，capacity 并没有真正清零。

如果要回收不必要的内存：可以调用函数 shrink_to_fit()，可以要求容器退回不需要的内存空间。其他方式，可以使用 swap 对 vector 内存进行清空，借助 swap() 方法将空容器交换给 x，从而达到清空 x 的目的。

**24. 链表遍历和数组遍历谁比较快？为什么？从 CPU 内存访问角度怎么理解？**

数组访问会更快一些。

原因：数组是具有相同的数据类型且按一定次序排列的一组变量的集合体，构成一个数组的这些变量称为数组元素数组在内存中的地址是连续相邻的，而链表在内存的地址是散列的，不连续的。

CPU 缓存会把一片连续的内存空间读入， 因为数组结构是连续的内存地址， 所以数组全部或者部分元素被连续存在 CPU 缓存里面，而链表的节点是分散在堆空间里面的，这时候 CPU 缓存帮不上忙，只能是去读取内存，而缓存的读取速率要比内存快。

**25. 给定一个链表的头节点和要删除的节点，如何 O(1) 复杂度搞定删除？**

1. 找到该节点的下一个节点。

2. 将下一个节点的值赋给该节点。

3. 让该节点的后继指向下一个节点的后继。

**26. 逻辑地址，物理地址，虚拟地址分别是什么？**

**物理地址：**它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。

**逻辑地址：**是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。

**虚拟内存：**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

**27. 线程和进程的区别？**

进程：每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在 Windows 系统中，一个运行的 xx.exe 就是一个进程。

线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。

**区别总结：**

**根本区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

**资源开销：**每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

**28. 多线程的锁有哪些？分别有什么区别呢？**

**互斥锁:** 互斥锁属于 sleep-waiting 类型的锁。例如在一个双核的机器上有两个线程 A 和 B，它们分别运行在 core 0 和 core 1 上。假设线程 A 想要通过 pthread_mutex_lock 操作去得到一个临界区的锁，而此时这个锁正被线程 B 所持有，那么线程 A 就会被阻塞，此时会通过上下文切换将线程 A 置于等待队列中，此时 core 0 就可以运行其他的任务（如线程 C）。

**自旋锁：**自旋锁属于 busy-waiting 类型的锁，如果线程 A 是使用 pthread_spin_lock 操作去请求锁，如果自旋锁已经被线程 B 所持有，那么线程 A 就会一直在 core 0 上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程 B 释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。

**虽然它的效率比互斥锁高，但是它也有些不足之处**：

自旋锁一直占用 CPU，在未获得锁的情况下，一直进行自旋，所以占用着 CPU，如果不能在很短的时间内获得锁，无疑会使 CPU 效率降低。

在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。

**29. 进程间通讯的方式？**

管道通信，消息队列，共享内存，socket，串口都可以实现。

**30. 烟花随机绽放的游戏，内存上存在什么问题**

可能会导致内存碎片造成性能下降。

**31.OSI 七层协议模型**

[OSI 七层模型详解](https://link.zhihu.com/?target=https%3A//blog.csdn.net/yaopeng_2005/article/details/7064869%3Fspm%3D1001.2101.3001.6650.3%26utm_medium%3Ddistribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-7064869-blog-122900999.t0_edu_mix%26depth_1-utm_source%3Ddistribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-7064869-blog-122900999.t0_edu_mix%26utm_relevant_index%3D6)

**32. 各种排序的平均 / 最坏复杂度。**

[图文详解—十大经典排序算法_珞沫的博客 - CSDN 博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_45666566/article/details/105383306%3Fspm%3D1001.2101.3001.6661.1%26utm_medium%3Ddistribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-105383306-blog-115428110.pc_relevant_multi_platform_whitelistv4%26depth_1-utm_source%3Ddistribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-105383306-blog-115428110.pc_relevant_multi_platform_whitelistv4%26utm_relevant_index%3D1)

**33. 介绍一下线段树**

[算法学习笔记 (14): 线段树 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/106118909)

**34. 介绍一下工厂模式**

**工厂模式**：包括简单工厂模式、抽象工厂模式、工厂方法模式

**简单工厂模式**：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。

即为：鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋子。哪个鞋炒的火爆，老板就生产哪个，看形势生产。

**扩展性非常差，新增产品的时候，需要去修改工厂类。**

**工厂方法模式：**修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。

即为：现各类鞋子抄的非常火热，于是为了大量生产每种类型的鞋子，则要针对不同品牌的鞋子开设独立的生产线，那么每个生产线就只能生产同类型品牌的鞋。要增加品牌就增加生产线。

**抽象工厂模式：**定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。

即为：鞋厂为了扩大了业务，不仅只生产鞋子，把运动品牌的衣服也一起生产了。

这个帖子有更加详细的讲解，上述例子也参考了该帖子：

[C++ 深入浅出工厂模式（初识篇） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/83535678)

**35.TCP 与 UDP 的区别**

1UDP 是无连接的，TCP 是面向连接的；

2UDP 是不可靠传输，TCP 是可靠传输；

3UDP 是面向报文传输，TCP 是面向字节流传输。

**36. 介绍对象池的实现思路，对象池回收时需要注意什么？**

```
template<typename Object>
class ObjectPool
{
public:
	ObjectPool(size_t unSize) :m_unSize(unSize)
	{
		for (size_t unIdx = 0; unInx < m_unSize; ++unIdx)
		{
			m_oPool.push_back(new Object());
		}
	}
	~ObjectPool()
	{
		std::list<Object*>::iterator iter = m_oPool.begin();
		while (iter != m_oPool.end())
		{
			delete(*iter);
			++iter;
		}
		m_unSize = 0;
	}
	Object* GetObject() {
		Object* pObj = NULL;
		if (0 == m_unSize)
		{
			pObj = new Object();
		}
		else
		{
			pObj = m_oPool.front();
			m_oPool.pop_front();
			--m_unSize;
		}
		return pObj;
	}
	void returnObject(Object* pObj) {
		m_oPool.push_back(pObj);
		++m_unSize;
	}
private: 
	unsigned int m_unSize;
	std:list<Object*>m_oPool;
};
```

最简单的对象池思路很清晰，就是预先分配好，在需要对象的时候取出管理对象的指针，用完后再返还，如以上代码所示。特别强调问题的是对象池回收时重复利用，当取出来后要注意，是不是要对对象做一次 reset 之类的操作，防止对象上一次的调用残留数据对本地调用构成影响，这个要根据自己对象的特点去进行相应的 reset 操作，比如可以有个基类 object，然后利用多态去实现调用子类的不同的 reset。（面试时面试官问我回收的具体实现，我是这样回答的，如果有比较好的答案，拜托可以在评论区一起补充~）。

### **5.2 图形学及游戏相关部分：**

图形学部分问了很多算法的实现，算法的细节都非常丰富，我在此不多做展开，只是简单叙述思路，想要仔细了解还是要阅读具体的资料或者自己动手去实现。

在这里特别强调，与简历中项目相关的内容，就会针对性地问或者问的比较深。所以最好大家都得确保对自己项目的熟悉程度，再往简历上写。

这个部分还涉及许多开放性的问题，我的这些回答，主要是我自己整理或者是面试中我自己的回答，并非什么标准答案，如果有不正确的地方，麻烦能够帮忙指出，感谢~

以下有一些问题与该面经[【游戏开发面经汇总】- 图形学基础篇](https://zhuanlan.zhihu.com/p/430541328)中问题一样，我部分摘录了这篇面经的回答，我也征得了大佬本人的同意，在此向前辈大佬表示感谢~

1. 介绍一下渲染管线，三维坐标如何变成屏幕坐标，有哪些变换？

![](1677840285118.png)

图形渲染管线实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程，在概念上可以将图形渲染管线分为四个阶段：应用程序阶段、几何阶段、光栅化阶段和像素处理阶段。

坐标变化过程如下图所示：

![](1677840285183.png)

其中特别要强调的，view 矩阵和 projection 矩阵的推导都是面试中十分常见的问题，需要掌握。

OpenGL 中的坐标系

**2.ndc 是什么，坐标范围？**

标准化设备坐标 (Normalized Device Coordinates, NDC)：标准化设备坐标是一个 x、y 和 z 值在 - 1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃 / 裁剪，不会显示在你的屏幕上。

**3. 延迟渲染管线和前向渲染管线有什么区别？各有什么优劣？**

[【《Real-Time Rendering 3rd》 提炼总结】(七) 第七章续 · 延迟渲染 (Deferred Rendering) 的前生今世](https://zhuanlan.zhihu.com/p/28489928)

**前向渲染（Forward Rendering）**，先执行着色计算，再执行深度测试。

正向渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O(n*m) 次。

Forward Rendering，光源数量对计算复杂度影响巨大，所以比较适合户外这种光源较少的场景。

```
For each light:
    For each object affected by the light: 
        framebuffer += object * light
```

![](1677840285405.png)

**延迟渲染 (Deferred Rendering)**，先执行深度测试，再执行着色计算。

延迟渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O(n+m) 次。

Deferred Rendering 的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随 光源数目变化而产生巨大变化。

```
For each object:
    Render to multiple targets For each light:
    Apply light as a 2D postprocess
```

![](1677840285446.png)

**4.Shadowmap 的了解嘛，介绍一下。除此之外还有有哪些阴影处理算法？**

[游戏中的阴影（一）：基础 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27572129)

**5. 软阴影可以怎么做？**

pcf ，pcss，vssm，sdf 等。

**pcf（percentage closer filtering）**本是用于做抗锯齿的算法，后常被用于软阴影的实现。pcf 的做法：在取 shading point 到光源的距离与 shadow map 进行比较时，不仅仅只取一个点，而是取周围范围的点，多次取平均，得到 visbility 值。例如周围九个点比较结果分别为：1,0,1,1,0,1,1,1,0，那么可见性即为 0.667。

**pcss（percentage closer soft shadow）：**我们知道往往阴影的接收物与投射物的距离越近，则阴影越硬，反之，阴影就越 “软”，pcss 正是基于这个思路去实现的。

第一步：Blocker search，从 shading point 出发，连向 light，比较 shadow map，若在阴影里则是 blocker，在一定区域内获取 blocker 的平均深度。

第二步：根据 blocker 的距离计算 filter 多大的范围（阴影软的程度）。

第三步：在该 filter 范围内做 pcf。

**vssm（variance soft shadow mapping）：**本质上可以理解为是一种对 pcss 的加速，避免了第一步和第三步中的采样。用切比雪夫测试的方式直接判断当前深度在区域范围内排序的百分比，相当于我们就直接得到了 visbility 值，这样的做法避免了大量的采样，加速了整个过程。

**sdf 阴影：**如下图所示，简单来说，是从 shading point 出发沿着灯光方向进行 ray marching，可以根据 sdf 提供的距离信息进行步进 step 优化，最终得到一个安全角度，该安全角度越小，则越暗，安全角度越大，则越亮。

![](1677840285485.png)

![](1677840285529.png)

优点：速度快（忽略生成 sdf 的时间），质量高

缺点：需要预计算，存储较高，仍然存在一定的 artifact。

**6.vssm 需要额外存储什么数据？vssm 算法会有什么问题？漏光的原因是什么？**

vssm 需要额外存储深度平方的 shadow map，因为切比雪夫测试需要知道方差，我们知道方差等于平方的期望减去期望的平方，所以我们需要额外存储该项方便计算。

vssm 存在漏光的问题：在 vssm 中我们是用切比雪夫来近似的，这种近似无需知道其本身的 pdf，实际可能并非我们近似的分布情况 (如下图的手绘积分)，如下面两张图所示，左边的树木效果很好，但是右边的镂空格子，阴影的变化剧烈，曲线不再平滑，积分结果误差就会比较大，最终就会出现漏光的现象。同时，在 vssm 中，我们还假设了接收物全部为平面，但如果接收物不是平面，阴影也会出现一些 artifact。

![](1677840285566.png)

![](1677840285612.png)

**7.CSM 是怎么做的？**

Cascaded Shadow Maps(CSM) 方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题。它将相机的视锥体分割成若干部分，然后为分割的每一部分生成独立的深度贴图。对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。

**8.IBL 的实现细节，diffuse 和 specular 部分分别是怎么做的？**

[漫反射辐照 - LearnOpenGL CN (learnopengl-cn.github.io)](https://link.zhihu.com/?target=https%3A//learnopengl-cn.github.io/07%2520PBR/03%2520IBL/01%2520Diffuse%2520irradiance/)

[镜面 IBL - LearnOpenGL CN (learnopengl-cn.github.io)](https://link.zhihu.com/?target=https%3A//learnopengl-cn.github.io/07%2520PBR/03%2520IBL/02%2520Specular%2520IBL/)

这个问题 LearnOpenGL 讲得非常详细，直接给出链接

**9. 反射探针是否了解？**

反射探针非常像一个捕捉周围各个方向的球形视图的摄像机。然后，捕捉的图像将存储为 cubemap，可供具有反射材质的对象使用。可在给定场景中使用多个反射探针，并可将对象设置为使用由最近探针生成的立方体贴图。

**10. 多个光照探针之间如何进行 blend？**

![](1677840285651.png)

对于空间中一点 P，可以用四面体的四个顶点坐标的线性组合来表示，即, P=aP0+bP1+cP2+dP3 其中 a+b+c+d=1 。而 a，b，c，d 的解法也在上图的矩阵公式里。在我们解得 a，b，c，d 之后，且点 P 确实在四面体之中，便可以用它们来对 Radiance 函数进行重采样，即 L(P,ω)=aL(P0,ω)+bL(P1,ω)+cL(P2,ω)+dL(P3,ω)。

关于四面体插值的详细内容可以参考这篇 ppt。

[GDC Vault - Light Probe Interpolation Using Tetrahedral Tessellations](https://link.zhihu.com/?target=https%3A//gdcvault.com/play/1015312/Light-Probe-Interpolation-Using-Tetrahedral)

**11.IBL 的 specular 部分的卷积，做了什么假设？这样假设会出现什么问题？**

我们使用 Cook-Torrance BRDF 的法线分布函数生成采样向量及其散射强度，该函数将法线和视角方向作为输入。由于我们在卷积环境贴图时事先不知道视角方向， 假设视角方向——也就是镜面反射方向——总是等于输出采样方向ωo。预过滤的环境卷积就不需要关心视角方向了。这意味着当从如下图的角度观察表面的镜面反射时，得到的掠角镜面反射效果不是很好。

![](1677840285686.png)

**12.IBL 一般会把图像存储在 cubemap 中，如果在一些移动端设备上，没有提供 cubemap 的相关 api，这个时候该怎么处理？**

方法一：直接把各个角度的六张图合并成一张大图，自己定义采样方式。

方法二：采用等距柱状投影图 (Equirectangular Map)

![](1677840285721.png)

**13. 如果使用柱状投影图，会有什么问题？**

水平视角附近分辨率较高，而底部和顶部方向分辨率较低。在大多数情况下，这是一个不错的折衷方案，因为大部分有意义的光照和环境信息都在水平视角附近方向。

**14. 如果需要实时进行卷积操作，diffuse 部分怎么做可以更快，更高效？、**

用球谐函数表示 diffuse 部分，两个 pass 的操作：一个是把光照环境转换到球谐表示，另一个是把它和反射函数卷积并转换回时域。

（第一次被问到这个问题时候我直接愣住，想了半天也没答对，直到面完才想起来，面试官是想问球谐，所以特地强调是 diffuse 部分。）

**15. 屏幕后处理 LUT 加滤镜是怎么做的**

该问题即为 games104 的作业二，是一种屏幕后处理，或者说是一种图像处理手段，原理简单来说就是在 LUT（ LookUpTable 颜色查找表）中找到当前颜色的映射值，用现有的 RGB 值去定位 LUT 中位置，找到映射颜色。

[图像处理之 LUT](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/fdec2a5e889f)

**16.OpenGL 抖动阶段做了什么处理？**

（我自己面的时候不知道这个。。直接说不会，摆了）

抖动（Dither），发生在逐片元阶段最后阶段，stencil test，depth test 及 blend 之后，是一种在色彩空间较小的设备上展示较大色彩空间的图像的一种方法。 例如: 在一个 RGB_565 的设备上展示 RGB_888 的图像, 展示时如果简单进行数据位截断，会造成色彩失真。抖动使用一个抖动矩阵，来调整一个像素周围像素的值，来使人眼产生错觉，模拟出原来的色彩。

这种技巧对于仅支持 8 位或者 16 位颜色信息的显示系统中非常有用。

**17.billboard 有什么作用？原理是什么？**

广告牌技术（billboarding）。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形，使得多边形看起来好像总是正对着摄像机。广告牌可以被用于渲染火焰、烟雾、云朵或者闪光，在粒子效果中运用很广泛。

广告牌技术的本质就是构建旋转矩阵，构建一个旋转矩阵需要三个基向量。广告牌技术所使用的基向量通常就是表面法线（固定为视角方向）、指向上的方向以及向右的方向。除此之外一般还需要指定一个锚点 (anchor location) ，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。

**18. 说一说蒙特卡洛的原理？**

这其实是一种以高效的离散方式对连续的积分求近似的非常直观的方法：对任何面积 / 体积进行积分——例如半球 Ω ——在该面积 / 体积内生成数量 N 的随机采样，权衡每个样本对最终结果的贡献并求和。

**19. 不用蒙特卡洛怎么表示积分？**

（我自己被问到的时候摆了... 说没想到别的）

低维空间可以用梯形法或者高斯求积公式法。

随机采样方法一般分为两类，除了蒙特卡洛以外还有拉斯维加斯方法。拉斯维加斯方法用于寻找精确解；在解渲染方程时，主要使用蒙特卡洛，蒙特卡洛方法在高维空间中它的积分收敛速度 与维度无关，仅与样本数量有关。

这里引用一个别人的例子：假如有一把锁，给我 100 把钥匙，只有 1 把是对的。于是我每次随机拿 1 把钥匙去试，打不开就再换 1 把。我试的次数越多，打开（最优解）的机会就越大，但在打开之前，那些错的钥匙都是没有用的。这个试钥匙的算法，就是**拉斯维加斯算法**——尽量找最好的，但不保证能找到。

假如筐里有 100 个苹果，让我每次闭眼拿 1 个，挑出最大的。于是我随机拿 1 个，再随机拿 1 个跟它比，留下大的，再随机拿 1 个…… 我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿 100 次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于**蒙特卡洛算法**——尽量找好的，但不保证是最好的。

**20. 大世界场景需要注意哪些问题？**

LOD, 场景空间划分，CSM，剔除，纹理过多导致的带宽或者显存问题......（这个问题十分开放，可以从许多角度回答，言之有理即可）

**21. 城市场景有什么优化思路？**

这个问题我自己当时是主要是想到剔除这个角度，因为城市场景，一般几何比较密集，若不进行合理的剔除很容易出现大量 overdraw。其他方面和上述问题一致，较为开放，可以从多角度回答。

**22. 除了 BVH 以外还有哪些空间划分方式？BVH 和八叉树各有什么适用范围？**

八叉树，稀疏八叉树，KD-Tree，BSP-Tree 等等

BVH 和八叉树的适用范围比较：

在使用上，八叉树只需要知道场景的大小和模型的精度就能进行分割，然后将模型一个个塞进去即可，而 BVH 需要了解全部的模型信息才能进行下一步分割。

BVH 的构建相对比较耗时间，而且对于动态物体的支持比较麻烦，但是射线求交这样的运行效率会更高，因此常用于离线渲染和光线追踪以及碰撞检测等对性能要求较高的场合。多用于快速判断场景对象之间的几何位置关系。

八叉树的构建简洁明了，比较直观。八叉树的结构是固定的，不会受物体位置的影响，这样对动态物体非常友好。多用于大型室外场景管理。

**23.BVH 划分节点有哪些手段，各有什么优缺点**

BVH 进行构建划分时，比较简单的手段：1. 随机选取一个维度 2. 选 Bounding box 中最长的轴进行进一步划分 3. 选取中间的三角形处进行划分（以保证两边三角形数量接近）。（我自己面试时，基本也就只答上来这几个了。。）

更加聪明的手段:

1. 基于表面积的启发式评估划分方法（Surface Area Heuristic，SAH），这种方法通过对求交代价和遍历代价进行评估，给出了每一种划分的代价（Cost），寻找代价最小方式进行划分。

2. 基于莫顿码（Morton code）的并行化 BVH 构建。

以下的文章非常详细的讲解了这个话题

[PBRT-E4.3 - 层次包围体 (BVH)（一） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/50720158)

[PBRT-E4.3 - 层次包围体 (BVH)（二） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/54620381)

[PBRT-E4.3 - 层次包围体 (BVH)（三） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/54694041)

**24. 射线和三角形求交，射线与球求交，怎么快速判断？**

**射线与三角形求交：**方法一：首先做光线与三角形所在平面求交，得到与平面的交点，比如取平面上一点 a，设交点为 p，(p-a)·n = 0, 即可解出 p 点, 然后仅需叉乘法判断该点 p 是否在三角形内即可。

方法二：moller trumbore 法直接公式判断。该方法是一种快速计算射线与三角形在三个[维度](https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3D%25E7%25BB%25B4%25E5%25BA%25A6%26spm%3D1001.2101.3001.7020)上的交点的方法，通过向量与矩阵计算可以快速得出交点与重心坐标。

[Möller-Trumbore 算法 - 射线三角形相交算法](https://link.zhihu.com/?target=https%3A//blog.csdn.net/zhanxi1992/article/details/109903792)

**射线与球求交：方法一：解析法：**直接代入球的解析表达式，解方程，求解出交点坐标。

**方法二：几何法**：

![](1677840285798.png)

大致思路为：射线起点 o 点，c 点和球的半径都是我们的已知点，从 c 作到射线的垂线，求出 h 的值，对比 h 的值和半径长度，若 h 小于 r，则与球有交点，否则没有交点。然后再求出 p 点坐标即可。还有一些可以用于加速的思路，比如 oc 连线和射线夹角如果大于等于 90 度，那么我们就可以认为不会有交点。

**25. 说一说 PBR 的原理？具体的法线分布函数有哪些？**

pbr 是一个非常大的话题，其中牵涉到的知识体系非常丰富，关于 pbr，前辈做了非常丰富的整理。

[【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR 核心知识体系总结与概览](https://zhuanlan.zhihu.com/p/53086060)

[【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/69380665)

**26. 如果我们要生成成千上万相同的对象，该怎么做？**

实例化（gpu instance），这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时 CPU -> GPU 的通信，它只需要一次即可。我们能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到 GPU 一次，然后使用一次函数调用告诉 GPU 它应该如何绘制这些实例。GPU 将会直接渲染这些实例，而不用不断地与 CPU 进行通信。

**27. 讲一讲渲染方程的物理意义**

渲染方程是一个描述光能在场景中流转的方程，它基于能量守恒定律，在理论上给出了一个完美的光能求解结果。其含义是：在某个视点看向特定的位置 x，看到的出射光亮度 (辐射率)Lo 等于 x 点的自发光亮度 Le(辐射率) 以及该点的反射光亮度之和，可以由以下公式表示：

![](1677840285850.png)

![](1677840285900.png)

![](1677840285940.png)

![](1677840285983.png)

其实就是在某个观察视角观察某一点，该点的亮度等于它本身的自发光 + 从四面八方照射到这一点后反射向观察视角的光，半球上任何一条入射光线都会产生反射，所以需要在半球上积分。通过 BRDF 可以得知反射到观察方向上具体的能量值。

在这里也顺带解释 BRDF(Bidirectional Reflectance Distribution Function) ，译作双向反射分布函数，是一个用来描述物体表面如何反射光线的方程，表示了当给定一条入射光的时候，某一条特定的出射光线的性质是怎么样的。它的精确定义是出射光辐射率 (Radiance) 的微分和入射光辐照度 (Irradiance) 的微分之比。

**28. 路径追踪的思路，具体实现细节，打到 diffuse 物体怎么做处理**

（本回答同样参考了 [Steven 王](https://www.zhihu.com/people/wang-xian-sheng-36-91-27)文章中的回答）

（1）提出背景

由于 whitted-style 的光追没有考虑漫反射物体的随机反射，而是直接停止反射了。但实际上漫反射物体也会向各个方向反射光线，所以引出了路径追踪：

（2）基本思想

路径追踪的基本思想是从视点发出一条光线，光线与物体表面相交时根据表面的材质属性继续采样一个方向（选择一个随机方向），发出另一条光线，如此迭代，直到光线打到光源上或逃逸出场景，然后用蒙特卡洛的方法，计算其贡献，作为像素的颜色值；由于单条光路的蒙特卡洛积分肯定会不准确，产生很多噪点，所以一般是单个像素发射多条光线进行路径追踪，一条路径就是视点和场景中各个物体反射交点的连线。

（3）核心算法和伪代码：

先用俄罗斯轮盘赌算法 (RR)，决定是否发出一条光线，若发出，则随机采样一个服从 pdf 分布的光线方向，发出该条光线，如果光线与光源相交，表示直接光照，直接用蒙特卡洛积分计算结果，再除以一个 P_RR，如果是物体，递归地计算交点的着色结果 (以目前发射的光线的反方向作为出射方向)，把着色结果当作一个光源的亮度，进行蒙特卡洛积分计算，同样除以 P_RR：（伪代码如下）

![](1677840286218.png)

**29. 怎么理解重要性采样？**

a. 原理：重要性采样即通过现有的一些已知条件（分布函数），想办法集中于被积函数分布可能性较高的区域 (重要的区域) 进行采样，进而可高效地计算准确的估算结果的的一种策略。

b. 理解：因为概率密度函数可能不是均匀分布的概率密度函数，有些地方出现的概率高，有的地方概率低，因此应该尽可能的多采用概率密度高的区域，否则如果用均匀采样，最后的结果不准确，也造成了计算的浪费

c. 举例：在使用路径追踪的时候，我们会随机生成一条反射光线，如果这个光线是均匀分布的话，很有可能可能许多发射出的光线最后都没有与光源相交，这样就造成了很多计算的浪费。重要性采样是说，着重去采样那些更有可能打到光源上的光线，比如更多地采样光源方向的光线：

ps：面试时还会问到，对光源的重要性采样和基于 GGX 函数的重要性采样有什么区别，我认为在数学本质上其实是一样的，就是将想办法将采样集中于被积函数分布可能性较高的区域，但出发思路有所区别，一个是从周围光源分布的角度出发，一个是从物体材质法线分布的角度出发。

**30. 碰撞检测是怎么做的，高速物体碰撞检测出现子弹的隧穿怎么办？**

该问题在 Games104 第十课物理系统中有比较详细的讲解。

碰撞检测一般分为两个阶段：

1.[broad phase](https://link.zhihu.com/?target=http%3A//www.bulletphysics.org/mediawiki-1.5.8/index.php/Broadphase) 快速找出潜在的碰撞物体列表，不在这个列表里的是绝对没可能碰撞的。broad phase 确定了一批需要进一步检查的物体。这个阶段，我们需要提前对场景进行划分，一般常用的手段包括 BVH，sort and sweep 可以帮助快速排除不需要的物体。

2.narrow phase 准确找出发生碰撞的物体列表。因为上一个阶段的部分物体实际上是没有碰撞的，需要在这个阶段剔除。常用算法包括：GJK，SAT 等。

关于隧穿情况，即为物体穿墙现象，上一帧还没碰到，下一帧已经穿过去了，没有发生碰撞的现象。连续碰撞检测 (Continuous Collision Detection, CCD) 专门处理物体之间的遂穿问题。

连续碰撞检测的目的是求出冲击时间 (Time Of Impact, TOI) ，使得物体步进 TOI 后，能够恰好与物体发生碰撞。计算冲击时间有非常多的算法可以实现，以下这篇文章有一些讲解。

[连续碰撞检测 - CCD - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/380532960)

**31. 双重缓冲和垂直同步是否了解？**

一帧画面展示到人眼需要经过显卡计算和显示器显示两个步骤，理想是显卡计算帧率和显示器刷新率一致，但现实没有那么理想。

一种是弱鸡显卡和强力显示器，如果不做处理，可能会出现显卡一帧还没画完，显示器就给显示出去了，这个解决的办法就是双缓冲，先在 backbuffer 上画，画好再送给显示器

第二种是弱鸡显示器和强力显卡，不做处理的话，可能会导致显示器刷新一次的时间够显卡算两帧了，这就导致前半段刷新的是显卡算出来的第一帧，后半段刷新的是第二帧，出现画面撕裂，解决方法就是垂直同步，限制显卡的计算频率。

**32. 移动端架构是否了解？是否有了解过 TBR 和 TBDR？你怎么理解 TBDR 中的 D？在 TBDR 上处理半透明物体怎么处理？**

(这个问题我自己面试回答的时候可以说讲得十分混乱了，以至于经常把自己绕进去，在这里系统整理了一下）

在 PC 上，显存是 GPU 直接访问的内存，是独立的，而在移动端中 CPU 和 GPU 使用的内存其实是在同一个物理内存颗粒上的，但 GPU 有逻辑上独立的内存区间。这块内存区间是 GPU 驱动来管理的。

之前的 OpenGL ES 规范中 CPU 和 GPU 之间的内存是不能共享的，Vertex 和 Texture 的 Buffer 是需要拷贝的，即使是在同一物理内存上。现在有了 vulkan，openGL 和 openGL ES 可以和 CPU 之间共享内存了，不用象以前那样拷贝来拷贝去了。

关于 TBR 和 TBDR 的管线流程如下图所示，在此也贴上了 IMR 管线方便进行对比。

![](1677840286274.png)

![](1677840286348.png)

对于 TBR 来讲，整个光栅化和像素处理会被分为一个个 Tile 进行处理，通常为 16×16 大小的 Tile。TBR 的结构通过 On-Chip Buffers 来储存 Tiling 后的 Depth Buffer 和 Color buffer。

On_Chip Memory 速度快容量小，不进行 Tiling，是无法容纳下巨大的 buffer 数据的。通过这样的做法，TBR 大大减轻了带宽的压力。

![](1677840286401.png)

**现在我们在来说 TBDR**，之所以会诞生 TBDR，主要是因为 TBR 依然没有解决 Overdraw 的问题，所以我们可以看到 TBDR 的管线中多了 HSR（Hidden Surface Removal）这一步。我们通常用来处理 overdraw 的 Early-Z 在面对以下这种情况，并不能完全避免无意义的开销：

![](1677840286444.png)

所以 PowerVR 提出了 HSR，不需要在软件层面对物体进行排序，直接提供硬件级别的支持来解决 OverDraw。

那么 HSR 是怎么做的呢：

当一个像素通过了 Early-Z 准备执行 PS 进行绘制前，先不画，只记录标记这个像素归哪个图元来画。等到这个 Tile 上所有的图元都处理完了，最后再真正的开始绘制每个图元中被标记上能绘制的像素点。

这样能达到什么效果呢，每个像素上实际只执行了最后通过 Early-Z 的那个 PS，而且由于 TBR 的机制，Tile 块中所有图元的相关信息都在片上，可以极小代价去获得。最终可以做到零 Overdraw

就是从像素级别做支持，在绘制之前再 Deferred 了一个阶段来做像素级别的深度测试，从而做到零 OverDraw，所以 TBDR 的 D 是这么来的。

**关于 TBDR 如何处理 AlphaTest 和 AlphaBlend：**

HSR 在设计上假定了前面的物体会挡住后面的物体，因此对于 AlphaTest 和 AlphaBlend 物体都是没有作用的（但他俩仍然可以被 Early-Z 拦住）。不仅没作用，反而会被其中断 Defer 流程，导致渲染性能降低。

如果在 HSR 处理不透明物体的过程中突然来了一个 AlphaTest 的图元，那么为了保证渲染结果正确，HSR 就必须要终止当前的 Defer，先把已标记好的像素都绘制出来，再进行后面的绘制。相对应的 AlphaBlend 同样也要中断 HSR 的 Defer，强制开始绘制，但是比 AlphaTest 好那么一点点的是他不影响后续图元并行地继续开始进行 HSR 处理。

[移动设备 GPU 架构知识汇总 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/112120206)

[IMR, TBR, TBDR 还有 GPU 架构方面的一些理解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/259760974)

**33. 纹理压缩有了解吗？移动端的纹理压缩呢？**

**ETC（Ericsson Texture Compression）**最初为移动设备开发，如今它是安卓的标准压缩方案，ETC1 在 OpenGL 和 OpenGL ES 中都有支持。

**DXT** 由 S3 Graphics 开发的一种与组块有关的有损压缩算法，也叫 DXTn 或 DXTC（DirectX Texture），是块截断编码（Block Truncation Coding）的一种改进。由于版权专利一般用于 Window 平台。

**PVRTC (PowerVR Texture Compression)** 由 Imagination 公司专为 PowerVR 显卡核心设计，由于专利原因一般它只被用于苹果的设备，仅 Iphone、Ipad 和部分 PowerVR 的安卓机支持。这可能是这几种压缩格式中最不公开的技术。

**ASTC（Adaptive Scalable Texture Compression）**，由 ARM 和 AMD 联合开发，2012 年发布，是较新的一种压缩格式，唯一一个不受专利权影响的压缩格式。ASTC 在压缩率、图像质量、种类上都挺不错的，也正在逐步代替前三种，最大的缺点可能就是兼容性还不够完善和解码时间较长，但以现在移动端的发展趋势来看，GPU 计算能力越来越难成为瓶颈，因此非常有希望在以后能成为统一的压缩格式。

ETC: 安卓的标准压缩方案  
DXTC/BC: 一般用于 windows 平台  
PVRTC: 一般只被用于苹果设备  
ASTC: 不受专利影响，可在任何设备使用。

[你所需要了解的几种纹理压缩格式原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/237940807)

**34. 常规性能问题应该如何分析？有哪些优化方向和手段？**

关于这个问题我自己整理了一张图：

![](1677840286483.png)

**35.GPU Driven 了解吗？**

关于 GPU Driven Render Pipeline，这篇文章中有非常详细的讲解，同时也可以参考 Games104 的第二十二讲

[GPU Driven Render Pipeline - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37084925)

**36. 帧同步和状态同步了解吗？**

[两种同步模式：状态同步和帧同步 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/36884005)

所谓同步，就是要多个客户端表现效果是一致的，例如我们玩王者荣耀的时候，需要十个玩家的屏幕显示的英雄位置完全相同、技能释放角度、释放时间完全相同，这个就是同步。而对于大多数游戏，不仅客户端的表现要一致，而且需要客户端和服务端的数据是一致的。所以，同步是一个网络游戏概念，只有网络游戏才需要同步，而单机游戏是不需要同步的。

状态同步和帧同步最大的区别就是战斗核心逻辑写在哪，状态同步的战斗逻辑在服务端，帧同步的战斗逻辑在客户端。由于核心逻辑必须知道一个场景中的所有实体情况，所以 MMO 游戏（例如魔兽世界）就必须把战斗逻辑写在服务端，所以 MMO 游戏必须是状态同步的，因为 MMO 游戏的客户端承载有限，并不能把整张地图的实体全部展现出来（例如 100 米以外的 NPC 和玩家就不显示了），所以[客户端](https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B:,:%7D)没有足够的信息计算全图的人的所有行为。

具体到客户端和服务端通信上，在状态同步下，客户端更像是一个服务端数据的表现层，举个例子，一个英雄的几乎所有属性（例如血量、攻击、防御、攻速、[魔法值](https://www.zhihu.com/search?q=%E9%AD%94%E6%B3%95%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B:,:%7D)等等）都是服务端传给客户端的，而且在属性发生改变的时候，服务端需要实时告诉客户端哪些属性改变了，客户端并不能改变这些属性，而是服务端传来多少属性就显示多少属性（虽然可以改变客户端数值达到表现上的效果，例如[无限血量](https://www.zhihu.com/search?q=%E6%97%A0%E9%99%90%E8%A1%80%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B:,:%7D)，但是服务端那边的血量属性为 0 时，一样要死）。

而在帧同步下，通信就比较简单了，服务端只转发操作，不做任何逻辑处理。现在同一局里有 4 个玩家，也就是 4 个客户端，这时客户端 A 释放了一个技能 x，此时将操作传递给服务端，服务端不做任何判断，直接把 A 的操作全部分发给 ABCD，则 ABCD 同时让客户端 A 控制的英雄释放技能 x。

**37.z-fighting 怎么处理？ 动近平面和远平面哪一个比较好？**

1. 不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，可以完全避免这两个物体之间的深度冲突。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。

2. 将近平面设置远一些。

3. 牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是 24 位的，但现在大部分的显卡都支持 32 位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。

**动近平面会更好**：精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。

**38. 欧拉角定义的旋转矩有什么问题，怎么处理？**

欧拉角定义了绕着三个坐标轴的旋转角，来确定刚体的旋转位置的方式，包括俯仰角 pitch，偏航角 yaw 和滚动角 roll；它的优点是比较直观，而且单个维度上的角度也比较容易插值；缺点是它不能进行任意方向的插值，而且会导致万向节死锁的问题，旋转的次序对结果也有影响。

可以构造新层级，不同的坐标轴嵌套关系。（不能根本避免，只能尽量选取合适的旋转顺序）

要从根源上解决，就不能用欧拉角的方式定义，而是使用四元数。

**39. 讲一下四元数原理，四元数怎么实现旋转**

Games104 第八课动画系统中有对四元数的详细讲解，推荐大家观看。

以下文章也非常 nice

[如何形象地理解四元数？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/23005815/answer/33971127)

**40. 抗锯齿算法知道哪些？**

SSAA, MSAA，FXAA, TAA

**41.8 倍的 MSAA，缓冲区大小也要 8 倍吗？MSAA 和延迟渲染不能共存只是带宽和显存的问题吗？**

是的，MSAA 会带来更大的缓冲区开销。MSAA 对延迟渲染的支持不是很好；有几个原因，一个是 MSAA 本质上是一种发生在光栅化阶段的技术，也就是几何阶段后，着色阶段前，这个技术需要用到场景中的几何信息，但是延迟渲染因为需要节省光照计算的原因，事先把所有信息都放在了 GBuffer 上，着色计算的时候已经丢失了几何信息；而且关键一点是如果强行这么做，MSAA 会增加数倍的带宽性能消耗，因此一般都不会这么做。还有一个原因是是以前 DX9 的时代，MRT (多重渲染目标) 技术不支持 MSAA。

**42.TAA 存在哪些问题？如何解决拖影？**

从时间维度上进行抗锯齿处理，使用同个像素在不同帧上的不同采样点，根据时间先后进行一个加权平均计算，这也造成了 TAA 的缺点，就是容易出现鬼影和抖动的现象；

关于拖影闪烁灯问题的解决方案：

[TAA 的各种 artifact 及解决方案 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/112565771)

[主流抗锯齿方案详解（二）TAA - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/425233743)

**43. 全局光照算法了解哪些？**

RSM，LPV, VXGI, SSGI, DDGI，PRTGI 以及终极解决方案实时光追等等。

**44. RSM, LPV ,VXGI 怎么处理的？**

这些算法的细节都非常丰富，这里只是做简单的叙述：

**RSM:**

1. 找到哪些表面被直接照亮，可以直接用 shadow map 的做法，shadow map 上每个像素可以认为是一个次级光源。

2. 将次级光源的贡献计算到着色点上去（这里将所有反射物假设为 diffuse 的，同时也无视了次级光源到着色点的可见性）。

具体视线中，只判定离 point 比较接近的 patch 的贡献。在世界空间中很难寻找距离比较近，所以在 shadow map 中找。

所以在 RSM 算法中需要额外存储 Depth，世界坐标信息（用于渲染方程中算距离），normal（算 cos 项），flux。

优点：流程简单，和 shadow map 几乎一致。很适合手电筒这类光源。

缺点：每多一个直接光源，就多一遍计算

做了太多假设，将 depth 当做距离使用，将所有 reflector 全部视为 diffuse，未考虑可见性导致漏光问题，这些都造成结果不够真实。

**LPV：**

1. 用 RSM 的操作来确定次级光源

2. 应用一个 3 维的纹理，对空间做 pre-subdivide，在划分好的格子内找到被包住的光源，相加虚拟光源的贡献，用两阶 SH 来描述虚拟光源向四面八方的 Radiance 分布。

3. 将 Radiance 向着周围六个格子传播，重复迭代。

4. 渲染，看 shading point 在哪个格子里，根据 Radiance 情况进行渲染。

算法问题：仍然是有 light leaking，因为 radiance 传播过程不考虑可见性，几何粒度如果小于格子划分粒度，就会出现 leaking，但如果细化格子，会带来更大的开销。

**VXGI：**

1. 从 light 出发：在每个体素中记录他的入射光线的分布以及法线的分布，方便计算出射的情况。

2. 从 camera 出发：从 shading point 连接一个圆锥出去。与圆锥相交的体素，全部计算一遍贡献。

优化手段：圆锥打出去，会越来越大，划分的体素就可以划分层级，圆锥越来越大，就与越来越大层级的体素求交。

问题：对于 diffuse 的物体，要向这周围打多个大圆锥来模拟 diffuse。体素化开销比较大，动态体素化会相对慢一些。

上述几个问题推荐看闫令琪老师的 Games202 中的全局光照部分以及王希老师 Games104 第二十一课，都有非常详细的讲解。

如果这些算法没有全部自己实现过，只是了解理论，也可以在讲得过程中大胆说出来，自己没有实现过，否则很多时候往深了问，很难面面俱到地回答好，这反而会先给面试官一个很高的期望，最后又让面试官失望。可以先降低一点面试官的期望阈值，再多讲一点给面试官惊喜，这样效果会更好。（血泪教训）。

**45.SSR 怎么做的，ray marching 是如何进行的？**

SSR 步骤：找 view 向量打到 shading point 后的反射向量与场景的交点，寻找交点的过程是一个 ray marching 的过程，并将交点的颜色值作为 shading point 的渲染参考。

![](1677840286521.png)

SSR 的核心是加速 ray marching 的求交，我们可以通过做一个基于深度的层级加速结构，如如果射线与上层的深度图都没有相交，那更不可能与子节点相交。如果一直没有交点，则可以大胆提升求交的 mipmap 层级，如果产生了交点，则需要更为精细小心地求交。

![](1677840286767.png)

SSR 的优点：速度快，特别对于 specular 和 glossy 的物体，效果也很好。

SSR 存在的问题：screen space 中普遍存在的问题，信息局限于屏幕，我们只能看到一层壳（深度），看不到后面的信息。Diffuse 物体不好处理。

具体可以直接观看闫老师的 games202 的 Lecture9。

**46. 如果要用在移动端 你觉得哪些 GI 算法优化之后是可行的？LPV，SSGI 如果要用在移动端，需要进行哪些方面的优化？**

我自己回答了 DDGI、SSGI 以及 LPV。我自己当时尝试从体素划分角度去回答 LPV 的优化，SSGI 中提到了 ray marching 合理优化步长，在提示下还说了一些时域的做法。

### **5.3 面试手撕题部分：**

这部分我最深的感触是刷题在精不在多，如果你的准备时间有限，没有必要去花太多时间去做没做过的题目，尽可能多刷几遍剑指 offer 或者是 LeetCode 上的 hot100 题，刷透才能让自己举一反三，没有刷透，盲目去多做，遇到新题目还是得直奔题解，做过的题目也很容易还是不会做。最终面试手撕代码的主要问题也确实基本都出自剑指 offer 和 LeetCode 的热题。

以下全部为我自己面试时碰到过的原题：

重建满二叉树

LRU 力扣 146 题

奇数放前面，偶数放后面 剑指 offer21 题

贪心发糖问题 力扣 135 题

排序二维数组高效查找，要求用二分和 Z 字查找都写一遍 剑指 offer04 题

力扣热题 岛屿数量问题 力扣 200 题

岛屿问题进阶，如果要搭桥把所有岛屿连接起来，求出岛屿占据的最少像素数（bfs + 连通域间最短距离 + 图论最短路径）

编辑距离 力扣 72 题

带括号的加减乘除

带去重的归并排序

三个点落在同一个半圆的概率

0-4 随机数生成 0-6 随机数

找到二叉树中的最大子搜索二叉树

A * 寻路

手写 blinn-phong shader

手写旋转，平移，缩放矩阵

HLSL/GLSL 写采样

### **5.4 技术面遇到的开放性问题：**

C++ 实际解决过哪些问题？

项目难点，如何解决，做多线程的时候遇到过哪些麻烦，怎么解决的？

对图形引擎 / 技术美术岗位的理解和看法？

图形学学习过程？

OpenGL 学了多长时间？

怎么在游戏中优化 cache 访问？

unity 了解程度，用过哪些功能？

你平时怎么 debug 的？

C# 的了解嘛？

blender 的了解嘛？是否会使用 blender 的脚本系统

懂不懂粒子系统和效果？

骨骼动画是否有了解？

用过哪些 debug 或者性能分析工具？

平时玩什么游戏？最近玩了什么游戏？喜欢什么类型的游戏？

原神的全局光照和屏幕后处理有了解吗？（不是米哈游问的，而且不止一家公司问了，我说玩过原神。。就会开始问）

战神 4 你觉得哪里好，你觉得奎爷那把斧子的技术难点在哪里？（因为我说最近一年玩过刚上 pc 的战神）

编译型语言和解释型语言有什么区别？

看过哪些印象深刻的技术博客吗？

说一件在技术上让你比较有成就感的事情，或者说是什么让你有成就感。

为什么想做游戏引擎？

## **6. 写在最后：**

图形 / 引擎 / 游戏研发是非常有意思的门类，我相信大家之所以走上这条道路绝大多数的人是因为热爱游戏。这几年优秀高质量的学习资料可以说井喷，games 系列的课程几乎都拥有极高的质量，如果能学得足够透彻，一定会更加得心应手（虽然很多是像我一样的应届生仓促地学完就鸭子上架接受拷打了）。至于学历方面，在这一行业并不是很重要，实践能力和知识储备更为重要，我见过很多本科生，比我这个半道子入行的非科班研究生不知道强到哪里去了，不过要提醒的是，现在确实有不少公司的图形 / 引擎岗会卡本科生了，虽然我认为毫无必要，但这可能是优秀人才越来越饱和的必然结果吧，最后提醒大家也是提醒我自己，切勿眼高手低，切记脚踏实地。

我的整个秋招也算是一波三折，最终虽然略有遗憾，但也算是较为圆满地结束了，我这个水平，能拿 offer 已经非常知足。

祝大家在学习的过程中也能收获快乐，前程似锦！

如果有任何问题欢迎评论或私信！

最后在这里感谢一些对我帮助极大的帖子，感谢前辈们的无私分享！

[【游戏开发面经汇总】- 计算机基础篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/417640759)

[【游戏开发面经汇总】- 图形学基础篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/430541328)

[字节朝夕光年 游戏引擎开发面经 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/479490559)

[参加数十次校招笔试面试后，我做了全面的总结（游戏开发岗） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/157355850)

[长文面经：零基础游戏渲染 / 图形引擎开发之路_笔经面经_牛客网 (nowcoder.com)](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/831724)

[秋招落幕，给非科班零基础想转行游戏开发的同学分享一些经验_笔经面经_牛客网 (nowcoder.com)](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/555201)