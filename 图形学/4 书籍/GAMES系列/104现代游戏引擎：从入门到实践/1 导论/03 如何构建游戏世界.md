本节课中我们会开始构造整个游戏世界。

![](1680591979306.png)

# 如何描述世界

## Game Object

首先我们要考虑游戏世界是由哪些组件构成的。以[《战地 2042》](https://www.ea.com/zh-cn/games/battlefield/battlefield-2042)为例，游戏中包含了大量的可互动对象包括坦克、无人机、火炮、士兵等。

![](1680591979922.png)

除此之外，游戏中还包含了很多静态的对象比如说各种建筑物。

![](1680591980489.png)

这些动态和静态的游戏对象都依附于游戏场景，一般来说场景包括天空、植被以及地形等。

![](1680591981024.png)

在玩家看不到的地方还有一些其它类型的游戏对象，它们为整个玩法提供支持。

![](1680591981543.png)

总结一下，游戏世界是由各种各样的**游戏对象 (game object, GO)** 组成的。

![](1680591982101.png)

## Components

那么如何描述一个游戏对象呢？最直观的方法是使用面向对象编程的思路把 GameObject 划分为属性和行为。

![](1680591982639.png)

![](1680591983194.png)

同时，不同 GO 之间的依赖关系还可以通过继承的方式来加以描述。

![](1680591983754.png)

![](1680591984298.png)

但在实践中人们发现 GO 之间的关系往往是非常复杂的，仅通过继承的方式无法完整地描述不同对象之间的关系。

![](1680591984912.png)

因此在现代游戏引擎中一般是通过**组件化 (components)** 的方式来描述一个对象，这样每个 GO 都可以拆分成若干个相互独立的组件。

![](1680591985432.png)

![](1680591985965.png)

以无人机为例，我们可以把任意形式的无人机拆分成 Transform、Motor、Model、AI 等组件，然后单独实现每个组件的功能。

![](1680591986510.png)

![](1680591987031.png)

这样当我们想要取定义新的无人机类型时只需要替换相应的组件即可。

![](1680591987574.png)

目前市面上常见的商业游戏引擎，包括 Unity 和虚幻等都使用了**组件化**的设计思想。我们在设计自己的游戏引擎时也应遵循这样的设计理念。

![](1680591988133.png)

> [!warning] Title
> UE 中的 UObject 不是上述讲的 GameObject，他需要确定任何对象生命周期的管理、内存管理、句柄等。Actor 才是类似 GameObject 的东西。


![](1680591988669.png)

> [!NOTE] 总结
> - 游戏世界中的一切都是 GameObject
>- GameObject 可以用基于组件 Components 的方式进行描述

# 如何让游戏动起来

### Tick

接下来我们考虑如何让整个游戏世界动起来。我们可以在每个时钟周期中分别对每个 GO 调用 tick() 函数，这种方式称为 **object-based tick**。

![](1680591989277.png)

**现代游戏引擎的 tick() 函数的方式是采用流水线的方法，以组件作为基本单位，每个时钟周期内我们依次 tick 不同 GO 的同一类组件。这种方式称为 component-based tick。**

![](1680591989819.png)

component-based tick 相对要反直觉一点，但却有着更高的性能。component-based tick 相当于把系统的 tick() 函数分解成流水线，这样可以提高系统的并行性并重复利用缓存。

![](1680591990358.png)
|基于对象的tick |基于组件的tick|
|:--|:--|
|简单直观|并行化处理，更高效|
|易于调试|减少缓存未命中|

### Events

在调用 tick() 函数时不同的 GO 需要进行通信以确定自身的行为。早期的游戏引擎通过硬编码（hardcode）的方式来编写所有可能的通信行为。

![](1680591990902.png)

当然在现代游戏引擎中已经抛弃了这种过于低效的通信方式，而是使用**事件 (event 机制)** 实现 GO 之间的交互。当某个 GO 需要和其他对象进行通信时，它会直接向相应的对象发送一个 event，而接收到这个 event 的对象则会在下个时钟周期进行处理。这样我们无需考虑系统中每种 GO 可能的通信方式，通过 event 机制实现了 GO 之间的**解耦**。

![](1680591991455.png)

在商业游戏引擎中就使用了 event 机制来实现 GO 之间的通信。
Unreal 比较复杂，涉及到反射机制。

![](1680591992000.png)

# 如何管理 GameObjects

当场景中的 GO 数量不断增加时我们就需要考虑如何高效地管理它们。一般来说对于场景中的每个 GO 我们会为它赋予一个识别号 UID 以及位置坐标，这样当 GO 之间就可以根据空间位置进行交互。

![](1680591992557.png)

> [!quote] 场景管理
> - 在场景中管理游戏对象
> - 游戏对象查询
> 	- 按唯一的游戏对象 ID
> 	- 按对象位置

最简单的管理方式是不管理，当 GO 需要进行交互时通过直接遍历的方式来查找对象。显然这种方式是过于低效的，随着 GO 数量的增加遍历的代价会按平方函数进行增长。
稍微好一点的管理方式是把场景划分成一个均匀的网格，这样需要进行查询时只考虑相邻格子中的 GO 即可。但如果 GO 在网格上不是均匀分布，这种管理方式的效率仍然很低。

![](1680591993144.png)

更合理的管理方法是**使用带层级的网格**，这种方式的本质是使用一个**四叉树**进行管理。这样进行查询时只需要对树进行遍历即可。

![](1680591993915.png)

![](1680591994613.png)

**除了四叉树之外，现代游戏引擎进行场景管理时还会使用 BVH、BSP、octree、scene graph 等不同类型的数据结构。**

![](1680591995341.png)

![](1680591996114.png)
> [!quote] 总结
> - 一切都是Object
> - GameObject可以用基于组件的方式描述
> - GameObject的状态在勾选循环中更新
> - GameObject之间通过事件机制进行交互
> - GameObject在场景中使用高效策略进行管理

本节课最后讨论了一下商业游戏引擎中 event 机制的实现。由于不同 GO 之间的依赖关系，直接使用 event 进行消息传递可能是不合理的（比如两人互相发送 event，会导致一些冲突）。同时为了高效的利用多核 CPU，在商业游戏引擎中会使用“邮箱” 的方式来代替 GO 之间的直接通信。
邮局的运行机制：图中的信封代表 Event，我们规定 GO 直接不可以直接通信，GO1 将信封存入邮箱，其他人从中取出来之后，才允许下一个 GO 存邮件。“邮箱” 的意义在于可以保证系统的严格时序，从而确保整个系统是**确定的 (deterministic)**，不会由于多核并行产生不同的运行结果。
![](1680591996915.png)

