这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 ([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/)) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中的玩法系统。

## Overview

玩法系统是游戏引擎最重要的部分，它是区分游戏引擎和渲染器以及物理引擎的核心。实际上玩法系统往往会贯穿整个游戏引擎，与引擎的其它系统进行交互，这样才能满足游戏设计师的需求。

![](1680600428200.png)

另一方面现代游戏的玩法是极其丰富的，即使是同一类型的游戏也具有多种多样的表现形式。这些丰富的游戏内容都需要通过玩法系统来进行实现。

![](1680600429020.png)

而在游戏行业中玩法系统还面临着快速迭代的问题，同一个游戏的核心玩法在开发运营初期和后期可能会有着巨大的差别。因此玩法系统在设计时也需要考虑需求变更和快速迭代。

![](1680600429864.png)

## Event Mechanism

玩法系统的核心是**事件机制 (event mechanism)**，在游戏世界中不同类型的 GO 会通过事件 / 消息的方式进行通信从而驱动游戏世界的运行。

![](1680600430721.png)

![](1680600431522.png)

### Publish-Subscribe Pattern

在游戏引擎中一般会使用 **publish-subscribe** 这样的模式来实现具体的通信过程。在 publish-subscribe 模式中每个 GO 有着自己的 publish 功能来向其它 GO 发送事件，同时自身的 subscribe 功能来实现接收事件以及相应的反馈。当然在 publish-subscribe 模式中还需要一个 **event dispatcher** 来执行高效的事件派送。因此在 publish-subscribe 模式中的三要素为**事件定义 (event definition)**、**注册回调 (callback registration)** 以及**事件派送 (event dispatching)**。

![](1680600432326.png)

![](1680600433142.png)

### Event Definition

事件定义是实现事件机制的第一步，最简单的定义方式是为事件定义一个类型以及相应的参数。

![](1680600433990.png)

因此我们可以使用继承的方式来实现不同类型事件的定义。但这种方式的缺陷在于玩法系统往往是由设计师来实现的，而对于游戏引擎来说一般无法由程序员事先确定。

![](1680600434826.png)

在现代游戏引擎中会使用反射和代码渲染的方式来允许设计师自定义事件类型和相关的数据。

![](1680600435681.png)

### Callback Registration

当 GO 接收到事件后就会激活调用相应的回调函数来改变自身的状态，而为了正确地使用回调函数则首先需要对不同的回调函数进行注册。

![](1680600436505.png)

回调函数的一大特点在于它的注册和执行往往是分开的。这一特点可能会导致回调函数调用时相关的一些 GO 可能已经结束了生命周期，因此回调函数的安全性是整个事件系统的一大难题。

![](1680600437362.png)

![](1680600438177.png)

为了处理这样的问题我们可以使用**强引用 (strong reference)** 这样的机制来锁定相关 GO 的生命周期。强引用会保证所有和回调函数相关的资源在回调函数调用前不会被回收，从而确保系统的安全。

![](1680600439011.png)

当然强引用的方式在一些场景下可能是不合适的，很多时候我们希望某些资源可以正确的卸载掉。因此我们还可以使用**弱引用 (weak reference)** 的机制在调用回调函数时判断资源是否已经被卸载掉。当然弱引用机制的滥用可能会影响整个系统的性能。

![](1680600439896.png)

### Event Dispatching

事件会通过分发系统来实现消息的传递。由于游戏中每一时刻往往存在着成千上万个 GO 和相应的回调函数，我们需要一个非常高效的分发系统才能保证游戏的实时性。

![](1680600440766.png)

最简单的分发机制是把消息瞬时发出去。这种方式的缺陷在于它会阻塞前一个函数的执行，从而形成一个巨大的调用栈使得系统难以调试；此外很多回调函数在执行时会申请一些额外的资源，这就容易导致游戏的帧率很难稳定。

![](1680600441601.png)

![](1680600442450.png)

![](1680600443268.png)

![](1680600444108.png)

现代游戏引擎中更常用的分发方式是使用**事件队列 (event queue)** 来收集当前帧上所有的事件，然后在下一帧再进行分发和处理。

![](1680600444918.png)

由于 event queue 中有不同类型的事件，因此我们还需要结合序列化和反序列化的操作来进行存储。

![](1680600445766.png)

event queue 一般会使用 ring buffer 这样的数据结构来实现，这样可以重用一块统一的内存空间来提升效率。

![](1680600446574.png)

现代游戏引擎中往往会同时有多个不同的 event queue 来处理不同类型的事件，每个 queue 用来保存一些相对独立的事件。这种方式可以便于我们进行调试，也可以提升系统的性能。

![](1680600447428.png)

当然 event queue 也有一些自身的问题。首先 event queue 无法保证 event 执行的顺序，同时对于一些实时性的事件 event queue 可能会导致执行的延误。

![](1680600448274.png)

![](1680600449146.png)

## Game Logic

在事件机制的基础上就可以开始设计游戏的逻辑了。在早期的游戏开发中会直接使用 C++ 来编写游戏的逻辑来获得更高的运行效率，而随着游戏系统变得越来越复杂这种直接基于高级语言的开发方式就不能满足开发者的需求了。

![](1680600449957.png)

![](1680600450829.png)

除此之外游戏引擎面对的用户往往是设计师而不是程序员，对于设计师来说直接使用编程语言来设计游戏可能是过于复杂的。

![](1680600451694.png)

因此在现代游戏引擎中往往会使用脚本语言来实现游戏的开发工作，它的优势在于它可以直接在虚拟机上运行。

![](1680600452529.png)

![](1680600453400.png)

因此我们可以把游戏中的很多逻辑使用脚本语言来实现。

![](1680600454219.png)

![](1680600455071.png)

![](1680600455888.png)

![](1680600456722.png)

脚本语言的另一大特点是可以进行热更新。

![](1680600457603.png)

当然脚本语言也有许多缺点，比如说它的效率一般会比较低，因此选择合适的脚本语言是十分重要的。

![](1680600458422.png)

![](1680600459260.png)

目前游戏行业中常用的脚本语言包括 Lua、Python、C# 等。

![](1680600460169.png)

![](1680600460985.png)

## Visual Scripting

**可视化脚本 (visual scripting)** 是现代游戏引擎几乎必备的功能。和传统的脚本语言相比可视化脚本无需开发者直接进行编程，因此它对于设计师和艺术家而言更容易进行掌握。像虚幻和 unity 这样的商业级游戏引擎都实现了自身的可视化脚本功能。

![](1680600461850.png)

当然可视化脚本本身也是一种编程语言，它需要实现相应的变量、语句、表达式、控制流程、函数甚至面向对象编程等功能。

![](1680600462683.png)

以虚幻引擎的 blueprint 功能为例，每个变量需要封装数据类型以及作用域两种属性。而在可视化脚本中，不同类型的数据会使用不同的颜色来方便用户进行区分。

![](1680600463498.png)

![](1680600464332.png)

在变量的基础上可以构造表达式，在可视化脚本中会使用节点来进行表示。

![](1680600465137.png)

![](1680600465977.png)

而控制语句则会使用三角形的符号来表示。

![](1680600466807.png)

![](1680600467638.png)

类似于高级语言中函数的概念，我们可以在可视化脚本中把节点按照一定的顺序连接起来形成一张图。

![](1680600468496.png)

![](1680600469411.png)

我们还可以把数据和函数打包在一起，这样就形成了类的概念。

![](1680600470239.png)

![](1680600471121.png)

除此之外在可视化脚本中往往还需要提供一些方便用户操作的功能，如查找节点、调试等功能。

![](1680600471993.png)

![](1680600472850.png)

可视化脚本也有一些自身的问题。首先可视化脚本很难进行协作，在大型开发团队中很难把每个开发者定义的脚本直接组装到一起，往往需要通过大量人工的重新排序才能得到正确的结果；同时当脚本中的节点过多时整个脚本在视觉上可能会非常繁琐，让人难以阅读。

![](1680600473717.png)

![](1680600474540.png)

![](1680600475336.png)

## Character, Control and Camera

**角色 (character)**、**控制 (control)** 以及**镜头 (camera)** 是构成玩家体验最重要的元素。

![](1680600476173.png)

### Character

角色是指游戏中如何设置玩家控制角色以及 NPC 的运动和各种状态。

![](1680600477017.png)

在现代游戏中角色的运动往往涉及大量不同的动画和状态改变，我们需要非常多的细节才能设计出符合人认知的角色运动。同时在游戏世界中角色还需要和环境中的各种元素进行互动，往往需要结合游戏引擎其它系统进行设计。

![](1680600477846.png)

![](1680600478687.png)

![](1680600479554.png)

![](1680600480435.png)

因此角色系统一般需要一个非常复杂的状态机模型来描述角色状态的切换和转移。

![](1680600481303.png)

### Control

控制系统的核心问题是要兼容玩家不同的输入设备。

![](1680600482227.png)

来自控制器的信号通过控制系统会转换成游戏可以识别的输入，然后通过事件机制来控制角色。

![](1680600483042.png)

![](1680600483975.png)

![](1680600484800.png)

同时我们还可以利用控制器的反馈功能来进一步提升玩家的游戏体验。

![](1680600485624.png)

![](1680600486428.png)

![](1680600487276.png)

### Camera

镜头会直接描述玩家视角中看到的场景和事物。

![](1680600488180.png)

从实现角度来说，我们只要设置好相机的位置和视角就可以直接利用渲染系统来实现镜头的功能。

![](1680600489063.png)

在游戏场景中最常见的情况是相机要绑定在玩家控制的角色身上，随着角色的运动一起运动。同时我们还需要保证相机在运动的过程中不要出现穿墙等各种问题。

![](1680600489906.png)

![](1680600490767.png)

镜头系统的一大难点在于如何根据角色的状态来调整相机的相关参数，使游戏画面更接近于人眼的真实反映。

![](1680600491605.png)

同时镜头系统也需要考虑各种相机特效的实现，包括镜头抖动、动态模糊等。

![](1680600492492.png)

在复杂场景中往往还会有多个相机同时存在，因此我们也需要管理这些相机和相关参数。

![](1680600493464.png)

整个镜头系统对于提升和改善玩家的游戏体验起着至关重要的作用。

![](1680600494389.png)

![](1680600495229.png)

因此游戏引擎中的镜头系统需要允许用户使用脚本或是可视化脚本来编辑相机的各种属性和参数。

![](1680600496055.png)

## Reference

*   [Lecture 15：Gameplay Complexity and Building Blocks](https://www.bilibili.com/video/BV1u34y1H7jd?vd_source=7a2542c6c909b3ee1fab551277360826)