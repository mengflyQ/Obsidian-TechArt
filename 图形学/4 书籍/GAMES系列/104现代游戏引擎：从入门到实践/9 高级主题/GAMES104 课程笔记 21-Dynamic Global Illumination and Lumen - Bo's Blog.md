这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 ([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/)) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎中的全局光照技术。

## Global Illumination

### The Rendering Equation

**全局光照 (global illumination, GI)** 是渲染中的重要问题。在介绍 GI 在游戏引擎的实现方法前我们先回顾一下**渲染方程 (the rendering equation)**：

![[3466d5f587122b22b187394ad75ab3ef_MD5 1.png]]

可以说一切渲染问题的本质在于求解渲染方程，而求解渲染方程的难点在于方程自身的递归形式。当场景中的物体被光源照亮后，被照亮的物体又会成为新的光源再次照亮其它物体。以 Cornell box 为例，来自屋顶的灯光会照亮左右两侧红色和绿色的墙壁，然后墙壁反射的光线又会照亮盒子使得盒子的两侧呈现红色或是绿色，这样的现象称为 **color bleeding**。

![](1680600989252.png)

![](1680600990167.png)

在复杂的游戏场景中通过 GI 会极大地提升画面表现力。

![](1680600991012.png)

### Monte Carlo Integration

作为积分方程，求解渲染方程的经典方法是 **Monte Carlo 积分 (Monte Carlo integration)**。对于可积函数 f(x)$f(x)$，我们可以通过采样的方法来逼近 f(x)$f(x)$的积分。

![](1680600991822.png)

![](1680600992670.png)

**光线追踪 (ray tracing)** 算法的本质就是通过 Monte Carlo 积分来求解渲染方程。

![](1680600993524.png)

### Importance Sampling

Monte Carlo 积分的效率和精度取决于如何设计采样的样本。当样本的数量比较少或是质量比较低时，通过光线追踪渲染出的图像往往会具有非常多的噪声。

![](1680600994439.png)

因此如何设计采样的分布对于提升渲染质量有着非常重要的意义，其中最简单的采样方法是均匀采样。

![](1680600995278.png)

现代高质量渲染的核心技术在于**重要性采样 (importance sampling)** 的大规模应用。重要性采样理论指出当我们的采样函数接近于被积函数时只需要相对少的样本就可以很好地近似被积函数的积分，而在计算 Monte Carlo 积分时只需要对样本按照 pdf 进行加权求和即可。

![](1680600996128.png)

![](1680600996969.png)

回到渲染方程中，被积函数包含余弦项 cosθi$\cos \theta_i$，因此一个常见技巧是根据余弦项进行采样；类似地也可以按照 BRDF 来进行采样，这种采样方式对于光泽表面的物体往往有着更高的积分效率。

![](1680600997873.png)

![](1680600998696.png)

![](1680600999527.png)

## Reflective Shadow Maps

尽管通过光线追踪可以解决 GI 的问题，但它的主要缺陷在于光线追踪基本无法应用在游戏这样有实时性要求的场景中。为了实现实时的 GI 人们设计了各种各样的算法来进行近似，其中最早的工作可以追溯到 2005 年的 **reflective shadow maps(RSM)** 算法。

从实现的层面上讲，RSM 更接近于**光子映射 (photon mapping)**。光子映射理论认为相机接收到的 radiance 本质是由光源发射的光子经过场景不断的吸收和反射最终的被相机捕获的结果，因此我们可以从光源出发发射大量的光子然后计算光子在场景上的分布，然后通过相机来进行收集即可。

在 RSM 中我们需要从光源的位置首先渲染一张 shadow map，它表示场景中所有被光源直接照射的部分。

![](1680601000380.png)

shadow map 记录了这些区域在直接光照下反射的 radiance，这样当我们需要考虑 GI 时只需要把直接光照和 shadow map 上记录的来自其它物体的反射光线进行相加即可。

![](1680601001280.png)

直接计算来自场景中其它物体的反射光线仍然需要非常多的计算量，在 RSM 中使用了 **cone tracing** 的技术来进行简化。

![](1680601002150.png)

由于间接光照一般来说是相对低频的，在渲染时还可以降低输出的分辨率进一步提升效率。然后在与直接光照相加时通过插值的方式来获得完整分辨率下的间接光照。

![](1680601002995.png)

通过 RSM 实现的 GI 可以明显提升游戏画面中阴影部分的细节。

![](1680601003899.png)

总结一下，RSM 作为实时 GI 的早期工作非常容易进行实现而且很高的计算效率；而它的缺陷在于 RSM 只能考虑光线的一次反射，而且在计算间接光照时没有进行可见性检测。

![](1680601004729.png)

## Light Propagation Volumes

**light propagation volumes(LPV)** 是考虑光线在场景中不断传播的一种 GI 算法，最早在 2009 年提出。

![](1680601005593.png)

LPV 的核心在于把场景使用三维的网格进行表示，并以此来计算光线在场景中的分布。

![](1680601006428.png)

![](1680601007670.png)

LPV 在计算时会记录每个格子上当光线传播到物体表面后散射的 radiance，然后以此为中心向其它格子进行扩散。

![](1680601008482.png)

![](1680601009331.png)

某种意义上讲 LPV 把光线的传播视为扩散过程，严格来说这样的处理是不完全遵循物理法则的。

![](1680601010209.png)

## Sparse Voxel Octree for Real-time Global Illumination

SVOGI 的思路与 LPV 非常接近，都使用了网格的方式来对场景空间进行划分。在 SVOGI 中使用了**保守光栅化 (conservative rasterization)** 的方法来获取场景的体素表达，从而得到场景中所有表面的体素。

![](1680601011050.png)

![](1680601011862.png)

为了更高效地管理场景中的体素，SVOGI 使用了八叉树这样的数据结构来把体素组织起来。

![](1680601012692.png)

在进行 shading 时则使用了 cone tracing 的方式来对八叉树进行查询。

![](1680601013553.png)

## Voxelization Based Global Illumination

VXGI 可以看做是对 SVOGI 的简化。在 VXGI 中使用了 clip map 这样的数据结构来描述场景，离相机越近就具有越高的分辨率。

![](1680601014414.png)

当相机发生运动时无需更新 clip map，只需要更新相机采样的范围即可。

![](1680601015215.png)

这样整个场景就得到了一个体素化表达，离相机近的地方体素越稠密，越远的地方体素越稀疏。

![](1680601016054.png)

对于每个体素我们还需要计算该体素遮挡了多少的光线，这里会记录体素在三个方向上的可见性。

![](1680601016925.png)

![](1680601017743.png)

当来自光源的光线注入到场景中时需要记录每个体素的表面上接收到的直接光照。

![](1680601018601.png)

![](1680601019427.png)

而对于屏幕上的像素则通过 cone tracing 的方式来计算间接光照，通过叠加整条光路上的 radiance 来获得间接光照。

![](1680601020284.png)

![](1680601021194.png)

![](1680601022007.png)

VXGI 的主要缺陷在于 cone tracing 的结构仍然是对间接光照的一种近似，而且它非常容易出现漏光的问题。

![](1680601022815.png)

## Screen Space Global Illumination

SSGI 和前面介绍过的方法相比是基于屏幕空间的 GI 技术。在现代 GPU 渲染管线中我们可以快速地渲染出屏幕空间上的各种物理量，通过重用屏幕空间的数据就可以实现 GI。

![](1680601023686.png)

当我们渲染得到屏幕空间上的直接光照时，可以利用屏幕空间上像素的法向信息来继续计算间接光照。

![](1680601024624.png)

计算间接光照时可以利用 ray marching 的方式来计算光线和平面空间中物体的交点。

![](1680601025470.png)

为了进一步提升 ray marching 的效率，SSGI 还使用了 z-buffer 的 mipmap 来进行加速。

![](1680601026343.png)

![](1680601027194.png)

![](1680601028588.png)

![](1680601029443.png)

![](1680601030300.png)

![](1680601031159.png)

![](1680601032580.png)

同时 SSGI 还会对每一个像素来重复使用其相邻像素采样的间接光照，这样可以减少采样的光线数量从而进一步提升渲染效率。

![](1680601033435.png)

![](1680601034314.png)

和前面介绍过的基于体素的 GI 技术相比，SSGI 对于光泽表面有非常好的渲染效果；但需要注意的是 SSGI 无法处理屏幕空间之外的物体，这容易导致各种错误的渲染结果。

![](1680601035173.png)

![](1680601036013.png)

## Lumen

**Luman** 是虚幻 5 引擎提出的最新实时 GI 技术。尽管实时光线追踪也可以实现实时 GI，但它依赖于硬件层面的实现而且需要大量的采样才能实现比较好的渲染效果。而 Luman 不依赖于硬件实现，可以应用到大量对实时性有需求的环境中。

![](1680601036923.png)

![](1680601037762.png)

![](1680601038591.png)

### Fast Ray Trace in Any Hardware

Luman 的渲染过程可以大致划分为 4 个部分，首先是进行高效的路径追踪。考虑到不是所有的硬件都支持光线追踪的加速，Luman 使用了 **SDF** 的方式来实现这一过程。

![](1680601039421.png)

由于直接把场景转换成 SDF 往往是比较复杂的，我们可以先对每个物体转换为 SDF。对于平移变换和等比例的放缩，物体坐标系下的 SDF 都可以很容易地转换为场景坐标系下的 SDF。

![](1680601040266.png)

需要注意的是当物体比较薄时要进行一些额外的处理。

![](1680601041182.png)

SDF 的一大优势在于它可以非常容易地得到光线步进的长度：在任意 p 位置前进 SDF(p) 的距离总是可以保证不会和场景出现相交。

![](1680601042011.png)

同时，SDF 在进行 cone tracing 时也可以很容易地计算出遮挡面积比例的估计。

![](1680601042860.png)

生成 SDF 时可以考虑使用一些稀疏的数据结构进行表示。

![](1680601043705.png)

SDF 甚至可以表达物体的不同 LOD。

![](1680601044540.png)

在低 LOD 下结合 sparse mesh 可以极大地减少模型的存储空间。

![](1680601045342.png)

当然，直接将场景中物体的 SDF 组合到一起在进行计算时仍然是过于复杂的。

![](1680601046176.png)

![](1680601047035.png)

这里可以结合屏幕空间的概念只考虑相机视野范围内的物体，将它们的 SDF 融合为一个低精度的全局 SDF。

![](1680601047895.png)

在这个低精度的全局 SDF 上进行 ray tracing 可以极大地降低计算压力。

![](1680601048728.png)

除此之外 SDF 也可以结合 mip 的思想，近处的精度高而远处精度低。

![](1680601049588.png)

### Radiance Injection and Caching

接下来我们需要把光照信息注入到场景中。在 Lumen 中使用了 **mesh card** 来保存物体在 6 个正方形上被光照亮后的结果。

![](1680601050398.png)

![](1680601051237.png)

对于每个 card 我们还需要记录物体表面的 albedo、法向以及深度等信息。

![](1680601052078.png)

所有物体的表面信息会统一记录到一张标准大小的纹理图像上，称为 **surface cache**。

![](1680601052894.png)

![](1680601053731.png)

根据物体距离相机的远近还可以设置不同的 card 分辨率以降低存储和计算需求。

![](1680601054549.png)

我们的目标是把物体所有光照的 radiance 记录到 surface cache 上。

![](1680601055446.png)

在 Lumen 中整个光照可分解为直接光照、体素化光照以及间接光照三部分。

![](1680601056254.png)

直接光照相对比较简单，我们只需要考虑光源直接照射到物体上反射的 radiance 即可。对于阴影中的物体则可以结合 shadow map 来进行处理。

![](1680601057077.png)

![](1680601057888.png)

得到直接光照后 Lumen 会对场景进行体素化来存储物体在 6 个方向上直接光照的亮度。而且体素化后的光照信息会在相邻帧上进行传递，随着时间的积累会得到光线多次弹射的效果。

![](1680601058755.png)

![](1680601059665.png)

![](1680601060513.png)

![](1680601061358.png)

![](1680601062289.png)

最后计算间接光照时只需要从 surface cache 上进行采样，利用上一步体素化光照作为照明即可。

![](1680601063100.png)

![](1680601063893.png)

![](1680601064747.png)

把直接光照和间接光照相加就得到了环境中光照的信息。

![](1680601065647.png)

![](1680601066547.png)

### Build a lot of Probes with Different Kinds

#### Screen Space Probe

有了光照后我们需要在物体表面通过采样来计算着色，此时我们需要在场景中放置**探针 (probe)** 来采样光照。Lumen 中直接在屏幕空间里放置 probe，每个 probe 会同时记录光线前进的距离以及收集到的 radiance。

![](1680601067384.png)

![](1680601068233.png)

![](1680601069096.png)

![](1680601069959.png)

![](1680601070783.png)

![](1680601071593.png)

![](1680601072438.png)

![](1680601073385.png)

#### Importance Sampling

为了提升渲染质量我们需要使用重要性采样的技术尽可能在比较重要的方向上进行采样。

![](1680601074259.png)

![](1680601075164.png)

回到 Monte Carlo 积分的公式中，我们需要把光线更多地分布在光照比较强或是接近物体法线的方向上。

![](1680601076083.png)

Lumen 中会对上一帧以及四周相邻的 probe 进行平均来估计光照的分布。

![](1680601077107.png)

而对于物体法向附近的方向，Lumen 会估计 probe 附近的法向分布。

![](1680601078026.png)

![](1680601078951.png)

![](1680601079854.png)

![](1680601080850.png)

![](1680601081696.png)

![](1680601082537.png)

![](1680601083429.png)

#### Denoising and Spatial Probe Filtering

为了进一步提升渲染效果我们还需要对图像进行滤波降噪。

![](1680601084300.png)

![](1680601085123.png)

![](1680601085953.png)

![](1680601086757.png)

![](1680601087614.png)

#### World Space Probes and Ray Connecting

![](1680601088434.png)

![](1680601089302.png)

![](1680601090126.png)

![](1680601090961.png)

![](1680601091804.png)

![](1680601092633.png)

![](1680601093456.png)

![](1680601094304.png)

![](1680601095147.png)

![](1680601095975.png)

### Shading Full Pixels with Screen Space Probes

![](1680601096796.png)

![](1680601097659.png)

### Overall, Performance and Result

![](1680601098511.png)

![](1680601099423.png)

![](1680601100273.png)

![](1680601101155.png)

![](1680601101995.png)

![](1680601102844.png)

![](1680601103675.png)

![](1680601104483.png)

![](1680601105384.png)

![](1680601106171.png)

![](1680601106998.png)

## Conclusion

![](1680601107825.png)

## Reference

*   [Lecture 21：Dynamic Global Illumination and Lumen (Part I)](https://www.bilibili.com/video/BV1oe411u7DJ/?vd_source=7a2542c6c909b3ee1fab551277360826)
*   [Lecture 21：Dynamic Global Illumination and Lumen (Part II)](https://www.bilibili.com/video/BV1Ya411g7Th/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)