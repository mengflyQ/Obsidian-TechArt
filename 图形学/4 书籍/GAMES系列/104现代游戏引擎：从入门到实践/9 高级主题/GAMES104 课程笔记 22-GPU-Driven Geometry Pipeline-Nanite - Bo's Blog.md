这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 ([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/)) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍 GPU 驱动的几何管线与 Nanite 技术。

## Introduction

### Traditional Rendering Pipeline

Nanite 是虚幻 5 引擎中提出的虚拟几何系统用来实现渲染超高精度的网格。要理解 Nanite 首先要回顾一下经典渲染管线：当我们从 CPU 端发出渲染指令时会首先由 CPU 来准备各种渲染所需的资源，然后 GPU 会接收这些数据并计算实际的着色。这种模式的缺陷在于 CPU 可能无法跟上 GPU 的计算速度，而且 CPU 的算力会浪费在准备渲染素材这一过程中。

![](1680601113347.png)

随着渲染场景的复杂度逐渐提升，CPU 端的计算开销会成为整个渲染过程的瓶颈。

![](1680601114171.png)

![](1680601115035.png)

### Compute Shader

为了提升渲染效率人们开发出了 **compute shader** 这样的技术，其核心在于把过去只能在 CPU 端执行的通用计算转移的 GPU 端，从而节约掉大量的 CPU 到 GPU 端的通信开销。

![](1680601115905.png)

### Graphics API

在图形 API 层面上过去只能一次绘制一个网格，而现代图形 API 则支持在一次 DrawCall 中同时绘制多个网格。

![](1680601116790.png)

### GPU Driven Rendering Pipeline

总结一下，现代 GPU 驱动的渲染管线核心思想在于把 CPU 端的计算直接移动到 GPU 端，同时渲染所需的数据也会直接由 GPU 进行加载。在理想情况下 CPU 端只负责发出绘制指令，一切渲染数据加载和计算都在 GPU 端直接完成。

![](1680601117670.png)

## GPU Driven Pipeline in Assassins Creed

游戏工业对 GPU 驱动渲染管线的大规模应用可以追溯到《刺客信条：大革命》。在游戏中我们可以看到大量的拥有真实细节的建筑和场景，如何渲染这些极其复杂的几何对象是整个渲染管线的巨大挑战。

![](1680601118528.png)

游戏开发团队提出了 **mesh cluster rendering** 的技术来提升渲染效率。mesh cluster rendering 的思想在于对同一物体上的面片进行聚类，在渲染时首先根据 cluster 来判断面片的可见性

![](1680601119335.png)

整个游戏的渲染管线如下图所示。通过 clustering 的方法可以去除掉大量不可见的对象以及三角形，从而极大地缓解了 GPU 的渲染压力。

![](1680601120267.png)

而在 CPU 端只负责非常少量的视锥剔除等工作，初步过滤掉不可见的物体。

![](1680601121129.png)

然后 GPU 端会把过滤后物体上的 cluster 拓展为 chunk，每个 instance 可以属于不同的 chunk 而每个 chunk 可以包含不同的 cluster。

![](1680601121951.png)

GPU 端进行实际的可见性剔除时会先检查 chunk 的可见性然后计算 cluster 的可见性。除了利用 bounding box 进行剔除外，还会同时结合三角形的朝向进行过滤，最后得到所有可见的三角形编号。

![](1680601122773.png)

所有可见三角形的编号会存储在一个事先申请的巨大 buffer 中。写入过程是原子化的，因此可以利用 GPU 并行计算来高效处理。而在进行渲染时可以利用这个 buffer 来并行处理所有的三角形，从而实现对场景的渲染。

![](1680601123613.png)

![](1680601124475.png)

## Occlusion Culling for Camera and Shadow

为了进一步提升渲染效率，除了剔除掉视野外的三角形外我们还希望能够把被遮挡住的三角形也同时剔除掉，这一过程称为 **occlusion culling**。当相机在场景中的运动比较光滑时可以把前一帧的深度图投影到当前相机位置上，再结合 hierarchy z-buffer 就可以估计哪些 cluster 和三角形是可见的。

![](1680601125337.png)

### Two-Phase Occlusion Culling

更现代的 occlusion culling 方法是使用上一帧和这一帧的两个 z-buffer 来实现。首先利用前一帧的 z-buffer 来快速选取可能可见的物体，然后使用这些物体来渲染新的 z-buffer。显然此时的深度图会有非常多的洞等待填充，而且很多像素的深度可能是错误的。为了修正这个问题还需要再利用这一帧的深度图来测试前面过滤掉的其它物体。

![](1680601126236.png)

这种 two-phase occlusion culling 方法对于非常复杂的场景以及动态物体都有很好的性能。

![](1680601127130.png)

而对于阴影的问题也可以复用前一帧阴影的深度图并结合 hierarchy z-buffer 来进行剔除。

![](1680601127972.png)

要进一步提升阴影的渲染效率还可以结合相机的可见性，把所有相机方向不可见的物体全部剔除掉。

![](1680601128842.png)

![](1680601129656.png)

## Visibility Buffer

和 Nanite 相关的另一个技术是课程前面提到过的 G-buffer 和[延迟渲染](https://peng00bo00.github.io/2022/04/27/GAMES104-NOTES-07.html#deferred-rendering)，我们可以把场景中的各种几何信息记录在 G-buffer 中从而方便渲染时的计算。

![](1680601130491.png)

![](1680601131371.png)

显然这样的 G-buffer 会占用非常多的显存，这在画面高分辨率或是复杂场景的情况下读取数据的效率会变得极其低下。

![](1680601132200.png)

![](1680601133102.png)

[V-buffer](https://peng00bo00.github.io/2022/04/27/GAMES104-NOTES-07.html#visibility-buffer) 是为了提升数据读取效率和缓存利用率而提出的一种技术。V-buffer 中不会记录太多的几何信息，一般只保存像素上物体的各种编号。

![](1680601133936.png)

![](1680601134789.png)

在进行着色时对每个像素需要先获取该处对应的三角形信息，然后通过插值来得到像素上相应的各种几何材质数据。这种渲染方式的优势在于计算量只与分辨率有关，而与场景的几何复杂度无关，因此拥有非常高的计算效率。

![](1680601135648.png)

![](1680601136480.png)

V-buffer 可以很容易地和延迟渲染管线进行结合。我们只需要利用 V-buffer 中可见物体的编号来重新写入 G-buffer 就可以完美融入延迟渲染管线中。

![](1680601137322.png)

当然 V-buffer 在实际使用时还有很多的细节要处理，比如说如何考虑纹理的梯度、如何选取合适的 mip-map 等。

![](1680601138186.png)

使用 V-buffer 可以极大地提升具有复杂几何场景的渲染效率。

![](1680601138999.png)

## Virtual Geometry - Nanite

### Overview

Nanite 的核心任务是实现实时电影级高精度几何模型的渲染，我们希望能够尽可能还原有着无限细节的真实世界。

![](1680601139796.png)

![](1680601140613.png)

回忆基于 [virtual texture](https://peng00bo00.github.io/2022/04/19/GAMES104-NOTES-06.html#terrain-texture) 的技术我们可以为物体不同 LoD 的纹理烘焙在固定大小的纹理贴图上，在渲染时根据相机的位置和实际需要加载所需的纹理。这种材质表达可以提升缓存利用率以及数据加载效率。

![](1680601141479.png)

Nanite 的思想与 virtual texture 非常相似，不过 Nanite 更关心的是如何建立虚拟的几何表示。当然几何数据本身要比纹理贴图要复杂得多，如何建立规范的几何表示至今仍然是一个难题。

![](1680601142301.png)

![](1680601143134.png)

以体素化表示为例，尽管体素本身是相对规范的但由于其巨大的数据量我们很难在游戏引擎中来直接使用。

![](1680601143998.png)

另一种流行的几何表示方法是**曲面细分 (surface subdivision)**，基于这样的技术我们可以把粗略的几何表面细分为高精度包含各种细节的曲面。然而曲面细分的一个缺陷在于很难对曲面进行降采样，即从高精度曲面来获得低精度表示。

![](1680601144851.png)

其它的几何表达方式包括 displacement map 或是点云也都无法满足我们的需求。

![](1680601145654.png)

![](1680601146463.png)

因此在 Nanite 中还是选择了三角网格来表示，然后设计了一套非常复杂的算法流程来表达几何信息。

![](1680601147334.png)

### Geometry Representation

Nanite 的一个重要想法是利用屏幕的精度来控制渲染时所需计算三角形的数量。尽管三角形的数量可以随着模型精度的提高不断增长，但只要屏幕分辨率不变所需绘制的三角形数量应该是比较稳定的。

![](1680601148161.png)

因此可以结合前面介绍过的 [mesh cluster](https://peng00bo00.github.io/2022/12/12/GAMES104-NOTES-22.html#gpu-driven-pipeline-in-assassins-creed) 来控制模型的细节。

![](1680601148998.png)

然后根据相机与模型的相对远近关系来生成 cluster 在不同 LoD 下的几何表示。

![](1680601149808.png)

![](1680601150629.png)

在选择 cluster 的 LoD 时需要考虑它投影到屏幕上产生的误差。一种直观的选取方法是当误差小于 1px 时选择当前层的 LoD，否则选取下一层的 LoD。

![](1680601151434.png)

![](1680601152291.png)

![](1680601153114.png)

但是在合并 cluster 时需要考虑不同 LoD 的 cluster 之间可能会出现缝隙。当然我们可以把 cluster 的边锁住，这样不管是使用哪一层的 LoD 都会有一致的边界。不过这样的处理并不是一个非常好的办法，可能会产生严重的 artifact。

![](1680601153942.png)

![](1680601154772.png)

Nanite 中提出了 **cluster group** 的概念来处理 cluster 之间的缝隙。cluster group 之间的边界会被锁住，而内部的 cluster 会在生成 LoD 时一起进行简化。

![](1680601155607.png)

整个 cluster 简化的过程如下。需要注意的是简化后的 cluster 与原始 cluster 之间并不是一对多的关系，而是多对多的关系。即不同的简化后的 cluster 可以对应同一个原始 cluster。

![](1680601156467.png)

![](1680601157323.png)

![](1680601158234.png)

![](1680601159283.png)

![](1680601160089.png)

随着 LoD 的提高不同 cluster group 的边界也会发生相应的变化，这样可以避免出现高频噪声。

![](1680601160946.png)

![](1680601161742.png)

![](1680601162579.png)

![](1680601163438.png)

实际上这样的简化 cluster 过程可以表示为一张 DAG，每个 cluster 在上一层 LoD 会有多个指向。

![](1680601164263.png)

![](1680601165092.png)

![](1680601165942.png)

而网格本身的简化则可以使用经典的 QEM 等简化算法来实现。

![](1680601166760.png)

![](1680601167588.png)

### Runtime LoD Selection

进行渲染时需要根据相机的位置来选择合适的 LoD。不过对于 DAG 这样的数据结构进行访问时仍然是比较复杂的。

![](1680601168464.png)

![](1680601169336.png)

Nanite 还使用了并行化的技术来加速访问。

![](1680601170179.png)

![](1680601171037.png)

![](1680601171904.png)

![](1680601172737.png)

![](1680601173588.png)

![](1680601174430.png)

除此之外还可以使用 BVH 来加速 LoD 选择。

![](1680601175281.png)

![](1680601176193.png)

![](1680601177121.png)

![](1680601177934.png)

BVH 的构建过程还可以使用 job system 来进行加速。

![](1680601178755.png)

![](1680601179559.png)

### Rasterization

Nanite 在渲染时很多三角形的大小已经接近于屏幕上的一个像素，此时需要硬件光栅化来提供支持。

![](1680601180365.png)

![](1680601181176.png)

![](1680601181983.png)

传统光栅化对于小三角形的支持不够好，在 Nanite 中会结合 compute shader 来实现软光栅。

![](1680601182842.png)

![](1680601183668.png)

![](1680601184486.png)

![](1680601185335.png)

在深度测试时，Nanite 还利用了一些 trick 进行加速。实际渲染过程与 V-buffer 渲染过程类似。

![](1680601186165.png)

![](1680601186998.png)

![](1680601187838.png)

![](1680601188738.png)

![](1680601189593.png)

![](1680601190440.png)

![](1680601191291.png)

### Deferred Material

Nanite 在绘制材质时会把材质信息转换为深度图，然后对可能出现的深度 (材质) 进行遍历。这样可以一次性绘制所有具有相同材质的像素。

![](1680601192120.png)

![](1680601192985.png)

![](1680601193828.png)

更新的 Nanite 版本还会把屏幕划分为若干个 tile，然后在每个 tile 上统计出现的材质。这样可以加速对全屏材质的遍历和绘制。

![](1680601194685.png)

![](1680601195511.png)

![](1680601196432.png)

![](1680601197280.png)

![](1680601198098.png)

### Virtual Shadow Map

高精度几何模型还会导致阴影渲染时的困难，而且遗憾的是 Nanite 目前尚不支持实时光追来计算阴影。

![](1680601199132.png)

![](1680601200046.png)

不过计算阴影时也可以结合 LoD，在距离相机不同远近的位置使用不同精度的模型。

![](1680601200921.png)

![](1680601201744.png)

![](1680601202603.png)

在这种思想下 Nanite 提出了 virtual shadow map 来表示不同精度的物体。

![](1680601203449.png)

![](1680601204333.png)

对于不同类型的光源也可以定制划分 virtual shadow map 的方式。

![](1680601205169.png)

当相机和光源都不变时我们可以把 shadow map 相关的信息写入 page 中方便下一帧读取。而如果相机和光源发生变化则只需更新一部分 page 即可。

![](1680601206012.png)

![](1680601206828.png)

当然这种 virtual shadow map 在场景光源发生变化时会出现一些问题，因此比较适合主光源不变的场景。

![](1680601207702.png)

![](1680601208506.png)

![](1680601209374.png)

### Streaming and Compression

![](1680601210210.png)

![](1680601211052.png)

![](1680601211912.png)

![](1680601212717.png)

![](1680601213571.png)

## Reference

*   [Lecture 22：GPU-Driven Geometry Pipeline-Nanite (Part I)](https://www.bilibili.com/video/BV1Et4y1P7ro/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)
*   [Lecture 22：GPU-Driven Geometry Pipeline-Nanite (Part II)](https://www.bilibili.com/video/BV17G4y1x7VX/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826)