这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 ([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/)) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中物理系统的应用以及一些高级算法。

## Character Controller

**角色控制器 (character controller)** 是玩家操作角色和游戏世界进行交互的接口。和很多人直观的认识不同，角色控制器在很多情况下实际上是一个非物理的。最常见的例子是玩家控制角色停止移动时角色会立即停住，而不是严格按照刚体仿真那样通过摩擦力来逐渐停止运动。某种意义上讲，角色控制器虽然是反物理的但却更符合人对物理世界的认知。

![](1680599949309.png)

![](1680599950153.png)

### Build a Controller in Physics System

在构建角色控制器时一般会使用简化后的形状来包裹角色，这样便于处理各种场景之间的互动。

![](1680599950983.png)

### Collide with Environment

在角色和场景进行互动时最常见的情况是玩家控制的角色撞到了墙壁上。如果严格按照物理引擎进行模拟，此时角色会一直停在碰撞的位置；而现代游戏中更常见的处理方式是修改角色的运动方向，使得角色可以沿墙壁方向进行滑动。

![](1680599951848.png)

### Auto Stepping

上下楼梯同样也是角色在场景中的一种常见行为。如果严格按照物理仿真进行处理，胶囊的上下楼梯会非常地困难。因此在游戏引擎中需要单独考虑这种情况，当角色上下楼梯时自动修正角色的位置。

![](1680599952711.png)

对于斜坡这种情况，如果按照刚体运动学进行处理会导致角色下坡时直接从斜坡上滑下来，或是在上坡时由于具有过大的速度角色直接冲上它不应该到达的位置。为了避免这些问题需要单独考虑角色停在斜坡或是限制角色的位置。

![](1680599953539.png)

### Controller Volume Update

角色控制器还需要考虑角色体积发生变化的情况。当玩家控制角色进行下蹲等动作时需要自动更新角色控制体的体积，否则容易出现角色卡在门口无法进入的问题。

![](1680599954382.png)

### Controller Push Objects

当玩家控制角色和场景中的物体互动时需要对动态对象的运动状态加以更新。比较常见的处理方式是发生碰撞时对动态对象施加一个相应的冲量来控制它们的运动。

![](1680599955261.png)

### Standing on Moving Platform

除此之外，角色控制器还需要考虑动态场景的情况。当角色位于运动的平台时需要根据平台的运动来调整角色的运动状态，否则会出现平台发生运动时角色的运动没有同步或是滞后的问题。

![](1680599956100.png)

## Ragdoll

**布娃娃 (ragdoll)** 系统是游戏角色动画的一个重要组成部分，它最常见的例子是角色的处决动画：当玩家控制的角色处决了某个游戏对象时，根据处决场景的不同被处决对象会发生相应场景互动的动作。

![](1680599956994.png)

### Map Skeleton to Rigid Bodies

实际上 ragdoll 与前面介绍过的[骨骼动画](https://peng00bo00.github.io/2022/05/11/GAMES104-NOTES-08.html#skinned-animation-implementation)密切相关。在模拟 ragdoll 的运动时，我们同样会在角色身上设置相应的节点并把不同节点之间的骨骼按照刚体进行模拟。不过出于实时计算上的考虑，ragdoll 一般只会使用非常少量的节点和骨骼来进行模拟。

![](1680599957826.png)

### Human Joint Constraints

同样地，在 ragdoll 中需要考虑角色身上不同节点的运动是带有一定约束的。如果忽略了人体骨骼关节的约束则会导致非常扭曲的模拟效果。

![](1680599958649.png)

![](1680599959502.png)

一般来说 ragdoll 关节的约束会由 TA 进行设置，如果设置的不好会出现一些反直觉的动画效果。

![](1680599960396.png)

![](1680599961258.png)

### Animating Skeleton by Ragdoll

需要注意的是尽管我们可以使用 ragdoll 来模拟角色的动画，在实际游戏中仍然是需要通过骨骼关节系统来驱动整个角色的运动。由于 ragdoll 中的骨骼关节数量一般会少于实际角色的骨骼关节，我们需要使用[动画重定向](https://peng00bo00.github.io/2022/05/17/GAMES104-NOTES-09.html#animation-retargeting)技术来将 ragdoll 计算出的运动映射到实际的角色骨骼上。

![](1680599962084.png)

### Blending between Animation and Ragdoll

在使用时还需要注意角色动画切换到 ragdoll 的过程。还是以角色处决动画为例，在一开始被处决对象是使用预先录制的角色动画，然后在某一时刻会切换成 ragdoll 使用物理系统来实时计算角色的行为。

![](1680599962985.png)

更进一步，在现代 3A 游戏中还会将角色动画和 ragdoll 实时计算出的动画进行混合来提升玩家的代入感和游戏体验。

![](1680599963804.png)

## Cloth

布料系统是游戏物理仿真中的重要一环。早期的布料模拟是使用预先录制的动画来实现的，我们可以在角色身上设置一些额外的骨骼来控制衣物的运动，这样就可以实现角色执行不同动作时衣物随之飘动的效果。

![](1680599964636.png)

另一种处理衣物的方法是使用刚体运动的方法来模拟衣物和角色以及场景的互动。这样的处理方法虽然需要更多的计算资源，但可以实现相对真实衣物运动的效果。

![](1680599965549.png)

### Mesh-Based Cloth Simulation

而在现代游戏引擎中衣物运动更多地是使用网格来进行模拟。这里首先要说明的是布料仿真中使用的网格是不同于渲染中所使用的网格，出于计算效率上的考虑布料仿真中使用的网格要比渲染中的网格要稀疏很多。

![](1680599966374.png)

同时在布料仿真中往往还会为网格上的每个顶点赋予一定位移的约束，从而获得更符合人直觉的仿真结果。

![](1680599967228.png)

### Mass-Spring System

使用网格进行布料仿真的基本处理方法是使用质点弹簧系统进行模拟。我们为网格的顶点赋予一定的质量，然后将相邻顶点使用弹簧连接起来就形成了布料仿真的物理系统。这里需要注意的是除了弹簧弹力之外一般还需要为质点施加一定的阻尼来保证质点的运动最终能够停住。

![](1680599968060.png)

在放置弹簧时除了横竖方向外一般还需要在对角方向上也设置一些弹簧，这样可以保证布料具有抵抗对角方向的刚度。

![](1680599968887.png)

最后把外力施加在质点弹簧系统上就可以进行布料的运动仿真了。这里需要注意的是在进行仿真时不要忘记质点除了弹簧施加的弹力和阻尼外自身还会收到重力以及空气阻力的作用。

![](1680599969721.png)

### Verlet Integration

对质点弹簧系统进行仿真时不可避免地会使用到一些数值积分的方法，这里我们着重介绍一些 Verlet 积分算法。Verlet 积分本质仍然是半隐式欧拉积分，不过在实际积分时可以将速度项约掉只保留位移和加速度项就能进行计算。因此 Verlet 积分不需要保存每一时刻的速度，我们只需要位移和力 (加速度) 就可以进行计算，从而提高布料仿真的效率。

![](1680599970639.png)

### Self Collision

布料仿真的一大难点在于如何处理**自相交 (self collision)** 问题。由于我们使用了没有体积的网格来表示布料，在进行仿真时很容易出现网格直接相互的穿插。

![](1680599971468.png)

目前布料自相交的问题还没有一个十分完善的解决方法。在工业界会使用一些 trick 来缓解自相交的问题，比如说对布料进行加厚、减少仿真时的时间步长、限制顶点的速度以及使用 SDF 进行控制等。

![](1680599972326.png)

![](1680599973113.png)

## Destruction

玩家对场景的破坏是通过破坏系统来进行实现。一个好的破坏系统可以极大地提升玩家的游戏体验，有些游戏甚至是以破坏系统为核心玩法进行设计的。

![](1680599973962.png)

### Chunk Hierarchy

我们可以使用一棵树来描述同一物体不同碎片之间的层次关系：树的根节点表示完整的物体，而它下面的每一层表示物体经受一定程度的冲击后所产生的碎片。

![](1680599974830.png)

### Connectivity Graph

当确定了物体承受的冲击后就可以使用一张图来表示不同碎片之间的连接关系：图的节点表示碎片，而图的边则表示相互连接的碎片能够承受的荷载，当冲击大于边上的值时就会发生物体的破碎。

![](1680599975704.png)

![](1680599976629.png)

### Damage Calculation

需要说明的是虽然我们使用了冲击和荷载这样的字眼，实际上在游戏引擎中却不会去计算这些物理量。它们只是一些人工设置的数值，并不具备真实的物理意义。在游戏开发中一般会使用一些经验公式来对冲击以及物体的承载力进行计算。

![](1680599977572.png)

![](1680599978430.png)

### Fracturing with Voronoi Diagram

那么如何去生成这样的一张图呢？在物理引擎中一般会使用 **Voronoi 图 (Voronoi diagram)** 这样的技术来对原始的物体区域进行划分，划分后的每一个区域即为所需的碎片。

![](1680599979306.png)

![](1680599980674.png)

对于三维的情况则要更加复杂一些，除了需要使用 Voronoi 图对空间进行划分还需要使用 Delaunay 三角化来重新生成碎片的三维网格。同时当物体破碎后还需要为碎片的网格赋予内部材质的纹理，这一般需要使用一些程序化的纹理生成算法。

![](1680599981580.png)

![](1680599982455.png)

在设置 Voronoi 图的种子时还可以根据需要设置不同模式的种子，这样可以实现相应的破碎效果。

![](1680599983320.png)

### Destruction in Physics System

从物理系统的计算流程上来看，破碎系统一般是仿真碰撞检测后实际解算之前。这主要是因为很多破碎的事件是由碰撞所导致的，同时在物体破碎后往往还会产生新的物体 (碎片) 需要计算相应的运动。

![](1680599984224.png)

### Issues with Destruction

除了物理系统的计算外在处理场景破坏时还需要添加相应的声音和粒子效果，这样可以得到更加真实的游戏体验。

![](1680599985052.png)

此外破坏系统的计算是相当昂贵的：当一个物体出现破碎后往往会带来成百上千个碎片需要进行物理仿真，这会极大地增加物理系统的计算负载，因此在使用时需要慎重考虑。

![](1680599985913.png)

### Popular Destruction Implementations

目前很多商业引擎都有现成的破坏系统。

![](1680599986802.png)

![](1680599987647.png)

## Vehicle

载具系统是现代游戏中重要的组成部分。要对载具进行模拟需要推导相应的动力学模型，以汽车为例整个汽车可以看做通过悬挂系统与地面接触的刚体。

![](1680599988520.png)

整个汽车的驱动力来自于引擎产生的扭矩，而扭矩的大小则需要查询引擎的相关曲线来计算。

![](1680599989359.png)

在竖直方向上由于地面的起伏车身会产生悬挂系统所导致的振动。

![](1680599990252.png)

在平面上汽车的轮胎会产生平行于前进方向的径向力，同时还会产生的切向力控制车辆的转动。

![](1680599991097.png)

根据车身重量的分布我们还需要计算汽车的重心。实际上重心的位置不仅会控制汽车的振动，还会汽车的转向性能有重要的影响。

![](1680599991937.png)

![](1680599992796.png)

![](1680599993630.png)

同时需要注意的是当车辆进行加速或是刹车时重心的位置也会发生一些变化。

![](1680599994466.png)

为了更好地实现转向，现代汽车在设计时会让两个转向轮的转动有微小的差异。在进行模拟时也需要考虑这个微小的角度变化。

![](1680599995303.png)

最后需要说明的是在计算地面和车轮求交时需要把轮子看做是球，这样才能模拟出车辆在凹凸不平的地面上行驶的效果。

![](1680599996141.png)

## Advanced: PBD/XPBD

### PBD

本节课最后讨论了 PBD 和 XPBD 两种更高级的物理仿真技术。和前面介绍过的仿真技术相比，PBD 和 XPBD 是建立在**拉格朗日力学 (Lagrangian mechanics)** 基础上的仿真方法。在拉格朗日力学的框架中不再考虑力等物理概念，而是把物理定律视为系统的某种约束来描述运动。

![](1680599997019.png)

以匀速圆周运动为例，在拉格朗日力学中我们不会去计算各种改变质点运动状态的力，而是考虑质点运动的位置约束以及速度约束。其中位置约束的导数也称为 Jacobian 矩阵。

![](1680599997847.png)

类似地，弹簧质点系统也可以表示为由约束定义的系统。

![](1680599998682.png)

PBD 在求解时，PBD 会把整个物理系统描述为关于位置的约束。然后通过不断迭代来计算满足约束的解。

![](1680599999652.png)

![](1680600000488.png)

整个 PBD 的求解流程如下：

![](1680600001331.png)

![](1680600002187.png)

![](1680600003039.png)

![](1680600003862.png)

![](1680600004683.png)

![](1680600005541.png)

PBD 是目前游戏行业非常热门的物理仿真技术，和传统仿真技术相比 PBD 往往会得到更稳定的解。

![](1680600006345.png)

### XPBD

XPBD 可以看做是对 PBD 的一种推广，它在 PBD 的基础上引入了**刚度 (stiffness)** 的概念来描述不同约束的强弱。

![](1680600007201.png)

## Reference

*   [Lecture 11：Physics System – Applications](https://www.bilibili.com/video/BV1Ya411j7ds/?spm_id_from=333.788)