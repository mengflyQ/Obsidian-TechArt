这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 ([GAMES 104: Modern Game Engine-Theory and Practice](https://games104.boomingtech.com/en/)) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎中的动画系统。

## Introduction

动画系统是游戏引擎的重要组成部分。从远古时代开始，我们的祖先就试图用各种手段让静止的画面动起来。

![](1680599634833.png)

直到近代，人们发现利用人眼的” 视觉残留” 效应可以将静止的画面产生运动的效果。这一发现构成了所有显示设备和电影动画的理论基础。

![](1680599635553.png)

### Animation Techniques in Film

目前游戏行业所使用的动画技术理论和经验基本都源自于电影行业对动画技术的探索。从早期的 2D 动画到如今大规模应用的三维动画，整个电影动画工业取得了令人瞩目的进步。

![](1680599636120.png)

早期的动画主要是由艺术家逐帧手绘来实现，而在今天基于计算机的动画模拟技术已经成为了电影工业的主流。

![](1680599636682.png)

### Animation Techniques in Game

回到游戏领域，早期的游戏动画都是制作者根据真实图片进行绘制来实现的，这与早期的二维动画异曲同工。

![](1680599637226.png)

后来随着 GPU 和 3D 游戏引擎的出现，人们开始使用计算机来直接生成游戏场景中的动画。而在今天的 3A 游戏大作中，结合真人动捕以及物理仿真的计算机动画已经可以以假乱真的效果。

![](1680599637834.png)

### Challenges in Game Animation

和电影行业中的计算机动画相比，游戏中的动画难点之一在于游戏是一个和玩家不断互动的过程。游戏开发者很难预设玩家的行为，而且必须考虑玩家的行为与场景进行互动的结果。

![](1680599638399.png)

同时，游戏对于实时性有着更高的需求。在很多情况下我们甚至需要考虑游戏场景中有着上万个单位同时进行运动的情况，这样大规模的计算给游戏动画系统的性能造成了巨大的挑战。

![](1680599638929.png)

除此之外，玩家对于现代游戏角色的动画也提出了更高的要求。我们希望游戏角色有着更加生动的表情，同时在运动过程中的行为尽可能自然。

![](1680599639440.png)

本课程中我们将游戏引擎的动画系统分成两部分。本节课会介绍一些基础的动画知识，而在下一节中则会讨论一些业界更加前沿的技术。

![](1680599639972.png)

## 2D Animation Techniques in Games

### Sprite animation

首先我们来看游戏中二维动画的实现。二维动画是最早的游戏动画形式，直到今天仍然有很多游戏使用二维动画来进行表现。最简单的二维动画称为 **sprite animation**，它是将游戏角色的行为逐帧绘制并在游戏中进行循环播放。

![](1680599640509.png)

为了实现更加生动的表现效果，还可以在不同的视角下对同一动作进行绘制并且在实际游戏中根据需要选择合适的动作帧进行播放。这样就可以利用 2D 动画实现伪 3D 的效果。

![](1680599641042.png)

在现代游戏中 sprite animation 仍然占有一席之地，很多游戏的特效就是通过预先渲染出的特效帧来实现的。

![](1680599641578.png)

### Live2D

目前虚拟主播中大范围应用的 **Live2D** 技术同样来自于 2D 动画，通过对一系列图像进行变形就可以实现非常生动的表现效果。

![](1680599642092.png)

Live2D 技术的核心是把角色的各个部位分解成不同的元素，通过对每个元素进行变形来实现虚拟人物的不同动作。

![](1680599642628.png)

在放置不同元素时还可以通过对图层顺序的变化进一步提升表现力。

![](1680599643197.png)

对于每一个图元则需要事先设置好它的网格来控制形变，这样角色的不同动作就可以通过对网格控制点的运动来进行描述。

![](1680599643809.png)

最后根据关键帧把角色不同元素不同控制点的运动组织起来就完成了一个虚拟角色的动作。

![](1680599644324.png)

## 3D Animation Techniques in Games

### Degrees of Freedom

3D 动画所需的技术要比 2D 动画复杂一些，在介绍具体的动画技术前我们需要先复习一下相关的数学知识。三维空间中物体的运动有**自由度 (degrees of freedom, DoF)** 的概念，对于刚体而言描述它的运动需要 3 个平动和 3 个旋转一共 6 个自由度。

![](1680599644864.png)

![](1680599645476.png)

### Rigid Hierarchical Animation

最简单的 3D 动画技术是把角色的不同部位都视为刚体，然后按照一定的层次把它们组织起来。早期的 3D 游戏就是使用这样的方法来实现三维角色的不同行为。

![](1680599646015.png)

### Per-vertex Animation

另一种实现三维动画的方法是利用网格的顶点来控制运动，这种技术称为**顶点动画 (per-vertex animation)**。此时网格上的每个顶点有具有 3 个平移自由度，通过对网格顶点坐标的变换就可以实现模型的运动。这种动画方法在人物角色上的应用比较少，但在物理仿真中则相对比较常见。

![](1680599646551.png)

### Morph Target Animation

类似于顶点动画，**morph target animation** 同样是利用顶点来控制模型的运动。和顶点动画不同的是，morph target animation 不会直接操作网格顶点的坐标而是通过顶点的位置和权重来控制整个网格的行为。morph target animation 在表现角色面部表情上有很广泛的应用。

![](1680599647083.png)

### Skinned Animation

本节课的核心是介绍**蒙皮动画 (skinned animation)** 的相关技术。蒙皮动画是目前游戏行业最主流的三维动画技术，它通过控制角色内部骨骼的运动来实现整个角色的运动。和刚体动画相比，蒙皮动画可以实现更加真实和自然的运动效果。

![](1680599647645.png)

蒙皮动画同样可以应用在二维动画上。基于 2D 蒙皮动画的运动会比刚体动画有更加自然的表现效果。

![](1680599648200.png)

### Physics-based Animation

在蒙皮动画之外另一大类动画形式是**物理动画 (physics-based animation)**。物理动画是完全基于物理法则的动画模拟方法，和蒙皮动画相比需要更加深入的数学物理知识进行描述。本课程中不会过多地介绍物理动画的相关内容。

![](1680599648730.png)

### Animation Content Creation

如何获得动画呢？早期的解决方法是由动画师在软件中通过关键帧来对角色的动作进行建模，而目前越来越多的游戏和电影则是通过真人动捕来获得更加自然的运动动画。

![](1680599649287.png)

## Skinned Animation Implementation

接下来我们介绍蒙皮动画的实现细节。从整体上来看，蒙皮动画的实现包括以下 5 个步骤：

1.  建立网格模型；
2.  建立网格模型附着的骨骼；
3.  为网格上每个顶点赋予骨骼对应的权重；
4.  利用骨骼完成角色的运动；
5.  结合顶点的骨骼权重实现网格的运动。

上述步骤看上去不是很难，但在实际编程中需要多加小心防止出现网格爆炸的问题。

![](1680599649818.png)

### Different Spaces

要描述骨骼的运动我们还需要引入相应的坐标系统。首先整个游戏世界定义了一个**世界坐标系 (world space)**，所有的物体都位于这个坐标系中；对于每个单独的模型，模型自身还定义了一个**模型坐标系 (model space)**；最后每个骨骼还定义了一个**局部坐标系 (local space)** 来描述网格顶点和骨骼的相对位置关系。任意两个坐标系之间的变换关系可以通过 3 个平移和 3 个旋转一共 6 个自由度来表示，这样每个顶点的坐标都可以从局部坐标系变换到模型坐标系再变换到世界坐标系上。

![](1680599650389.png)

### Skeleton

在此基础上就可以结合角色自身的特点构建出具有一定拓扑关系的**骨骼模型 (skeleton)**，这一般可以通过一棵树来表示。对于类人型的骨骼，整棵树的根节点一般位于胯部。而对于四足动物等其它类型的骨骼其根部则会位于其它位置。

![](1680599650904.png)

### Joint

我们定义骨骼与骨骼之间相连接的部位为一个**关节 (joint)**。实际上我们不会直接按照骨骼进行编程，而是利用关节及他们直接的连接关系来表达整个骨骼的运动。

![](1680599651424.png)

在游戏建模中除了常见的四肢外可能还会根据角色的服装和特点来构建更加复杂的骨骼模型。比如说玩家手中的武器就是通过在角色手上绑定一个新的骨骼来实现的。

![](1680599651983.png)

![](1680599652536.png)

除此之外，在进行建模时我们往往还会定义一个 root 关节。不同于前面介绍过的胯部骨骼，root 关节一般会定义在角色的两脚之间，这样方便把角色固定的地面上。类似地，对于坐骑的骨骼也往往会单独把 root 关节定义在接近地面的位置。

![](1680599653111.png)

![](1680599653672.png)

很多游戏动画需要将不同的骨骼绑定到一起。最直观的例子就是角色骑马的动画，此时角色和马都有自身独立的动画而我们需要将它们组合到一起完成角色骑马的动作。要实现这种功能需要设计一个单独的 mount 关节，然后通过这个关节将两个模型拼接到一起。需要注意的是在拼接时不仅要考虑关节坐标的一致性，更要保证两个模型的 mount 关节上有一致的朝向，这样才能实现模型正确的结合。

![](1680599654281.png)

### Bind Pose

早期的骨骼建模会使用 T-pose 作为角色动作的基准。但在实践过程中发现 T-pose 会导致角色的肩部出现挤压的状况，因此现代 3A 游戏中更多地会使用 A-pose 这种姿势进行建模

![](1680599654895.png)

### Skeleton Pose

完成骨骼建模后，角色的运动就可以通过骨骼的**姿态 (pose)** 来进行描述。这里需要注意的是表达角色的不同动作时每个关节实际上具有 9 个自由度，除了刚体变换的 6 个自由度外还需要考虑 3 个放缩变换引入的自由度。这 3 个放缩自由度对于表现一些大变形的动作起着很重要的作用。

![](1680599655462.png)

## Math of 3D Rotation

### 2D Orientation Math

在这一节中我们会详细介绍三维空间中如何表示物体旋转这一问题，不过首先我们来回顾一下二维空间的旋转。对于二维空间中的点 (x,y)$(x, y)$，当它绕原点进行旋转时只需要一个旋转角度θ$\theta$就可以进行描述，旋转的过程可以通过一个旋转矩阵 R(θ)$R(\theta)$来进行表示。

![](1680599656021.png)

### 3D Orientation Math

#### Euler Angle

三维空间中的旋转要更复杂一些。我们可以把任意三维空间的旋转分解为绕三个轴的旋转，每个旋转都对应一个三维旋转矩阵，这样就可以通过绕三个轴的旋转角度来进行表达。这种描述三维旋转的方法称为**欧拉角 (Euler angle)**。

![](1680599656582.png)

欧拉角在很多领域都有大量的应用，比如说飞行器的导航和姿态描述一般都是基于欧拉角的。

![](1680599657094.png)

但是需要说明的是欧拉角有很多局限性，比如说欧拉角是依赖于旋转顺序的。在使用欧拉角时必须指明绕三个旋转轴进行旋转的顺序，同样的欧拉角按照不同的顺序进行旋转会得到不同的结果。

![](1680599657625.png)

欧拉角的另一个缺陷在于**万向锁 (gimbal lock)**：在有些情况下按照欧拉角进行旋转会出现退化的现象，导致物体的旋转会被锁死在某个方向上。

![](1680599658171.png)

![](1680599658684.png)

总结一下，欧拉角的主要缺陷如下：

*   万向锁及相应的自由度退化问题；
*   很难对欧拉角进行插值；
*   很难通过欧拉角对旋转进行叠加；
*   很难描述绕 x,y,z$x, y, z$轴之外其它轴的旋转。

由于这些缺陷的存在，游戏引擎中几乎不会直接使用欧拉角来表达物体的旋转。

![](1680599659221.png)

#### Quaternion

在游戏引擎中更常用的旋转表达方式是**四元数 (quaternion)**，它由 Hamilton 爵士于 19 世纪提出。

![](1680599659846.png)

我们知道二维空间中的旋转可以使用复数来进行表示。换句话说，二维平面上的旋转等价于复数乘法。

![](1680599660415.png)

类似地，我们可以认为四元数是复数在三维空间的推广。一个四元数 q$q$具有 1 个实部和 3 个虚部 i,j,k$i, j, k$，四元数的运算法则如下：

![](1680599660945.png)

可以证明，任意的三维旋转可以通过一个单位四元数来表示。当我们需要对点 v$\mathbf{v}$进行旋转时，只需要先把 v$\mathbf{v}$转换成一个纯四元数，然后再按照四元数乘法进行变换，最后取出虚部作为旋转后的坐标即可：

![](1680599661482.png)

进一步可以证明用欧拉角表达的旋转都对应着一个四元数的表示。同样地，四元数与旋转矩阵直接也存在着相应的转换关系。

![](1680599662100.png)

![](1680599662636.png)

使用四元数来表达三维旋转的优势在于我们可以使用简单的代数运算来获得旋转的逆运算、旋转的组合以及两个单位向量之间的相差的旋转量。

![](1680599663244.png)

对于绕任意轴旋转的情况，我们同样可以利用旋转轴和旋转角度的信息来构造出四元数进行表达。

![](1680599663851.png)

## Joint Pose

### Affine Matrix

有了三维旋转的表达方法后我们就可以利用关节的姿态来控制角色模型的运动。具体来说，我们每个关节的姿态可以分为平移、旋转和缩放三个部分，把它们组合到一起就可以通过一个**仿射矩阵 (affine matrix)** 来描述关节的姿态。

![](1680599664363.png)

![](1680599664917.png)

![](1680599665436.png)

![](1680599665996.png)

![](1680599666556.png)

![](1680599667126.png)

对于骨骼上的每一个关节，我们实际上只需要存储它相对于父节点的相对姿态。这样在计算绝对姿态时可以利用仿射矩阵的传递性从根节点出发进行累乘即可。

![](1680599667684.png)

这种利用相对坐标系来描述位姿关系的好处在于它可以正确地对角色动作进行插值，而如果直接从绝对坐标系进行插值则会得到错误的结果。

![](1680599668219.png)

### Skinning Matrix

在前面我们介绍过模型的每个顶点是附着在骨骼上的，因此在关节姿态发生变化后顶点会跟着关节一起运动。

![](1680599668803.png)

记顶点 V$V$在关节 J$J$定义的局部坐标系下的坐标为 Vlb$V_b^l$，初始时刻进行绑定时 V$V$在模型坐标系下的坐标为 Vmb$V_b^m$。在 t$t$时刻，当关节位姿发生变化后顶点的局部坐标保持不变。此时顶点在模型坐标系下的坐标和局部坐标直接满足变换关系：

Vl(t)=Vlb=(Mmb(J))−1Vmb(1)

$$V^l(t) = V_b^l = (M_{b(J)}^m)^{-1} V_b^m$$

其中 Mmb(J)$M_{b(J)}^m$即为初始时刻进行绑定时关节 J$J$对应的姿态。

![](1680599669319.png)

利用 t$t$时刻关节的位姿 MmJ(t)$M_J^m(t)$，可以得到顶点 V$V$模型坐标系下的坐标 Vm(t)$V^m(t)$与初始时刻模型坐标系下绑定的坐标 Vmb$V_b^m$之间的变换关系：

Vm(t)=MmJ(t)VlJ=MmJ(t)⋅(Mmb(J))−1Vmb=KJVmb(2)

$$V^m(t) = M_J^m(t) V_J^l = M_J^m(t) \cdot (M_{b(J)}^m)^{-1} V^m_b = K_J V_b^m$$

其中 KJ=MmJ(t)⋅(Mmb(J))−1$K_J = M_J^m(t) \cdot (M_{b(J)}^m)^{-1}$称为关节 J$J$的**蒙皮矩阵 (skinning matrix)**。

![](1680599669859.png)

注意到蒙皮矩阵的第二项包含矩阵求逆运算，在游戏引擎中为了提高计算效率一般会直接存储整个逆阵。

![](1680599670373.png)

![](1680599670980.png)

对于同一个顶点绑定到多个骨骼的情况则需要通过插值进行处理。此时顶点 V$V$会同时存储它所绑定到的关节以及对应的权重，其在世界坐标系下的坐标为它在每个关节上定义的局部坐标转换到世界坐标后的加权和。

![](1680599671524.png)

![](1680599672066.png)

### Interpolation

在动画制作过程中一般只会记录下一系列关键帧上骨骼的姿态，而要得到实际的动画还需要通过插值来获得中间帧上模型的运动。

![](1680599672607.png)

![](1680599673176.png)

![](1680599673734.png)

线性插值是最基本的插值方法，我们可以通过对关节姿态的插值来计算中间帧上的模型运动。

![](1680599674293.png)

对于三维旋转的插值要相对复杂一些，不过我们可以借助四元数的运算来进行处理。要获得插值后的旋转只需要对四元数直接进行线性插值，然后再进行归一化即可，这样的方法称为 NLERP。

![](1680599674829.png)

需要说明的是 NLERP 并不是真的对旋转进行线性插值。当动画的帧数较高时 NLERP 会有明显的违和感，这是由于它没有考虑旋转并不是线性空间。

![](1680599675359.png)

![](1680599675892.png)

想要真的对旋转进行线性插值可以使用 SLERP 这样的算法，不过 SLERP 的计算代价要比 NLERP 要大一些。

![](1680599676462.png)

![](1680599677006.png)

### AnimationRuntime Pipeline

我们把上面介绍过的算法整理一下就得到了一个简单的蒙皮动画管线如下。现代 3A 游戏在此基础上还会更多地把计算配置到 GPU 上来充分计算资源。

![](1680599677518.png)

## Animation Compression

**动画压缩 (animation compression)** 是计算机动画中非常实用的技术。实际上直接存储每个模型上每个关节的姿态需要占用非常多的资源，因此利用一些压缩技术来减少动画存储空间有着非常重要的意义。

![](1680599678035.png)

![](1680599678572.png)

### DoF Reduction

在广泛的实践中人们发现不同关节不同自由度的信号之间有着巨大的差异。以大腿关节为例，在大多数情况下它的缩放自由度都是 1 而且大部分的平动自由度都是 0，它的运动基本都是来自于旋转；而对于手指这样的关节，它的旋转很少但是平动会相对多一些。

![](1680599679180.png)

![](1680599679712.png)

因此最简单的动画压缩方法是直接缩减运动的自由度，把关节的缩放和平动自由度直接去掉只保存旋转。

![](1680599680254.png)

### Keyframe

对于旋转自由度我们可以使用**关键帧 (keyframe)** 来对信号进行离散，然后通过插值来重建原始信号。

![](1680599680871.png)

在离散时还可以利用不等间距采样的方式来进一步压缩信号。

![](1680599681442.png)

直接使用线性插值来描述非等间距采样的旋转信号仍然不够自然，这里推荐使用 Catmull-Rom 曲线来对关键帧进行插值。Catmull-Rom 曲线只需要一个锐度参数α$\alpha$以及 4 个控制点就可以获得 C1 连续的光滑曲线。基于 Catmull-Rom 曲线可以实现非常高精度的信号离散和重建效果。

![](1680599682002.png)

![](1680599682539.png)

### Quantization

进一步压缩数据时还可以考虑使用低精度的存储方式来记录位移信号。比如说可以通过规范化的方法将 32 位浮点数转换为 16 位无符号整数来表示，这样虽然损失了一些精度但却可以极大地减少存储空间。

![](1680599683055.png)

![](1680599683586.png)

对四元数进行压缩时可以利用单位四元数每一位上数值的范围来进行化简。具体来说我们可以首先使用 2 个 bit 来表示四元数的哪一位被丢掉了，剩下的 3 位可以分别使用 15 个 bit 来进行表达。这样一个四元数可以使用 48 个 bit 来进行存储，远小于使用 4 个 float 所需的 128 个 bit。

![](1680599684131.png)

![](1680599684760.png)

![](1680599685303.png)

### Error Propagation

数据压缩必然会导致精度损失的问题。对于一些末端的关节，由于误差传播的效应可能会产生非常大的累计误差。这种现象的直观反映就是模型可能会产生视觉上可见的偏移。

![](1680599685820.png)

![](1680599686427.png)

要缓解这种累计误差首先需要定量化的描述误差。我们可以直接对比数据压缩前后模型每个顶点上的坐标差异，但这种做法的计算代价过于巨大，目前工业界的主流处理方法是在关节上设置虚拟顶点然后利用虚拟顶点压缩前后的差异来描述误差。

![](1680599686967.png)

![](1680599687524.png)

![](1680599688094.png)

而要缓解累计误差我们可以为不同的关节设置不同的存储精度，或是通过主动补偿的方式来进行修正。总体而言，对于累计误差目前没有非常完善的处理方法。

![](1680599688637.png)

![](1680599689179.png)

## Animation DCC Process

本节课最后介绍了动画制作的流程。一般来说蒙皮动画的制作包括建立网格模型、绑定骨骼、蒙皮、制作骨骼动画以及导出等步骤。

![](1680599689789.png)

动画制作的第一步是建立网格模型。一般来说建模师设计的三维模型会具有远高于动画需求的精度，因此在动画制作阶段往往只会使用低精度的模型进行处理。

![](1680599690307.png)

需要注意的一点是为了保证最终动画成品的效果，建模师在建模时一般会在关节处对网格进行加密。

![](1680599690862.png)

接下来需要为模型制作骨骼，目前主流的三维建模软件都集成了骨骼的功能。在角色基本骨骼的基础上一般还会根据游戏玩法进一步添加一些额外的关节，包括武器、坐骑等。

![](1680599691431.png)

然后我们需要把顶点绑定到骨骼上，这一般需要在软件自动计算的基础上结合建模师的经验进行手动校正。

![](1680599691979.png)

在动画建模阶段则需要由动画师根据关键帧设置模型的动作。

![](1680599692522.png)

最后游戏引擎需要提供相应的模型导出功能。目前工业标准是使用 FBX 格式来保存动画所需的全部几何运动数据。

![](1680599693040.png)

## Reference

*   [Lecture 08：Basics of Animation Technology I](https://www.bilibili.com/video/BV1jr4y1t7WR/?spm_id_from=333.788)
*   [Lecture 08：Basics of Animation Technology II](https://www.bilibili.com/video/BV1fF411j7hA/?spm_id_from=333.788)
*   [四元数与三维旋转](https://krasjet.github.io/quaternion/quaternion.pdf)
*   [曹则贤开讲” 从一元二次方程到规范场论” 中国科学院 2022 跨年科学演讲第三场全程回顾](https://www.bilibili.com/video/BV1qa411B792?t=6557.6)