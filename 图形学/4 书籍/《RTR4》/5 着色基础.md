 

_“一张好画等于一件善事”—— 文森特. 梵高_

_“A good picture is equivalent to a good deed.”_

_—Vincent Van Gogh_

渲染三维对象的图像时，模型不仅应具有适当的几何形状，而且还应具有所需的视觉外观。根据应用程序的不同，其范围可以从照片写实（外观与真实对象的照片几乎相同）到出于创造性原因选择的各种类型的风格化外观。有关两者的示例，请参见图 5.1。

本章将讨论同样适用于真实感和风格化渲染方面的着色。第 15 章专门致力于风格化渲染，而本书的重要部分（第 9 章至第 14 章）则着重于通常用于照片级真实感渲染的基于物理的方法。

## 5.1 着色模型 Shading Models

决定渲染物体的外观的第一步是选择一个渲染模型（shading model）用来描述物体的颜色应该怎样变化，相关的因素有表面方向（surface orientation），视角方向（view direction），以及光照（lighting）等等。

举个例子，我们将使用 Gooch 着色模型 **[561]** 的变体。这是第 15 章中讨论的非真实感渲染的一种形式。Gooch 着色模型旨在提高技术例证（technical illustrations）中细节的易读性。

Gooch 着色背后的基本思想是将表面法线与光源的位置进行比较。如果法线指向灯光，则使用较温暖的色调为表面着色； 如果指向不对，则使用较冷的色调。介于两者之间的角度在这些色调之间进行插值，这取决于用户提供的表面颜色。在此示例中，我们向模型添加了风格化的 “突出显示” 效果，以使表面具有光泽外观。图 5.2 显示了实际的着色模型。

着色模型通常具有用于控制外观变化的属性。设置这些属性的值是确定对象外观的下一步。我们的示例模型只有一种属性，即表面颜色，如图 5.2 的底部图像所示。

![[aa0a3d6ae1742d035b5ba429bc782d66_MD5.png]]

_图 5.1。顶部图像来自使用虚幻引擎渲染的真实风景的场景。底部图片来自 Campo Santo 的游戏 Firewatch，该游戏采用说明性艺术风格设计。（上图由 GöokhanKaradayi 提供，下图由 Campo Santo 提供。）_

像大多数着色模型一样，此示例受相对于视图和光照方向的表面方向的影响。出于着色目的，这些方向通常表示为归一化（单位长度）向量，如图 5.3 所示。

现在，我们已经定义了着色模型的所有输入，接下来可以看一下模型本身的数学定义：

![[78e71f066eae21004e78460266663713_MD5.gif]]

![[cf44ab4cf9291ac199de29c5d60e36ab_MD5.png]]

_图 5.2。风格化的着色模型，结合了 Gooch 着色和高光效果。顶部图像显示了具有中性表面颜色的复杂对象。下图显示了具有各种不同表面颜色的球体。 （来自计算机图形学档案 **[1172]** 的中国龙模型，来自斯坦福 3D 扫描存储库的原始模型。）_

![[e2ade6e02eeff49675d686fda155e020_MD5.png]]

_图 5.3。单位长度向量输入到示例着色模型（和其他大多数着色模型）：表面法线_

_![[2b9e49b5f6bd2ccfe018b78698794666_MD5.gif]]_

_，视图向量

![[0da9e11a3936d7316db28f189ea3dd80_MD5.gif]]

和光照方向 $l$。_

在此公式中，我们使用了以下的中间计算：

$\\ \textbf{c}_{\textrm{cool}}=(0,0,0.55)+0.25\textbf{c}_{\textrm{surface}}, \\ \textbf{c}_{\textrm{warm}}=(0.3,0.3,0)+0.25\textbf{c}_{\textrm{surface}}, \\ \textbf{c}_{\textrm{highlight}}=(1,1,1), \\ t=\frac{(\textbf{n}\cdot\textbf{l}+1)}{2},\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.2) \\ \textbf{2}=2(\textbf{n}\cdot\textbf{l})\textbf{n}-\textbf{l}, \\ s=(100(\textbf{r}\cdot \textbf{v})-97). \\$

该定义中的几个数学表达式也经常在其他着色模型中找到。着色操作中通常会进行 Clamping 操作，通常 Clamping 到 0 或 Clamping 在 0 到 1 之间。在这里，我们将使用在 1.2 节中介绍的 $x^{\mp }$ 标记，将其用于高光混合因子 $s$ 的计算中 0 和 1 之间的 Clamp 之中。点积运算符出现 3 次，每次出现在两个单位长度的向量之间； 这是一个非常普遍的模式。两个向量的点积是它们的长度与它们之间夹角的余弦的乘积。因此，两个单位长度向量的点积就是余弦，它是两个向量彼此对齐程度的度量。由余弦组成的简单函数通常是最令人愉悦和最准确的数学表达式，用于说明着色模型中两个方向（例如，光方向和表面法线）之间的关系。

另一种常见的着色操作是基于 0 到 1 之间的标量值在两种颜色之间线性插值。该操作采用 $t\textbf{c}_{a}+(1-t)\textbf{c}_{b}$ 的形式，随着 t 的值在 1 和 0 之间移动，它会在 $\textbf{c}_{a}$ 和 $\textbf{c}_{b}$ 之间进行插值。分别，此图案在此着色模型中出现了两次，第一次在 $\textbf{c}_{\textrm{warm}}$ 和 $\textbf{c}_{\textrm{cool}}$ 之间进行插值，第二次在先前的插值结果与 $\textbf{c}_{\textrm{highlight}}$ 之间进行插值。线性插值在着色器中出现的频率很高，以至于在我们已经看到的每种着色语言中，它都是一个内置函数，称为 $\textrm{lerp}$ 或 $\textrm{mix}$ 。

线 $\textbf{r}=2(\textbf{n}\cdot\textbf{l})\textbf{n}-\textbf{l}$ 计算反射光向量，将 $\textbf{l}$ 反射大约 $\textbf{n}$。尽管不像前两个操作那样普遍，但是对于大多数着色语言来说，它也足够具有内置的反射功能。

通过将这些操作以不同的方式与各种数学表达式和着色参数组合在一起，可以为多种风格化和写实的外观定义着色模型。

* * *

**引用：**

****[561]**** Gooch, Amy, Bruce Gooch, Peter Shirley, and Elaine Cohen, “A Non-Photorealistic Lighting Model for Automatic Technical Illustration,” in SIGGRAPH ’98: Proceedings of the 25th Annual Conference on Computer Graphics and Interactive Techniques, ACM, pp. 447–452, July 1998. Cited on p. 103

****[1172]**** McGuire, Morgan, Computer Graphics Archive, http://graphics.cs.williams.edu/data, Aug. 2011. Cited on p. 105, 118

## 5.2 光源 Light Sources

光照（lighting）对我们的示例着色模型的影响非常简单。它提供了着色的主要方向。当然，现实世界中的光照可能非常复杂。可以有多个光源，每个光源都有自己的大小，形状，颜色和强度。间接光照会带来更多变化。正如我们将在第 9 章中看到的那样，基于物理的真实感（photorealistic）着色模型需要考虑所有这些参数。

相反，根据应用程序和视觉样式的需要，风格化的着色模型可以以多种不同方式使用光照。一些高度风格化的模型可能根本没有光照的概念，或者（例如我们的 Gooch 着色示例）可能仅使用它来提供一些简单的方向性。

光照复杂性的下一步是使着色模型以二进制方式对光的存在或不存在做出反应。用这种模型着色的表面在光照时将具有一种外观，而在不受光影响的情况下将具有不同的外观。这暗示了区分这两种情况的一些标准：距光源的距离，阴影（将在第 7 章中讨论），表面是否背对光源（即，表面法线 $\textbf{n}$ 与光照方向向量 $\textbf{l}$ 之间的角度大于 90°），或这些因素的某种组合。

从非暗即亮（binary presence）的光照到能逐渐变化强度的光照，仅需要一小步。这可以表示为光的不存在和完全存在之间的简单插值，即表示强度的有界范围，它可能为 0 到 1 ，或者可能为以某种其他方式影响着色的无边界数值（unbounded quantity）。后者的常见选择是将着色模型拆解为亮部和暗部，而光照强度 $k_{\textrm{light}}$ 线性地改变亮部：

$\textbf{c}_{\textrm{shaded}}=f_{\textrm{unlit}}(\textbf{n},\textbf{v})+k_{\textrm{light}}f_{\textrm{lit}}(\textbf{l},\textbf{n},\textbf{v}).\;\;\;\;\;\;\;\;\;\;(5.3)$

这个可以简单地扩展为 RGB 光照颜色 $\textbf{c}_{\textrm{light}}$，

$\textbf{c}_{\textrm{shaded}}=f_{\textrm{unlit}}(\textbf{n},\textbf{v})+c_{\textrm{light}}f_{\textrm{lit}}(\textbf{l},\textbf{n},\textbf{v}),\;\;\;\;\;\;\;\;\;\;(5.4)$

以及多个光源，

$\textbf{c}_{\textrm{shaded}}=f_{\textrm{unlit}}(\textbf{n},\textbf{v})+\sum ^{n}_{i=1}\textbf{c}_{\textrm{light}_{i}}f_{\textrm{lit}}(\textbf{l}_{i},\textbf{n},\textbf{v}).\;\;\;\;\;\;\;\;\;\;(5.5)$

无光照部分 $f_{\textrm{unlit}}(\textbf{n},\textbf{v})$ 对应将光视为二进制的着色模型的 “不受光影响时的外观”。它可以具有各种形式，具体取决于所需的视觉效果和应用程序的需求。例如，$f_{\textrm{unlit}}()=(0,0,0)$ 将使不受光源影响的任何表面变为纯黑色。另外，无光照的部分可以为无光照的物体表达某种形式的视觉外观，类似于 Gooch 模型的背向光线的表面的冷色。通常，着色模型的这一部分表示某种形式的光照，这些光照并非直接来自明确放置的光源，例如来自天空的光或来自周围物体反射的光。这些其他形式的光照将在第 10 章和第 11 章中讨论。

前面我们提到，如果光照方向 $\textbf{l}$ 与表面法线 $\textbf{n}$ 的距离大于 90°，则光源不会影响表面点，实际上是来自表面的下面。这可以认为是光相对于表面的方向与其对着色的影响之间具有更一般关系的特例。尽管是基于物理的，但这种关系可以从简单的几何原理得出，并且对于许多类型的非基于物理的，风格化的着色模型也很有用。

可以将光在表面上的效果可视化为一组射线，其中射线密度击中表面对应用于表面着色的光照强度。参见图 5.4，该图显示了光照表面的横截面。沿该截面入射到表面的光线之间的间距与 $\textbf{l}$ 和 $\textbf{n}$ 之间的角度的余弦成反比。因此，入射到表面的光线的总密度与 $\textbf{l}$ 和 $\textbf{n}$ 之间的角度的余弦成正比，正如我们前面所看到的，它等于这两个单位长度向量之间的点积。在这里，我们看到了为什么定义与光的传播方向相反的光照向量 $\textbf{l}$ 会很方便； 否则我们将不得不在执行点积运算之前将其取反。

更准确地说，当光线密度为正时，其光线密度（以及光线对着色的贡献）与点积成正比。负值对应于从表面后面发出的光线，无效。因此，在将灯光的着色乘以照明点积之前，我们需要先 Clamp 点积为 0。使用第 1.2 节中介绍的 $x^{+}$ 表示，即将负值 Clamp 为 0，我们会得到 

$\textbf{c}_{\textrm{shaded}}=f_{\textrm{unlit}}(\textbf{n},\textbf{v})+\sum ^{n}_{i=1}(\textbf{l}_{i}\cdot\textbf{n})^{+}\textbf{c}_{\textrm{light}_{i}}f_{\textrm{lit}}(\textbf{l}_{i},\textbf{n},\textbf{v}).\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.6)$

支持多个光源的着色模型通常将使用公式 5.5（更通用）或公式 5.6（基于物理的模型所需）中的一种结构。这对于风格化模型也可能是有利的，因为它有助于确保照明的总体一致性，尤其是对于背离灯光或着色表面。但是，某些模型不适用于该结构。此类模型将使用公式 5.5 中的结构。

对于函数 $f_{\textrm{lit}}()$ 来说，最简单的选择是使其颜色恒定，

$f_{\textrm{lit}}()=\textbf{c}_{\textrm{surface}},\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.7)$

这将推导出以下着色模型：

$\textbf{c}_{\textrm{shaded}}=f_{\textrm{unlit}}(\textbf{n},\textbf{v})+\sum ^{n}_{i=1}(\textbf{l}_{i}\cdot\textbf{n})^{+}\textbf{c}_{\textrm{light}_{i}}\textbf{c}_{\textrm{surface}}.\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.8)$

该模型的上光部分（lit part）对应于 1760 年出版的约翰 · 海因里希 · 兰伯特（Johann Heinrich Lambert）**[967]** 之后的兰伯特着色模型（Lambertian shading model）， 该模型在理想的漫反射表面（即完全无光泽的表面）的背景下工作。在这里，我们对 Lambert 模型进行了一些简化的解释，第 9 章将对此进行更严格的介绍。Lambertian 模型可单独用于简单着色，它是许多着色模型的关键组成部分。

从公式 5.3 - 5.6 可以看出，光源通过两个参数与着色模型交互：指向光的向量 $\textbf{l}$ 和浅色的 $\textbf{c}_{\textrm{light}}$。有多种不同类型的光源，它们的主要区别在于这两个参数在场景中的变化方式。

接下来，我们将讨论几种流行类型的光源，它们有一个共同点：在给定的表面位置，每个光源仅从一个方向 $\textbf{l}$ 照射表面。换句话说，从着色表面位置看，光源是一个无限小的点。对于现实世界的光源，这并非严格如此，但是大多数光源相对于它们与被照明表面的距离较小，因此这是一个合理的近似值。在 7.1.2 和 10.1 节中，我们将讨论从多个方向照亮表面位置的光源，即 “区域光”（area lights）。

* * *

**引用：**

****[967]**** Lambert, J. H., Photometria, 1760. English translation by D. L. DiLaura, Illuminating Engineering Society of North America, 2001. Cited on p. 109, 389, 390, 469

### 5.2.1 方向光 Directional Lights

方向光（Directional Lights）是光源的最简单模型。$\textbf{l}$ 和光在整个场景中都是恒定的，除了光可能会因阴影而衰减。方向光无位置。当然，实际的光源确实在空间中具有特定的位置。方向光是抽象的，当到光源的距离相对于场景大小较大时，方向光会很好地工作。例如，20 英尺远的泛光灯可以照亮一个小的桌面西洋镜，这种情况就可以表示为方向光。另一个例子是几乎所有被太阳照亮的场景都可以用方向光，除非所涉及的场景是诸如太阳系内行星之类的东西。

方向光的概念可以稍微扩展，以允许在光方向 $\textbf{l}$ 保持恒定的同时改变 $\textbf{c}_{\textrm{light}}$ 的值。通常出于表现或创意原因，这样做通常是将灯光效果绑定到场景的特定部分。例如，可以用两个嵌套的（一个在另一个内）盒形体积定义一个区域（外盒与内盒），其中 $\textbf{c}_{\textrm{light}}$ 等于外盒之外的（0，0，0）（纯黑色），也等于内盒之内的某个常数，并且在两个盒之间的区域中的那些极值之间平滑插值。

### 5.2.2 精确光 Punctual Lights

精确光（punctual light）并不是准时约会（on time for its appointments），而是具有实际位置的光，这是与方向光不同的。但这与现实世界的光源也不同，此类光源也没有尺寸，形状或大小。对于拉丁语的 “点”（punctus），我们使用术语 “punctual” 来表示 “点”（point），该类包括源自单个局部位置的所有照明源。我们使用 “点光”（point light）一词来表示一种特定类型的发射器，它在所有方向上均等地发射光。因此，点光（point light）和聚光灯（spotlight）是精确光（punctual lights）的两种不同形式。光线方向向量 $\textbf{l}$ 随当前着色表面点 $\textbf{p}_{0}$ 相对于点光源的位置 $\textbf{p}_{\textrm{light}}$ 的位置而变化：

$\textbf{l}=\frac{\textbf{p}_{\textrm{light}}-\textbf{p}_{0}}{\left \|\textbf{p}_{\textrm{light}}-\textbf{p}_{0}\right \|} .\;\;\;\;\;\;\;\;\;\;(5.9)$

此公式是向量归一化的一个示例：将向量除以其长度即可产生指向相同方向的单位长度向量。这是另一种常见的着色操作，就像我们在上一节中看到的着色操作一样，它是大多数着色语言中的内置函数。但是，有时需要此操作的中间结果，这需要使用更多基本操作以多个步骤显式执行标准化。将其应用于精确光方向计算可以得到以下结果：

$\\ \textbf{d}=\textbf{p}_{\textrm{light}}-\textbf{p}_{0}, \\ r=\sqrt{\textbf{d}\cdot\textbf{d}},\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.10) \\ \textbf{l}=\frac{\textbf{d}}{r}.$

由于两个向量的点积等于两个向量的长度与它们之间夹角的余弦的乘积，并且 0º 的余弦为 1.0，因此向量与自身的点积就是其长度的平方。因此，要找到任何向量的长度，我们只需将其自身点积并取结果的平方根即可。

我们需要的中间值是 $r$，即点光源和当前着色点之间的距离。除了将其用于归一化光向量外，还需要 $r$ 的值来计算作为距离函数的浅色 $\textbf{c}_{\textrm{light}}$ 的衰减（变暗）。这将在下一节中进一步讨论。

**点光 / 全向光 Point/Omni Lights**

在所有方向上均匀发光的点状光被称为点光或全向光。对于点光源，光线随距离 $r$ 的变化而变化，唯一的变化源是上述距离衰减。图 5.5 使用类似于图 5.4 中余弦因数的几何推理说明了为什么会变暗。在给定的表面上，来自点光源的光线之间的间距与从表面到光线的距离成比例。与图 5.4 中的余弦因子不同，此间距的增加沿表面的两个维度发生，因此射线密度（这里颜色为 $\textbf{c}_{\textrm{light}}$）与平方反比距离 $1/r^{2}$ 成比例。这使我们能够使用单个光照属性 $\textbf{c}_{\textrm{light0}}$ 来指定 $\textbf{c}_{\textrm{light}}$ 的空间变化，该属性定义为在固定参考距离 $r0$ 处的 $\textbf{c}_{\textrm{light}}$ 值：

$\textbf{c}_{\textrm{light}}(r)=\textbf{c}_{\textrm{light}_{0}}(\frac{r_{0}}{r})^{2}.\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.11)$

公式 5.11 通常被称为平方反比光衰减（inverse-square light attenuation）。尽管从技术上讲，对于点光源，距离衰减是正确的，但仍有一些问题使此公式不适用于实际的着色。

第一个问题发生在相对较小的距离处。当 $r$ 的值趋于 0 时，clight 的值将无限制地增加。当 $r$ 达到 0 时，我们将得到除以零的奇点（singularity）。为了解决这个问题，一种常见的修改是在分母 **[861]** 上增加一个小值 $\epsilon$：

$\textbf{c}_{\textrm{light}}(r)=\textbf{c}_{\textrm{light}_{0}}\frac{r_{0}^{2}}{r^{2}+\epsilon}.\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.12)$

ǫ的确切值取决于具体应用。例如，虚幻引擎（Unreal Engine）使用 $\epsilon$ = 1 cm **[861]**。在 CryEngine **[1591]** 和 Frostbite **[960]** 游戏引擎中使用的另一种修改是将 $r$ 固定为最小值 $r_{min}$：

$\textbf{c}_{\textrm{light}}(r)=\textbf{c}_{\textrm{light}_{0}}\left ( \frac{r_{0}}{\textrm{max}(r,r_{min})} \right )^{2}.\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.13)$

与先前方法中使用的任意值 $\epsilon$ 有些不同，$r_{min}$ 的值具有物理解释：发射光的物理对象的半径。小于 $r_{min}$ 的 $r$ 值对应于穿透物理光源内部的着色表面，而这是不可能的。

![[bb9e38a52c2a4883a3bd947ca1ff06f1_MD5.png]]

_图 5.5。来自点光源的光线之间的间距与距离 $r$ 成正比增加。由于间距的增加是二维的，因此光线的密度（以及光强度）成比例地降低到  $1/r^{2}$。_

相反，平方反比衰减的第二个问题发生在相对较大的距离处。问题不在于视觉效果，而在于性能。尽管光强度会随着距离的增加而降低，但是它永远不会变为 0。为了有效渲染，希望光在某个有限距离处达到 0 强度（第 20 章）。可以通过多种不同的方式修改平方反比公式来实现这一目的。理想情况下，修改应引入尽可能少的更改。为了避免在光线影响的边界处出现明显的截止，还建议修改函数的导数和值在相同距离处达到 0。

一种解决方案是将平方函数乘以具有所需属性的开窗函数。虚幻引擎 **[861]** 和 Frostbite **[960]** 引擎都使用了这样一种功能 **[860]**：

$f_{\textrm{win}}(r)=\left ( 1-\left ( \frac{r}{r_{\textrm{max}}} \right )^{4}\right )^{+2}.\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.14)$

+2 表示在平方之前将值（如果为负）Clamp 为 0。图 5.6 显示了示例的平方反比曲线，公式 5.14 中的窗函数以及两者相乘的结果。

![[6d2699fae1ee9d44641c36d99154c07a_MD5.png]]

_图 5.6。该图显示了平方反比的曲线（使用 $\epsilon$ 方法以避免奇异性，$\epsilon$ 值为 1），公式 5.14 中描述的窗函数（ $r_{\textrm{max}}$ 设置为 3 ）和窗曲线。（注：在信号处理中，窗函数（英语：window function）是一种除在给定区间之外取值均为 0 的实函数。）_

应用的需求将影响所用方法的选择。例如，当以相对较低的空间频率（例如，在光照贴图或每个顶点中）采样距离衰减函数时，在 $r_{\textrm{max}}$ 处使导数等于 0 尤为重要。CryEngine 不使用光照贴图或顶点照明，因此它使用了更简单的调整，切换为 $0.8r_{\textrm{max}}$ 和 $r_{\textrm{max}}$ 之间的线性衰减 **[1591]**。

对于某些应用，匹配平方反比曲线不是优先事项，因此完全使用其他功能。这有效地将公式 5.11 - 5.14 概括为以下内容：

$\textbf{c}_{\textrm{light}}(r)=\textbf{c}_{\textrm{light}_{0}}f_{\textrm{dist}}(r),\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.15)$

其中 $f_{\textrm{dist}}(r)$ 是关于距离的某些函数。这种函数称为距离衰减函数（distance falloff functions）。在某些情况下，非反平方衰减函数（non-inverse-square falloff）的使用受性能约束的驱动。例如，游戏《正当防卫 2（Just Cause 2）》所需的灯光计算成本非常低廉。因此便规定了一个易于计算的衰减函数，同时该函数还足够平滑，可以避免逐顶点照明瑕疵（per-vertex lighting artifacts） **[1379]**：

$f_{\textrm{dist}}(r)=\left ( 1-\left ( \frac{r}{r_{\textrm{max}}} \right )^{2} \right )^{+2}.\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.16)$

在其他情况下，衰减功能的选择可能由创造性的考虑决定。例如，用于现实游戏和程式化游戏的虚幻引擎具有两种用于光衰减的模式：如公式 5.12 中所述的平方反比模式和可以调整以创建各种衰减曲线的指数衰减模式。**[1802]**。游戏 Tomb Raider（2013）的开发人员使用样条编辑工具来编写衰减曲线 **[953]**，从而可以更好地控制曲线形状。

**聚光灯 Spotlights**

与点光源不同，几乎所有现实世界光源的光照都随方向和距离而变化。这种变化可以表示为方向衰减函数 $f_{\textrm{dir}}(\textbf{l})$（directional falloff function） ，该函数与距离衰减函数结合以定义光照强度的整体空间变化：

$\textbf{c}_{\textrm{light}}=\textbf{c}_{\textrm{light}_{0}}f_{\textrm{dist}}(r)f_{\textrm{dir}}(\textbf{l}).\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.17)$

$f_{\textrm{dir}}(\textbf{l})$ 的不同选择可以产生各种照明效果。一种重要的效果是聚光灯（spotlight），它可以将光投射到圆锥形中。聚光灯的方向衰减函数具有围绕聚光灯方向向量 $\textbf{s}$ 的旋转对称性，因此可以表示为 $\textbf{s}$ 与相对于表面的反向光向量 -1 之间的角度 $\theta _{s}$ 的函数。需要反转光向量，因为我们在表面上将 $\textbf{l}$ 定义为指向光，而在这里我们需要指向远离光方向的向量。

大多数聚光灯功能都使用由 $\theta_{s}$ 的余弦组成的表达式，这是着色中角度的最常见的形式（如我们先前所见）。聚光灯通常具有本影角θu，该本影角对光进行限制，以使所有 $\theta_{s} \geqslant \theta_{u}$ 的 $f_{\textrm{dir}}(\textbf{l})=0$。该角度可以与前面看到的最大衰减距离 $r_{\textrm{max}}$ 类似的方式用于剔除。聚光灯通常具有半影角（penumbra angle）$\theta _{p}$，该半影角（penumbra angle）定义了一个内锥，在该内锥处，光处于其全部强度。见图 5.7。

![[5faf011cdcd8b23619e6e5f44bcd0c3c_MD5.png]]

_图 5.7。聚光灯：$\theta_{s}$ 是从灯的定义方向 $\textbf{s}$ 到向量 -1 的角度，即到表面的方向； $\theta_{p}$ 表示半影；  $\theta_{u}$ 表示为光定义的本影角。_

聚光灯使用了各种方向衰减功能，但它们往往大致相似。例如，函数 $f_{\textrm{dir}_{F}}(\textbf{l})$ 用于 Frostbite 游戏引擎 **[960]**，函数 $f_{\textrm{dir}_{T}}(\textbf{l})$ 用于 three.js 浏览器图形库 **[218]**：

$\\ t=\left ( \frac{\textrm{cos}\;\theta_{s} - \textrm{cos}\;\theta_{u}}{\textrm{cos}\;\theta_{p} - \textrm{cos}\;\theta_{u}} \right )^{\mp} , \\ f_{\textrm{dir}_{F}}(\textbf{l})=t^{2},\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;(5.18) \\ f_{\textrm{dir}_{F}}(\textbf{l})=\textrm{smoothstep}(t)=t^{2}(3-2t).$

回想一下，$x^{\mp }$ 是我们在 1.2 节中介绍的将 $x$ Clamp 在 0 和 1 之间的符号。平滑步长函数（smoothstep function）是三次多项式（cubic polynomial），通常用于着色中的平滑插值。它是大多数着色语言的内置函数。

图 5.8 显示了到目前为止我们讨论过的某些光源类型。

![[1ab8e6ac72c3b77f71c038d62cd837d3_MD5.png]]

_图 5.8。某些类型的灯。从左到右：定向，无衰减的点光源和平滑过渡的聚光灯。请注意，由于光线和表面之间的角度变化，点光会朝边缘变暗。_

**其他精确光**

精确光的照度值 $\textbf{c}_{\textrm{light}}$ 可以通过许多其他方式变化。

$f_{\textrm{dir}}(\textbf{l})$ 函数不限于上述简单的聚光灯衰减函数； 它可以代表任何类型的方向变化，包括从实际光源测量的复杂列表模式。照明工程协会（IES）已为此类测量定义了标准文件格式。IES 配置文件可从许多照明制造商处获得，并已用于游戏 Killzone：Shadow Fall **[379，380]**，以及 Unreal **[861]** 和 Frostbite **[960]** 游戏引擎中。Lagarde 很好地总结了 **[961]** 与解析和使用此文件格式有关的问题。

游戏《古墓丽影》（Tomb Raider，2013 年）**[953]** 具有一种精确光，可对沿世界坐标 x，y 和 z 轴的距离应用独立的衰减功能。在《古墓丽影》中，参数曲线还可以应用于随时间变化的光强度，例如制作一个闪烁的火炬。

在第 6.9 节中，我们将讨论如何通过使用纹理来改变光的强度和颜色。

* * *

**引用：**

****[********861********]**** Karis, Brian, “Real Shading in Unreal Engine 4,” SIGGRAPH Physically Based Shading in Theory and Practice course, July 2013. Cited on p. 111, 113, 116, 325, 336, 340, 342, 352, 355, 383, 385, 388, 421, 423

****[1591]**** Schulz, Nicolas, CRYENGINE Manual, Crytek GmbH, 2016. Cited on p. 111, 113, 631

****[960]**** Lagarde, S´ebastian, and Charles de Rousiers, “Moving Frostbite to Physically Based Rendering,” SIGGRAPH Physically Based Shading in Theory and Practice course, Aug. 2014. Cited on p. 111, 113, 115, 116, 312, 325, 336, 340, 341, 354, 371, 422, 426, 435, 503, 890

****[861]**** Karis, Brian, “Real Shading in Unreal Engine 4,” SIGGRAPH Physically Based Shading in Theory and Practice course, July 2013. Cited on p. 111, 113, 116, 325, 336, 340, 342, 352, 355, 383, 385, 388, 421, 423

****[860]**** Karis, Brian, “Tiled Light Culling,” Graphic Rants blog, Apr. 9, 2012. Cited on p. 113, 882

****[1379]**** Persson, Emil, “Making It Large, Beautiful, Fast, and Consistent: Lessons Learned Developing Just Cause 2,” in Wolfgang Engel, ed., GPU Pro, A K Peters, Ltd., pp. 571–596, 2010. Cited on p. 114, 556, 558, 715, 882

****[1802]**** Unreal Engine 4 Documentation, Epic Games, 2017. Cited on p. 114, 126, 128, 129, 262, 287, 364, 611, 644, 920, 923, 932, 934, 939

****[953]**** Lacroix, Jason, “Casting a New Light on a Familiar Face: Light-Based Rendering in Tomb Raider,” Game Developers Conference, Mar. 2013. Cited on p. 114, 116

****[218]**** Cabello, Ricardo, et al., Three.js source code, Release r89, Dec. 2017. Cited on p. 41, 50, 115, 189, 201, 407, 485, 552, 628

****[379********]**** Drobot, Michal, “Lighting of Killzone: Shadow Fall,” Digital Dragons conference, Apr. 2013. Cited on p. 116

****[********380]**** Drobot, Michal, “Physically Based Area Lights,” in Wolfgang Engel, ed., GPU Pro5 , CRC Press, pp. 67–100, 2014. Cited on p. 116, 388

****[861]**** Karis, Brian, “Real Shading in Unreal Engine 4,” SIGGRAPH Physically Based Shading in Theory and Practice course, July 2013. Cited on p. 111, 113, 116, 325, 336, 340, 342, 352, 355, 383, 385, 388, 421, 423

****[961]**** Lagarde, S´ebastian, “IES Light Format: Specification and Reader,” S´ebastian Lagarde blog, Nov. 5, 2014. Cited on p. 116, 435

****[953]**** Lacroix, Jason, “Casting a New Light on a Familiar Face: Light-Based Rendering in Tomb Raider,” Game Developers Conference, Mar. 2013. Cited on p. 114, 116

### 5.2.3 其他光照类型 Other Light Types

方向光和精确光的主要特征是如何计算光照方向

![[55f82f9116ccdec4613d3e7889cfa23b_MD5.png]]

。可以通过使用其他方法来计算光的方向来定义不同类型的光。例如，除了前面提到的光源类型外，《古墓丽影》还使用了胶囊体光源（Capsule Lights）**[953]**，这些光源不是点光源，而是线段。对于每个着色像素，将线段上最接近的点的方向用作光方向

![[55f82f9116ccdec4613d3e7889cfa23b_MD5.png]]

。

只要着色器具有用于评估着色方程的

![[55f82f9116ccdec4613d3e7889cfa23b_MD5.png]]

 和 

![[576a48f12c28ec68714cdd45c4dc8b07_MD5.png]]

 值，便可以使用任何方法来计算这些值。

到目前为止讨论的光的类型是抽象的。实际上，光源具有大小和形状，并且它们从多个方向照亮表面点。在渲染中，此类光源称为区域光源（area lights），并且它们在实时应用中的使用稳步增长。区域光渲染技术分为两类：模拟由于部分遮挡区域光而导致的阴影边缘柔化的技术（第 7.1.2 节）和模拟区域光对表面着色影响的技术。（第 10.1 节）。第二类照明对于光滑的镜面表面最为明显，在这种表面上，可以通过反射清楚地看到其形状和大小。另外，方向光和精确光，尽管它们不再像过去那样普遍使用，但不太可能被废弃。目前已经开发出一种计算照明面积的近似值的技术，性能消耗较少，因此得到了广泛的应用。GPU 性能的增强允许我们使用比过去更复杂的技术。

* * *

**引用：**

****[953]**** Lacroix, Jason, “Casting a New Light on a Familiar Face: Light-Based Rendering in Tomb Raider,” Game Developers Conference, Mar. 2013. Cited on p. 114, 116

 

这两节终于翻译完毕，不得不说原文篇幅是真的长，花了不少时间。

另外，以后引用的具体文章标题不会再列出来，一是为了节省时间，二是感觉列出来会过于冗余。所以如果想看具体引用文章标题的话，请在原书里手动搜索。

业余翻译，若有不周到之处，还请多多指教。



##  5.3 实现着色模型 Implementing Shading Models

为了发挥作用，这些着色和光照的方程当然必须在代码中实现。在本节中，我们将仔细介绍设计和编写此类实现的一些关键注意事项。此外，我们也会介绍一个简单的实现示例。

### 5.3.1 计算频率 Frequency of Evaluation

（注：frequency of evaluation 似乎是某个特别名词，暂未查到正式翻译，联系上下文后，发现译为 “计算频率” 更易理解。）

当设计一个着色实现时，需要根据他们的计算频率（frequency of evaluation）对计算进行划分。首先，要决定给出的计算结果是否总是在一个绘制调用（draw call）中保持恒定。在这种情况下，虽然 GPU 的计算着色器能够用于特别昂贵的计算，但是计算一般可由应用程序在 CPU 上执行。其计算的结果通过统一的着色器输入传到图形 API 中。

从 “一次” 开始，即使在这个类别中，也存在有大范围可能的计算频率。最简单的例子就是着色方程中一个常量子表达式，但是这可以应用到那些很少更改参数的例如硬件配置和安装选项的计算中。这种着色计算可能在着色器编译的时候就完成了，这种情况下甚至不需设置一个统一的着色器输入。或者，在安装阶段或当应用被加载时，计算就会被一个离线的预计算 Pass 所执行。

另一种情况是，着色计算的结果在应用程序执行时不断变化，但是这个变化很慢，以至于不需要在每一帧都进行更新。例如基于虚拟游戏世界时间的光照参数。如果计算的消耗是昂贵的，那么它应该被平摊到多帧。

其他情况下，包括每帧执行一次的计算，例如连接视图和透视矩阵；或每个模型执行一次的计算，例如根据位置更新模型的光照参数；或每次绘制调用（draw call）执行一次，例如，更新模型中每种材质的参数。通过计算频率，我们将统一的着色器输入分组，这样有助于提高应用程序的效率，并且还可以通过最小化常量更新（minimizing constant updates）来提高 GPU 的性能 **[1165]**。

如果着色计算的结果在一个绘制调用中不断变化，那么它就不能由一个统一的着色器输入传到着色器中。取而代之的是，它必须在第 3 章提到的可编程着色阶段之一中被计算，并且如果需要的话，会通过不同的着色器输入传到其他阶段。理论上，着色计算能在任何一个可编程阶段上执行，其中每个都对应着不同的计算频率：

顶点着色器（Vertex shader） —— 计算每个曲面细分前的顶点。

外壳着色器（Hull shader） —— 计算每个表面补丁。

域着色器（Domain shader） —— 计算每个曲面细分后的顶点。

几何着色器（Geometry shader）—— 计算每个图元。

像素着色器（Pixel shader）—— 计算每个像素。

![[b1a26d4a15bb2375d662beed00dda096_MD5.png]]

_图 5.9 对于来自公式 5.19 的案例着色模型的逐像素和逐顶点的计算结果的比较，展示了三个不同顶点密度的模型。左侧展示了逐像素计算的结果，中间展示了逐顶点计算的结果，以及右边呈现了每个模型的线框渲染以展示顶点的密度。（来自计算机图形学档案的中国龙网格模型 **[1172]**，原模型来自斯坦福 3D 扫描存储库）_

实际上，大部分着色计算是逐像素执行的。尽管这些通常是在像素着色器中实现的，但是计算着色器的实现正变得越来越普遍；相关的一些例子将在第 20 章中讨论。其他阶段主要用于几何操作，例如变换和变形。为了理解为什么是这种情况，我们会对比逐顶点和逐像素着色计算的结果。在旧版的文本里，它们有时会被称作 Gouraud 着色（Gouraud shading）**[578]** 和 Phong 着色（Phong Shading）**[1414]**，尽管这些术语如今已不常使用。对比中使用的着色模型在某些方面与公式 5.1 中的较为相似，但是经过修改，它可以与多个光源一起使用。当我们详细讲解案例的实现时，会在之后给出完整的着色模型。

图 5.9 展示了不同顶点密度模型的逐像素和逐顶点着色的结果。对于龙，这个顶点密度极高的模型网格，逐顶点与逐像素之间的区别是很小的。但是对于茶壶，顶点着色计算导致了例如高光棱角分明的视觉错误，并且再两个三角面组成的平面上，顶点着色的版本很明显是不对的。导致这些错误的原因是着色方程，尤其是高光部分，在模型网格表面有着非线性变化的值。这使得它们不适合用于顶点着色器，其计算结果会在递交给像素着色器之前在三角面进行线性插值。

原则上来说，可以在像素着色器中仅计算着色模型的镜面高光部分（specular highlight），而在顶点着色器中计算其余部分。这可能不会导致视觉伪像（visual artifacts），并且理论上将节省一些计算。然而在实践中，这种混合实现通常不是最佳的。着色模型的线性变化部分往往在计算上花费最少，并且以这种方式拆分着色计算往往会增加相当多的开销，例如重复计算和额外的变化输入，从而导致弊大于利。

（注：visual artifacts 在此不是很好翻译，翻译为视觉人造物会莫名其妙，考虑到指的是之前提到的某种虚假感的视觉错误，且错误原因是与现实世界有差异，因此翻译为视觉伪像）

正如我们之前提到的，在大部分实现中，顶点着色器负责非着色操作，例如几何变换和变形。生成的几何表面属性，转换到合适的坐标系统中，并被顶点着色器写入，在三角面上进行线性插值，然后作为变化的着色器输入传入像素着色器。这些属性通常包括表面的位置，表面法线，以及可选的表面切线向量（如果需要法线贴图的话）。

需要注意的是，即使顶点着色器总是生成单位长度表面法线，插值也是能改变其长度的。见图 5.10 左侧。因此，法线需要在像素着色器中重新归一化（缩放至长度为 1）。然而，顶点着色器生成的法线的长度仍然很重要。如果法线长度在顶点间是明显不同的，例如，作为顶点混合的副作用，这就会使插值倾斜。此情况可见图 5.10 右侧。由于这两个副作用，具体的实现通常会在插值之前与之后，即在顶点着色器和像素着色器中，去归一化插值后的向量。

![[55a8ddcdc29741ffd0fd68b2809a9367_MD5.png]]

_图 5.10 在左侧，我们看到跨越表面的单位法线的线性插值将导致插值后的向量长度小于 1。在右侧，我们看到法线的线性插值有着明显不同的长度，这导致了插值后的方向朝着两个法线中较长的倾斜。_

与表面法线不同，指向特殊位置的向量，例如视图向量（view vector）和精确光的光向量（light vector），通常是不进行插值的。取而代之的是，在像素着色器中插值后的表面位置将被用来计算这些向量。除了在任何情况下都需要在像素着色器中执行的归一化操作外，每个向量都会用向量减法运算，这是很快的。如果因为一些原因，需要对这些向量进行插值的话，不要事先对它们进行归一化。这会导致错误的结果，见图 5.11。

![[49038dd159162785227c1251c975d083_MD5.png]]

_图 5.11 两个光向量间的插值。在左侧，在插值前将它们归一化将导致归一化后方向不正确。在右侧，对未归一化向量插值，得到了正确的结果。_

之前我们有提到顶点着色器变换表面几何体到 “合适的坐标系”。通过统一变量传递到像素着色器的相机与光源的位置，通常被应用程序变换到相同的坐标系。这样可以最大程度减少像素着色器将所有的着色模型向量带入相同的坐标空间的工作。但是究竟哪个坐标系是“合适” 的呢？可能的答案包括全局世界空间以及相机的局部坐标系，或者更罕见的，是当前渲染模型的局部坐标系。这通常是基于系统性的考虑，例如性能，灵活性和简单性，为整个渲染系统做出选择。举个例子，如果渲染的场景预计包含大量的光源，那么就应该选择世界空间以避免光源位置的变换。或者，最好使用相机空间，这样可以更好地优化与视图向量相关的像素着色器操作，并且提高精确度。（第 16.6 节）

虽然大部分的着色器实现，包括我们将要讨论的案例实现，都遵循上述一般概述，但是总有例外。举个例子，一些应用程序出于美术风格的原因选择了基于逐图元着色计算的多面外观。这种风格被称为平面着色（flat shading）。如图 5.12 是两个平面着色的例子。

原则上，可以在几何着色器中执行平面着色（flat shading），但是近年来相关的实现通常是使用顶点着色器。这是通过将每个图元的属性与其第一个顶点相关联并禁用顶点值插值来完成的。禁用插值（可以为每个顶点值分别处理）将导致第一个顶点的值传递到图元中的所有像素。

![[98ac83e922578fe22f82b9fc583a6e2a_MD5.png]]

_图 5.12 风格使用平面着色的两个游戏：肯塔基 0 号路（Kentucky Route Zero，上图）与 癌症似龙（That Dragon, Cancer，下图）（上图由 Cardboard Computer 提供，下图由 Numinous Games 提供）_

### **5.3.2 实现案例 Implementation Example**

我们现在会展示一个着色模型实现的案例。正如之前提到的，我们正在实现的着色模型与来自公式 5.1 的扩展的 Gooch 模型是相似的，但是我们经过了修改以让其能够支持多个光源。它可以被描述为

![[24dde8cb957bbfd788c4fd230e0fae63_MD5.gif]]

通过以下中间计算：

![[2a82bb3bb9d918311d0b3076b85b8dee_MD5.gif]]

此公式适合公式 5.6 中的多光源结构，为方便起见，在此重复：

![[e37c12b45d0e8ec10f9e35872dbb3744_MD5.gif]]

在此案例中，lit 和 unlit 项具体为

![[452e030ecf446bd34b79b9369afcc289_MD5.gif]]

调整冷色的 unlit 贡献值，使得结果看起来更像原始方程。

在大部分通常的渲染应用程序中，材质球属性的变化值诸如 $\textbf{c}_{\textrm{surface}}$ 会被存储在顶点数据，或者，更普遍的做法是存在纹理中（第六章）。然而，为了让这个案例的实现保持简单。我们会假设在整个模型中 $\textbf{c}_{\textrm{surface}}$ 是一个常数。

此实现方案会使用着色器的动态分支功能去循环处理所有的光源。然而尽管这种直接的方法可以很好地处理还算简单的场景，但是它对于庞大、具有复杂几何体，且拥有许多光源的场景并不合适。有效处理大量光源的渲染技术将会在第 20 章详细介绍。并且，为了简单起见，我们只支持一种类型的光源：点光源。虽然这个实现方案是相当简单的，但是它遵循了我们之前提到的最佳实践。

（注：“最佳实践” 应该是指前文中 “然而在实践中，这种混合实现通常不是最佳的。着色模型的线性变化部分往往在计算上花费最少，并且以这种方式拆分着色计算往往会增加相当多的开销，例如重复计算和额外的变化输入，从而导致弊大于利。”）

着色模型并不是单独实现的，而是在更大的渲染框架环境（context）中实现。该案例在一个简单的 WebGL 2 应用程序中实现，修改自 Tarek Sherif **[1623]** 的 “Phong-shaded Cube”WebGL 2 案例，但是其他更复杂的框架也是运用相同的原则。

（注：context 在很多书籍中译为 “上下文”，对于初学者会很费解，个人觉得译为“语境”、“环境” 更好理解）

我们将讨论应用程序调用的 GLSL 着色器代码和 JavaScript WebGL 的一些示例。这里的目的并不是讲述 WebGL API 的细节，而是要展示一般的实现原理。我们将以 “由内到外” 的顺序来讲解实现过程，首先是像素着色器，然后是顶点着色器，最后是应用程序侧的图形 API 调用。

着色器源文件应包含着色器输入与输出的定义，这样的着色器代码才是正确的。正如我们在第 3.3 节谈到的，使用 GLSL 术语，着色器输入会分为两类。其中之一就是统一输入集，它有着应用程序所设置的值，并且在一个绘制调用（draw call）中保持不变。第二种类型由变化的输入组成，它可以在着色器调用（像素或顶点）之间改变。以下是 GLSL 语言中像素着色器的各种输入及其输出的定义：

in vec3 vPos ;

in vec3 vNormal ;

out vec4 outColor ;

（注：最后一句直译太冗长拗口了，直接意译，原文 Here we see the defifinitions of the pixel shader’s varying inputs, which in GLSL are marked in, as well as its outputs: ）

像素着色器有单独的输出，其内容为最终的着色颜色。像素着色器的输入与顶点着色器的输出相匹配，顶点着色器的输出在被输入到像素着色器之前会在整个三角面进行插值。像素着色器有两个不同的输入：表面位置与表面法线，且这两者都是在应用程序的世界空间坐标系内。当然，统一输入的数据数量还有很多，为了简洁，我们仅展示这两个的定义，且这两者都是与光源相关的：

struct Light {

 vec4 position ;

 vec4 color ;

};

uniform LightUBlock {

 Light uLights [MAXLIGHTS];

};

uniform uint uLightCount ;

由于这些是点光源，因此每个光源的定义都包含位置和颜色。为了符合 GLSL std140 数据布局标准的限制，我们将它们定义为 vec4 而不是 vec3。尽管在这种情况下， std140 布局可能导致一些空间的浪费，但是它简化了确保 CPU 与 GPU 之间的数据布局一致的任务，这也就是我们为什么在该例子中使用它的原因。Light 结构体的数组是在一个已命名的统一代码块内定义的，该代码块是 GLSL 的功能，用于将一组统一变量绑定到缓冲区对象，以加快数据传输速度。数组长度被定义为与应用程序允许的在单个绘制调用中光源的最大数量。稍后我们将看到，应用程序在编译着色器之前将着色器源文件中的 MAXLIGHTS 字符串替换为正确的值（本例中为 10）。统一的整数 uLightCount 是在绘制调用中的实际的活动光源数。

接下来，我们来看一下像素着色器的代码：

vec3 lit( vec3 l, vec3 n, vec3 v) {

 vec3 r_l = reflect (-l, n) ;

 float s = clamp (100.0 * dot (r_l , v) - 97.0 , 0.0 , 1.0) ;

 vec3 highlightColor = vec3 (2 ,2 ,2) ;

 return mix (uWarmColor , highlightColor , s) ;

}

void main () {

 vec3 n = normalize (vNormal) ;

 vec3 v = normalize (uEyePosition .xyz - vPos) ;

 outColor = vec4 (uFUnlit , 1.0) ;

for ( uint i = 0u; i <uLightCount ; i ++) {

 vec3 l = normalize (uLights [i]. position . xyz - vPos ) ;

 float NdL = clamp ( dot (n, l) , 0.0 , 1.0) ;

 outColor . rgb += NdL * uLights [i]. color . rgb * lit(l,n,v) ;

 }

}

我们有一个 lit 项的函数定义，它被 main() 函数调用。总的来说，这是公式 5.20 与 公式 5.21 的 GLSL 简单实现。

需要注意， $f_{\textrm{unlit}}()$ 和 

![[e6b4f7e0688a88b89bb06fd768319060_MD5.gif]]

 是作为统一的变量被传入。由于这些值在整个绘制调用中是恒定不变的（constant），因此应用程序可以计算这些值，从而节省一些 GPU 的周期。

该像素着色器使用了一些的内置的 GLSL 函数。reflect() 函数在第二个向量（此例中为表面法线）定义的平面上反射一个向量（此例中为光向量）。由于我们想要光向量和反射向量都指向远离表面的位置，因此我们需要在将前者传递给 reflect() 之前对其取反。clamp() 函数有三个输入值。其中的两个输入值定义了第三个输入值被 clamped 的范围。一个特别的 clamping 例子是范围在 0 和 1 之间 （对应了 HLSL 的 saturate() 函数），这个运算是很快的，在大部分 GPU 上是没有什么消耗的。这也是我们在这里使用它的原因，虽然我们只需要 clamp 值到 0，因为我们知道它不会超过 1。mix() 函数也有三个输入值，基于第三个值（一个在 0 与 1 之间的混合参数）在其中两个值之间进行线性插值，在此例中，指的是暖色与高光色。在 HLSL 中这个函数称为 lerp()，意思是 “线性插值”（linear interpolation）。最后是 normalize() 函数，它会将向量除以其长度，将其缩放为 1。

现在让我们看一下顶点着色器。我们不会展示任何它的统一定义，因为我们已经在像素着色器里看过一些统一定义的例子了，但是不同的输入和输出的定义还是值得查看一下的：

layout (location =0) in vec4 position ;

layout (location =1) in vec4 normal ;

out vec3 vPos ;

out vec3 vNormal ;

需要注意的是，正如之前提到的，顶点着色器的输出对应像素着色器的不同输入。输入中包含指令，这些指令决定了怎样在顶点

数组中布置数据。顶点着色器的代码如下：

void main () {

 vec4 worldPosition = uModel * position ;

 vPos = worldPosition . xyz;

 vNormal = (uModel * normal) .xyz;

 gl_Position = viewProj * worldPosition ;

}

这些是顶点着色器的普遍操作。着色器变换表面位置与法线到世界空间，并且将它们传入像素着色器以便在着色过程中使用。最终，表面位置被变换到裁剪空间并且传入 gl_Position，一个被光栅器使用的特殊系统定义变量。gl Position 变量是任何顶点着色器的必需的输出。

需要注意的是，法线向量在顶点着色器中并没有归一化。他们不需要被归一化是因为他们在原始网格模型中的长度为 1，并且应用程序没有执行任何可能会非均匀地改变他们的长度的操作，例如顶点混合或非均匀缩放。模型矩阵可以有一个统一的缩放因子，但是那会按比例地改变所有法线的长度，因此不会导致出现图 5.10 右侧中的问题。

应用程序为了多种不同的渲染和着色器设置而使用 WebGL API。每个可编程的着色器阶段都被单独地设置，并且他们都被绑定到程序对象上。以下是像素着色器的设置代码：

var fSource = document . getElementById ( "fragment" ) . text . trim () ;

var maxLights = 10;

fSource = fSource . replace (/ MAXLIGHTS /g, maxLights . toString () ) ;

var fragmentShader = gl. createShader (gl. FRAGMENT_SHADER) ;

gl. shaderSource (fragmentShader , fSource) ;

gl. compileShader (fragmentShader) ;

请注意提到的 “片元着色器”，是 WebGL（以及它所基于的 OpenGL）中使用的术语。正如我们之前在此书中提到的，虽然“像素着色器” 在某些方面描述不够精确，但它是更普遍的称呼方式，所以我们将继续在本书中使用 “像素着色器” 这个称呼。此代码也是将 MAXLIGHTS 字符串替换成合适的数值的地方。大部分渲染框架执行类似的预编译着色器操作。

还有更多的应用程序代码用于设置统一，初始化顶点数组，清除，绘制等，你可以在程序 ****[1623]**** 中查看这些代码，并且许多 API 指南对此进行了说明。在此我们的目标是通过它们自身的编程环境，了解着色器是怎样被当作单独的处理器。因此，我们在此结束本小节。

### **5.3.3 材质系统 Material Systems**

正如我们的简单案例里，渲染框架很少只实现单个着色器。通常来说，需要一个专用的系统来处理大量的材质，着色模型，以及应用程序所使用的着色器。

正如之前章节里面所揭示的，一个着色器是用于 GPU 的可编程着色阶段之一的一个程序。因此，着色器是低级的图形 API 资源，并且不是美术人员会直接接触的。相反，材质是面向美术人员封装的表面的视觉表现。材质有时也描述非视觉部分，比如碰撞属性，我们不会继续深入此话题，因为它已经超出了该书的范围。

虽然材质通过着色器被实现，但这不是一个简单的一对一对应。在不同的渲染情况下，相同的材质可能使用不同的着色器。一个着色器也可能被多种材质共用。最普遍的情况是材质参数化。在它的最简单形式中，材质参数化需要两种类型的材质实体： 材质模板（material templates）与材质实例（material instances）。每个材质模板描述一类材质并且有一个参数的集合，它可以根据参数类型的不同去分配不同的值，有数值，颜色，或者贴图。每个材质实例对应着一个材质模板与所有参数的一组特定值。一些渲染框架例如虚幻引擎 **[1802]** 允许更复杂的、分层的结构，其中材质模板派生自多层次的其他模板。

参数可以在运行时被解析，通过统一的输入传递到其他着色器程序，或者也可以在编译时，通过在着色器编译前替换值来解析参数。一个常见的编译时参数类型是布尔开关，它用来控制激活给定材质的特征。这可以由美术人员通过材质 UI 的勾选框去设置，或者由材质系统在程序上去设置，例如远处的物体，它们的视觉效果特征可以忽略不计，此情况设置关闭可以减少着色器消耗。

尽管材质参数可以与着色模型参数一对一匹配，但我们不是总会遇到这种情况。一个材质可能会修改一个给定着色模型参数的值，例如表面颜色，可修改为一个常量。或者，可以将多个材质参数以及插值的顶点或纹理值作为输入，通过一系列复杂的操作来计算着色模型参数。在地形材质中，基于表面位置与方向的着色是尤为普遍的。举个例子，高度与表面法线可以被用来控制积雪特效，做法是在高处的水平面和接近水平面的表面以白色表面颜色做混合。基于时间的着色通常用于动画材质，例如闪烁的霓虹灯标志。

材质系统的最重要任务之一是将多种着色器函数划分为单独的元素，并控制这些元素的组合方式。在许多情况下，这种组合是很有用的，包括以下几种情况：

*   将表面着色与几何处理组合在一起，例如刚体变换，顶点混合，变形，曲面细分，实例化，以及裁剪。这些功能都是各不相同的：表面着色器依赖于材质，几何处理依赖于模型网格。所以，分开编写他们以及让材质系统根据需求组合他们是很方便的。
*   将表面着色与一些组合操作例如像素丢弃（discard）与混合（blending）组合在一起。这与移动端 GPU 是尤为相关的，在移动端 GPU 的像素着色器里，混合是一种普遍执行的操作。通常我们希望独立于表面着色用材质来选择这些操作。
*   将用来计算着色模型参数的操作与着色模型自身的计算组合在一起。这种方式允许编写一次着色模型的实现，并且与多种不同计算着色模型参数的方式组合在一起去重用它。
*   将独立可选的材质特征相互组合，以及与选择逻辑、剩余的着色器组合在一起。这种方式允许分开编写每个特征的实现。
*   将着色模型、其参数的计算与光源计算组合在一起：在每个光源的着色点计算 
    
    ![[c9926321cad55e5694f0fdea3e0a12b2_MD5.gif]]
    
     与 
    ![[47457a6025b4748b2697dce722160061_MD5.gif]]
    
     的值。例如延迟渲染的技术（在第 20 章讨论）改变了这个组合的结构体。在支持该技术的渲染框架里，这种方式将额外增加复杂度。

如果图形 API 提供这种类型的着色器代码模块作为核心功能，将会很方便。然而悲伤的是，不像 CPU 代码，GPU 着色器不允许对代码片段进行后编译链接。每个着色器阶段的程序都作为一个单元被编译。着色器阶段之间的分离确实提供了一些受限制的模块，这些模块某种程度上与我们列表上的第一项相匹配：将表面着色（通常在像素着色器上执行）与几何处理（通常在其他着色阶段执行）组合在一起。但是这个匹配并不完美，因为每个着色器也会执行其他操作，并且其他类型的组合仍然需要被处理。有了这些限制，材质系统能实现所有类型组合方式的唯一办法在于源代码层级。这个主要包括例如并列和替换的字符串操作，通常通过 C 风格的预处理指令例如 #include，#if 和 #define 去执行。

早期的渲染系统有着相对较小数量的着色器变体，并且通常是手动去编写每个变体。这也有一些好处的。例如，可以在充分了解最终的着色器程序的基础上去优化每个变体。然而，这种手动编写的方法随着着色器变体数量的增加而变得不切实际。当我们将所有不同部分和选项都纳入考虑时，所有可能的不同着色器变体数量是巨大的。这就是为什么模块化和可组合性是如此的关键。

当设计一个系统用来处理着色器变体时，第一个需要解决的问题是，不同选项间的选择是否是通过动态分支（dynamic branching）在运行时执行，或者是在编译时通过条件预处理（conditional preprocessing）执行。在较老的硬件上，动态分支通常是不可能的或者是速度极慢的，所以运行时的选择是不可行的。随后所有变体都在编译阶段被处理，包括不同光源类型计数的所有可能组合 **[1193]**。

相反，如今的 GPU 能够很好地处理动态分支，尤其是当分支行为对于一个绘制调用中所有像素都是相同的情况下。现在许多功能性变体，例如光源的数量，都在运行时被处理。然而，为一个着色器添加大量的功能变体将产生一个不同的消耗：寄存器计数（register count）的增加和占用率的相应降低，进而导致性能下降。详情可见第 18.4.5 节。所以编译时变体仍然是有价值的，它能避免包含那些从不执行的复杂逻辑。

举个例子，让我们想象一个支持三种不同类型光源的应用程序。其中两种光源类型很简单：点光源与方向光。第三种类型是通用的聚光灯，它支持列表照明模式以及其他复杂的功能，这需要大量的着色器代码去实现。然而，这个通用的聚光灯使用率相对较小，此应用程序中只有不到 5% 的光源是这种类型。在过去，一个单独的着色器变体会为每个可能的三类光源计数的组合去编译，以避免动态分支。尽管在如今这种方式已不再需要，但是编译两个单独的变体仍然是有好处的，一个变体适用于通用聚光灯数量大于等于一时，另一个变体适用于此类聚光灯数量正好为 0 时。由于它更简单的代码，第二个变体（更常使用）可能有着更低的寄存器占用率，并且因此有着更高的性能表现。

现代材质系统同时使用了运行时着色器变体和编译时着色器变体。即使完整的负载已经不会仅在编译时处理，但总体的复杂度与变体的数量仍然保持增长，所以还是需要编译大量的着色器变体。举个例子，在游戏《命运：被夺走的国王》（Destiny: The Taken King）中，在单帧内使用了超过 9000 个编译的着色器变体 **[1750]**。可能的变体数量还可以变得更为巨大，例如， Unity 渲染系统有着接近 1000 亿可能的变体。只有确确实实被使用的变体才会被编译，但是着色器编译系统必须被重新设计以处理大量可能的变体 **[1439]**。

材质系统设计者使用不同的策略去解决这些设计目标。虽然这些策略有时候表现为互斥的系统体系结构 **[342]，**但这些战略能够被——以及通常是——合并到相同的系统中。这些策略包含以下内容：

*   代码重用——在共享的文件中实现函数，使用 #include 预处理指令去访问那些来自任意着色器的所需函数。
*   减法——一个着色器，通常被称为超级着色器（ubershader 或 supershader）**[1170,1784]**，聚集了一大批功能，使用编译时预处理器与动态分支的组合去移除无用的部分并且在互斥的备选方案之间切换。
*   加法——各种功能被定义为具有输入输出连接器的节点，并且这些都会组成到一起。这与代码重用策略相似，但是更结构化。节点的组合可以通过文本 **[342]** 或一个可视图形编辑器来完成。后者旨在使非工程师（例如技术美术）更容易编写新的材质模板 **[1750，1802]**。通常来说，可视图形编写只能访问到着色器的一部分。举个例子，在虚幻引擎的可视图形编辑器中只能作用到着色模型输入相关的计算。见图 5.13。
*   基于模板——定义了一个接口，只要符合该接口，就可以接入不同的实现。这与加法策略相比显得更加正式，并且通常被用于更大的功能块中。该接口的一个普遍案例是着色模型参数计算与着色模型自身计算的分离。虚幻引擎 **[1802]** 有着不同的 “材质域”，包括计算着色模型参数的表面域与计算一个缩放值的光照函数域（该缩放值为给定光源调整 
    
    ![[c9926321cad55e5694f0fdea3e0a12b2_MD5.gif]]
    
     ）。一个与此相似的 “表面着色器” 结构也存在于 Unity 中 **[1437]**。注意，延迟着色技术（将在第 20 章讨论）强制采用了一个类似的结构，其 G 缓冲区用作接口。

![[32d0b36e797588aab1df044edeefa083_MD5.png]]

_图 5.13 虚幻引擎材质编辑器。注意在节点图右侧的高节点。这个节点的输入连接器对应着渲染引擎的多种着色输入，包括所有的着色模型参数。（材质示例由 Epic Games 提供）_

更具体的案例，书籍《WebGL Insights》（现在免费）中的一些章节讨论了各种引擎是怎样控制他们的渲染管线。除了组合外，现代材质系统还有一些其他重要的设计注意事项，例如以最少的着色器代码重复去支持多平台的需求。这包括功能的变体，以解决平台，着色语言和 API 之间的性能和功能差异。游戏《命运》的着色器系统（The Destiny shader system） **[1750]** 是对这种问题的最具代表性的解决方案。它采用了一个专有的预处理器层从而使着色器能够由一个自定义的着色器语言书写。这允许我们编写与平台无关的材质，然后能够自动翻译成不同的着色语言与具体实现。虚幻引擎 **[1802]** 与 Unity **[1436]** 有着相似的系统。

材质系统也需要确保具有好的性能表现。除了着色变体的专门编译外，材质系统还能执行一些少数其他普遍的优化。《命运》着色器系统以及虚幻引擎会自动检测那些在一次绘制调用中保持恒定的计算（例如在之前实现案例中提到的暖色与冷色计算），并且将它们移到着色器之外。另一个例子是在《命运》中使用的作用域系统（scoping system），为了减少 API 开销，它用来区分以不同频率更新的常数（例如每帧一次，每个光源一次，每个物体一次）的操作和在合适的时间更新每个常数设置的操作。

正如我们所见过的，实现一个着色方程是一个选择哪个部分该简化，以怎样的频率去计算各种表达式，并且用户应该怎样修改与控制外观的问题。渲染管线的最终输出是颜色和混合值。剩余的反走样，半透明，与图像显示的部分详细介绍了这些值将怎样合并与修改以进行显示。

## 5.4 走样与反走样 Aliasing and Antialiasingtexture mapping

想象一个巨大的黑色三角形缓缓地穿过一个白色背景。因为屏幕网格单元（screen grid cell）被三角形覆盖，代表这个网格单元的像素值应该在强度上平稳下降。然而通常发生在所有类型的基础渲染中的情况是，当网格单元的中心被覆盖的那一刻，像素颜色立即从白色变为黑色。标准 GPU 的渲染也不例外。见图 5.14 的最左列。

![[29c7b42ec53acd248554758dedf5a5b9_MD5.png]]

_图 5.14 上排图像展示了三个不同反走样级别的三角形、线、点。下排图像是上排图像的放大。最左列每个像素仅用一个采样，这意味着没有使用反走样技术。中间列的图像以每像素四个采样（以网格模式）的方式渲染，最右列则是使用每像素八个采样（在 4×4 的棋盘格中，一半的正方形被采样）。_

三角形在像素里的显示是要么存在，要么不存在。线的绘制也有类似的问题。因此，边缘有着锯齿状的外观，这种视觉伪像（visual artifact）被称作 “锯齿”（the jaggies），当物体运动时则被称作 “爬虫”（crawlies）。关于此问题的更正式的称呼为 “走样”（aliasing），并且，旨在避免这个问题的相关技术我们称为 “反走样”（antialiasing）。关于采样理论与数字滤波的话题已经足够另外写一本书了 **[559，1447,1729]**。因为这是渲染的关键领域，我们会在这里阐述采样和滤波的基础理论。接下来我们会专注于当前在实时渲染中我们能做一些什么以减轻走样伪像（aliasing artifacts）。

### 5.4.1 采样与滤波理论 Sampling and Filtering Theory

渲染图像的处理本身便是一个采样任务。之所以这样是因为图像的生成就是三维场景采样的处理过程，其目的是为图像中的每个像素（一个离散的像素数组） 去获取相应的颜色值。为了使用纹理映射（第 6 章），纹素（texels）必须能被重采样以在各种条件下获得好的结果。为了在动画文件中生成图像的序列，动画文件通常以均匀的时间间隔采样。本节将介绍采样，重建，以及滤波的话题。为了简单起见，大部分材质将以一维呈现。这些概念也将自然地推广到二维，并且因此能够在处理二维图像时使用。

（注：纹素（英语：Texel，即 textureelement 或 texture pixel 的合成字）是纹理元素的简称，它是计算机图形纹理空间中的基本单元。如同图像是由像素排列而成，纹理是由纹素排列表示的。）

图 5.15 展示了一个连续的信号是怎样以均匀的间隔被采样的，即离散化（discretized）。采样处理的目标是数字化地去呈现信息。这样做可以减少信息量。然而采样的信号需要被重建（reconstructed）以恢复原始信号。这是通过对采样信号进行滤波来完成的。

![[db6c0593cf1bca7f8c2104803f46e693_MD5.png]]

_图 5.15 一个连续信号（左图）被采样（中图），并且接下来原始信号通过重建以恢复（右图）。_

无论何时进行采样，都可能出现走样。这是我们不想造成的伪像（artifacts），并且我们需要与走样进行战斗以生成令人满意的图像。老的西方人见过的一个关于走样的经典案例，是电影摄像机拍摄的一个旋转的马车车轮。由于车轮辐条移动得比摄像机记录图像的速度快得多，车轮看起来像是在向后或向前缓慢旋转，或者甚至有可能看起来根本没有转动。见图 5.16。之所以会出现这种现象，是因为车轮的图像是以一系列时间步长被记录的，这被称作时间走样（temporal aliasing）。

在计算机图形中走样的普遍案例有光栅化的线与三角形边的 “锯齿”，被称为 “萤火虫”（fireflies）的闪烁的高光，以及缩小具有方格图案的纹理时发生的走样（见 6.2.2 节）。

当一个信号被以过慢的频率采样时，走样就会出现。如图 5.17 所示。为了使一个信号被合适地采样（换句话说，这样就能够从样本中重建原始信号），采样频率必须大于被采样信号最大频率的两倍。这通常被称作采样定理（sampling theorem），并且该采样频率以一位在 1928 年发现此频率的瑞典科学家 哈里 · 奈奎斯特（Harry Nyquist） (1889–1976) 命名，被称为奈奎斯特率（Nyquist rate）**[1447]** 或奈奎斯特极限（Nyquist limit）。奈奎斯特极限如图 5.16 所示。该定理使用术语 “最大频率” 的这一事实暗示着信号应该受到频带限制（band-limited），这仅仅意味着任何频率都不能超过特定限制。换句话说，信号相对于相邻样本间的间隔应该足够平滑。

当一个三维场景以点样本渲染时（注：即像素渲染），正常情况下是不会有频带限制的。三角形的边缘，阴影边界，以及其他现象会产生变化不连续的信号，因此会产生无限的频率 **[252]**。同样，无论样本被打包得多紧密，物体仍然能足够小，以至于他们根本不能被采样。因此，当我们使用点样本渲染场景时，完全避免走样的问题是不可能的，并且我们几乎总是使用点采样。然而，有时候我们可以知道信号在何时有频带限制。其中一个例子是当纹理被应用到表面的时候。此情况下是可以计算与像素采样率相比的纹理采样频率的。如果该频率低于奈奎斯特极限，那么就不用做特殊的操作去对纹理进行合适的采样。如果频率过高的话，那么就会使用各种算法对纹理进行频带限制（第 6.2.2 节）。

### 重建 Reconstruction

给定一个频带限制的采样信号后，我们现在来讨论原始信号是怎样从采样信号去重建的。为了做到这点，我们必须用到一个滤波器。三个普遍使用的滤波器如图 5.18 所示。需要注意的是，滤波器的区域应该总是为单个的，否则重建的信号可能会扩大或收缩。

![[67173f5d056eebce5df159b50ccc704e_MD5.png]]

_图 5.18 左上图为 box 滤波器（box filter），右上图为 tent 滤波器（tent filter）。底部为 sinc 滤波器（在这里已经 clamped 在 x 轴上）_

![[643ebe39ad61db6bb2bb82da9a32f067_MD5.png]]

sinc

_图 5.19 采样后的信号（左侧）使用 box 滤波器进行重建。这是通过以下步骤完成的：首先在每个采样点上放置 box 滤波器，并且在 y 方向上将其缩放，这样滤波器的高度与采样点就是相同的。之后求出的和就是重建后的信号（右侧）。_

在图 5.19 中，box 滤波器（最近的相邻处）被用于重建一个采样信号。这是所使用的最糟糕的滤波器，因为产生的信号是一个非连续的阶梯状。然而由于它很简单，所以仍然经常在计算机图形学中使用。如图所示，box 滤波器被放置在每个采样点上，并且之后会被缩放，这样滤波器最上方的点就可以与样本上的点重合。所有这些缩放与平移后的 box 函数之和就是右侧所示的重建后的信号。

box 滤波器可以替换成任意其他滤波器。在图 5.20 中，tent 滤波器，也被称作三角形滤波器，被用来重建采样后的信号。需要注意的是这个滤波器在相邻采样点之间实现了线性插值，所以它比 box 滤波器要更好，因为重建的信号现在是连续的。

![[c8d49f4bf7e8d17abea97b1f4a58399b_MD5.png]]

_图 5.20 采样后的信号（左侧）使用 tent 滤波器去进行重建。重建后的信号如右侧所示。_

然而，使用 tent 滤波器重建的信号的平滑程度并不好；在采样点有着突然的斜率改变。这与以下事实有关： tent 滤波器并不是一个完美的重建滤波器。为了得到完美的重建，必须使用理想的低通滤波器。其中信号的频率分量是正弦波：$\textrm{sin}(2\pi f)$，$f$ 是该分量的频率。鉴于此，低通滤波器将去除频率高于滤波器定义的某个频率的所有频率分量。直觉上来看，低通滤波器移除了信号的尖锐特征，即滤波器对信号进行了模糊处理。理想的低通滤波器是 sinc 滤波器（见图 5.18 底部）

![[3051dfa737557463f8885e337d5bf6c7_MD5.png]]

_图 5.21 这里 sinc 滤波器被用来重建信号。sinc 滤波器是理想的低通滤波器。_

$\textrm{sinc}(x)=\frac{\textrm{sin}(\pi x)}{\pi x}\;\;\;\;\;\;\;\;\;\;(5.22)$

傅里叶分析 **[1447]** 的理论解释了为什么 sinc 滤波器是理想的低通滤波器。简单来说，理由如下。理想的低通滤波器是频率域的 box 滤波器，当它与信号相乘时，移除了所有高于滤波器宽度的频率。将 box 滤波器从频率域转到空间域会得到 sinc 函数。与此同时，乘法操作被转换为了卷积（convolution）函数，卷积是我们在本节中一直使用的，但没有实际描述过的术语。

正如图 5.21 所示，使用 sinc 滤波器去重建信号能得到更平滑的结果。采样过程在信号中引入了高频部分（突变），并且低频滤波器的任务是移除这些高频部分。事实上， sinc 滤波器用频率高于 1/2 的采样率计算了所有的正弦波。sinc 函数，如公式 5.22 所示，当采样频率是 1.0 时（即采样信号的最大频率必须小于 1/2），它是完美的重建滤波器。更普遍地来说，假设采样频率是 $f_{s}$ ，也就是说，相邻样本间隔为 $1/f_{s}$。对这种情况来说，完美的重建滤波器是 $\textrm{sinc}(f_{s}x)$ ，并且它计算了所有高于 $f_{s}/2$ 的频率。这在下一节的重采样信号中是很有用的。然而 sinc 的滤波器宽度是无限的，并且在某些区域是负值，所以它在实践中很少有用。

在低品质的 box 与 tent 滤波器之间存在有用的中间区域，另外，不实用的 sinc 滤波器也存在中间区域。大部分广泛使用的滤波器函数 **[1214,1289,1413,1793]** 处于这些极端情况之间。所有这些滤波器函数都有一些对 sinc 函数的近似，但是对于它们影响的像素数量有所限制。最接近 sinc 函数的滤波器在它们的部分域上有负值。对于应用程序而言，负滤波器值是不可取或不实用的，我们通常使用有着非负瓣的滤波器 **[1402]**（通常被称作高斯滤波器，因为他们源于或类似于高斯曲线）。第 12.1 节更详细地讨论了滤波器函数以及它们的使用。

在使用任意滤波器之后，便得到了一个连续的信号。然而，在计算机图形学中我们不能直接显示一个连续的信号，但是我们可以使用它们去对连续信号进行重采样并得到另一个大小，即放大或缩小信号。这个话题将在接下来讨论。

### **重采样 Resampling**

重采样被用来放大后者缩小一个采样信号。将设原采样点位于整数坐标系内（0,1,2,...），即样本间的间隔是单位整数。更进一步的，假设在重采样后，我们想要新的采样点以样本的间隔 a 均匀地放置。对于 a > 1，使用缩小（下采样），对于 a < 1，使用放大（上采样）。

放大是两种情况中较为简单的一个，所以我们从放大开始讲解。假设采样信号如上一节所示那样被重建。直观上看，因为信号现在已经被完美重建并且是连续的，所需要的便是以我们期望的间隔去重采样重建后的信号。这个过程在图 5.22 中有描述。

然而，当缩小时，这个技术不起作用。原始信号的频率对采样率来说过高，以至于无法避免走样。取而代之的是，已经证明了使用 $\textrm{sinc}(x/a)$ 的滤波器应该被用来从采样信号中创建连续信号 **[1447,1661]**。之后便可以期望的间隔进行重采样。如图 5.23 所示。换句话说，通过在此使用 $\textrm{sinc}(x/a)$ 作为滤波器，低通滤波器的宽度增加了，以至于更多的信号高频率内容被移除了。正如图中所示，（独立 sinc 函数的）滤波器宽度被翻倍以减少重采样率，并使原采样率减半。将此与数字图像联系起来，这与一开始进行模糊操作（为了移除高频率部分）是相似的，然后以低分辨率对图像进行重采样。

![[c2770a05e902b952d8373cd8f63df6f5_MD5.png]]

_图 5.22 在左侧，是采样信号与重建新号。在右侧，重建新号已经以两倍的采样频率进行重采样，即进行了放大。_

![[8fefa52d6136e6d151898a5e45cf81c6_MD5.png]]

_图 5.23 在左侧是采样信号与重建信号，在右侧，滤波器宽度已经放大为原来的两倍以使样本间隔也变为原来的两倍，即进行了缩小。_

以采样和过滤理论为框架，我们现在开始讨论在实时渲染中用于减少走样的各种算法。

### 5.4.2 基于屏幕空间的反走样 Screen-Based Antialiasing

如果采样与滤波的效果不好，三角形的边缘会产生明显的伪像（artifacts）。阴影边缘，高光，以及颜色迅速变化的其他现象都可能导致类似的问题。在本小节中讨论的算法会帮助前述的这些案例提升渲染品质。它们的共同点是，它们都是基于屏幕空间的，即他们只在管线输出的采样样本上进行操作。并没有最佳的反采样技术，因为对画面品质而言，这些技术都有各自的有点，例如捕捉清晰的细节或者其他现象的能力，运动时的表现，内存消耗，GPU 要求，以及速度等等。

![[80021c0c388791c1ad3978c17640abe2_MD5.png]]

_图 5.24。在左侧，以像素中心的一个样本去渲染一个红色三角形。因为三角形并没有覆盖样本，像素是白色，即使像素的大部分已经被红色三角形覆盖。在右侧，对每个像素使用了四个采样点，正如我们所见，其中两个采样点被红色三角形所覆盖，因此像素为粉红色。_

在如图 5.14 所示的黑色三角形案例中，其中一个问题就是低采样率。在每个像素的网格单元中心进行单个采样，因此关于该网格单元最通常被了解的是，它是否被三角形所覆盖。通过在每个屏幕网格单元使用更多的采样并以一些方式将它们混合，就能计算出更好的像素颜色。如图 5.24 中所示。

基于屏幕的反走样方案的一般策略是使用一个针对屏幕的采样模式，并且对这些样本进行加权与求和，以得出像素的颜色，$\textbf{p}$：

$\textbf{p}(x,y)=\sum ^{n}_{i=1}w_{i}\textbf{c}(i,x,y),\;\;\;\;\;\;\;\;\;\;(5.23)$

其中 $n$ 是用于单个像素的采样数。函数 $\textbf{c}(i,x,y)$ 是一个采样颜色，$w_{i}$ 是权重，范围是 [0,1]，样本对整个的像素颜色有所贡献。样品的位置根据其在序列中的顺序来确定，如 1，……，n，并且可选的函数也是使用像素位置 $(x,y)$ 的整数部分。换句话说，每个样本在屏幕网格的采样位置都是不同的，并且可选的采样模式可以对每个像素都不同。在实时渲染系统（以及大多数其他渲染系统）中，样本通常是点样本。所以，函数 $\textbf{c}$ 可以被认为是两个函数。首先，函数 $\textbf{f}(i,n)$ 检索屏幕上需要样本的浮点 $(x_{f},y_{f})$ 。然后对屏幕上的该位置进行采样，即检索该精确点处的颜色。选择采样方案，并且配置渲染管线以计算特定子像素位置的采样，这通常基于逐帧（或逐应用）设置。

在反走样中的另一个变量是 $w_{i}$，每个样本的权重。这些权重的和为 1。大部分用于实时渲染系统的方法都对它们的样本给出了统一权重，即 $w_{i}=\frac{1}{n}$。图形硬件的默认模式，像素中心的单个采样，是上述反走样方程的最简单情况。只有一个项，该项的权重为 1，并且采样函数 $\textbf{f}$ 总是返回被采样像素的中心。

反走样算法计算每个像素时，如果使用超过一个完整的采样，就被称作超级采样（或过采样）方法。概念上最简单地说，全场景反走样（full-scene antialiasing, FSAA），又名 “超级采样反走样”（supersampling antialiasing, SSAA），以更高的分辨率渲染场景，然后对相邻的样本进行滤波以得到图像。举个例子，假设我们需要一张 1280 x 1024 像素的图像。如果你在屏幕外渲染一个 2560 x 2048 像素的图像，然后对每 2 x 2 的像素区域取平均值，之后在屏幕上显示，我们需要的图像就会以每像素四个采样，并使用 box 滤波器去进行滤波。需要注意的是，这相当于图 5.25 中的 2 x 2 网格采样。此方法较为消耗性能，因为所有的子采样必须被完整地着色与填充，其中每个样本都具有 z 缓冲区的深度信息。FSAA 的主要优点在于简单。这种方法的其他低质量版本只在一个屏幕轴向上以两倍的速率采样，因此被称为 1 x 2 或 2 x 1 超级采样。通常来说，为了简化起见，使用二次幂分辨率和 box 滤波器。英伟达（NVIDIA）的动态超分辨率（dynamic super resolution）功能是一个更加复杂的超级采样形式，其中以更高的分辨率渲染场景，并且使用 13 个采样的高斯滤波器去生成显示图像 **[1848]**。

![[81dfca975f93f6baeef9b31b7c09ef8c_MD5.png]]

_图 5.25。一些像素采样方案的对比，按照逐像素采样数从少到多排列。Quincunx 共享角落的样本以及中心样本进行加权，以使其值达到像素最终颜色的一半。2 × 2 旋转网格比 2 × 2 直形网格在几乎水平的边缘上会捕获更多的灰度级。类似地，尽管使用的样本较少，但 8 rooks 图案捕获的此类线条比 4 × 4 网格捕获的灰度级别更多。_

一个与超级采样相关的采样方法是基于累积缓冲区（accumulation buffer）的 **[637,1115]**。该方法不使用一个大的屏幕外缓冲区，而是使用一个与最终期望图像具有相同分辨率的缓冲区，但是每个颜色通道使用更多的字节位。为了得到一个场景的 2 x 2 采样，生成四幅图像，视图根据需要在屏幕 x 轴或 y 轴上移动半个像素。每个生成的图像都是基于网格单元内的不同采样位置。每帧必须重新渲染场景几次，并将结果复制到屏幕上，这种额外费用使该算法在实时渲染系统中成本很高。当性能问题不关键时，这种方法对生成高质量的图像来说是很有用的，因为每个像素可以使用任何数量的样本，并且可以放置在任何地方 **[1679]**。累积缓冲区曾经是硬件中单独的一部分。它直接被 OpenGL API 所支持 ，但是在 3.0 版本中被弃用。在现代 GPU 中，累积缓冲区这个概念可以通过在输出缓冲区使用高精度的颜色格式，从而在像素着色器中实现。

当物体边缘、镜面高光和锐利阴影等现象引起突变的颜色变化时，需要额外的采样样本。阴影通常能够变得更软，以及高光可以变得更平滑以避免走样。可以增加特定对象的大小，例如电线，以确保它们在长度上每个位置覆盖至少一个像素 **[1384]**。物体边缘的走样仍然是一个主要的采样问题。在渲染时物体边缘被检测以及它们的影响被考虑在内时，可以使用分析方法，但是这些方法通常更为昂贵，并且相比简单地进行更多的采样，它的鲁棒性要更低。然而，GPU 的功能例如保守光栅化和光栅化顺序视图开启了新的可能性 **[327]**。

例如超级采样与累积缓冲区等技术，它们通过生成完全由单独计算的阴影和深度指定的样本来工作。由于每个样本都必须通过像素着色器，因此总体增益相对较低，性能消耗也较高。

多重采样反走样（Multisampling antialiasing，MSAA）通过一次的逐像素计算表面着色，并在样本间共享计算结果，从而降低了高额的计算成本。像素可能有，我们说，每个片元有四个 $(x,y)$ 样本位置，每个都有它们自己的颜色与 z 深度值，但是对于像素的每个物体的片元，像素着色器只计算一次。如果所有的 MSAA 位置样本都被片元覆盖，那么着色样本就会在像素的中心被计算。相反，如果片元覆盖较少的位置样本，则着色样本的位置可以移动，以更好地表示所覆盖的位置。举个例子，这么做可以避免纹理边缘之外的着色采样。这种位置调整方法被称作质心采样（centroid sampling）或质心插值（centroidinterpolation），并且如果开启该功能的话，该过程会由 GPU 自动完成。质心采样可以避免出现三角形外的问题（off-triangle problems），但会导致导数计算返回不正确的值 ****[530，1041]****。参见图 5.26。

![[0f57648f42d48377e0c5adc130c49e54_MD5.png]]

_图 5.26。在中间，一个像素中的两个物体重叠。红色物体覆盖了三个样本，蓝色物体只有一个。像素着色器计算位置以绿色显示。因为红色三角形覆盖了像素的中心，这个位置被用作着色器计算。用于蓝色物体的像素着色器在对应的样本位置进行计算。对于 MSAA 来说，分离的颜色与深度值被储存在所有四个位置中。在右侧展示了 EQAA 的 2f4x 模式。四个样本现在有四个 ID 值，这些 ID 索引了一张存储起来的表，表内有两种颜色和深度的信息。_

MSAA 比纯粹的超级采样方案快是因为片元只进行一次着色。它致力于以高频率对片元的像素覆盖区域进行采样，以及共享计算出的着色数据。通过进一步分离采样和覆盖范围，可以节省更多的内存，这反过来又可以使反走样的速度更快——使用的内存越少，渲染速度就越快。英伟达（NVIDIA）在 2006 年推出了覆盖采样反走样（coverage sampling antialiasing，CSAA），并且 AMD 随后推出了增强质量反走样（enhanced quality antialiasing，EQAA）。这些技术通过以更高的采样率并且仅储存片元的覆盖范围来实现。举个例子，EQAA 的 “2f4x” 模式存储了两个颜色与深度值，在四个样本位置之间共享。颜色与深度值信息不再储存在特定的位置里，而是储存在一张表中。四个样本每个只需要一位（bit）空间用来指定两个存储值中的哪个与其位置相关联。见图 5.26。覆盖样本明确规定了每个片元对最终像素颜色的贡献。如果储存的颜色数量超出了，一个储存的颜色就会被移除并且对应的样本会被标记为未知。这些样本对最终颜色不产生贡献 **[382,383]**。对大多数场景来说，相对较少的像素会包含三个或更多的在着色上完全不同的可见不透明片元，所以这个方案在实践中表现良好 **[1405]**。然而对于最高品质来说，虽然 EQAA 有更好的性能优势 **[1002]**，但是游戏极限竞速：地平线 2 （Forza horizon 2） 运行时会使用 4 倍 MSAA。

一旦所有的几何体被渲染到一个多重采样缓冲区时，会执行一个解析（resolve）操作。这段程序会将样本颜色总体进行平均以决定像素的颜色。值得注意的是，当使用具有高动态范围颜色值的多重采样时，可能会出现一个问题。在这种情况下，为了避免伪像（artifacts），在进行解析操作前，你通常需要对值进行色调映射 **[1375]**。这个开销可能很昂贵，所以可以使用更简单的色调映射函数的近似函数或者其他方法 **[862,1405]**。

默认的情况下，MSAA 通过 box 滤波器进行解析。在 2007，ATI 推出了自定义滤波器反走样（CFAA）[1625]，它能够使用更狭窄或更宽的 tent 滤波器并且稍微拓展到其他像素格。之后支持了 EQAA，从而取代了这个模式。在现代 GPU 上，像素或者计算着色器能够访问 MSAA 的样本并且使用任何我们所期望的重建滤波器，包括从周围像素中采样的样本。虽然一个更宽的滤波器会丢失锐利的细节，但它能够减少走样。佩蒂诺（Pettineo）**[1402,1405]** 发现立方体的 smoothstep 以及有着 2 或 3 像素宽度的 B 样条滤波器在总体上得出了最好的结果。当然还有性能消耗，因为即使使用自定义着色器模拟默认的 box 滤波器解析也会花费很长的时间，而一个更宽的滤波器核心意味着增加了样本的访问成本。

英伟达（NVIDIA）的内置支持的 TXAA ，类似地，在比单个像素更大的区域上使用了更好的重建滤波器，以提供更好的结果。它和更新的 MFAA（多帧反走样，multiframe antialiasing）方案都使用了 TAA（时间性反走样，temporal antialiasing），这是一类通用技术，它可以使用之前帧的结果用来改进图像。由于程序员能够逐帧设置 MSAA 采样模式的功能 **[1406]**，这种技术在某种程度上成为了可能。这种技术可以解决例如旋转的马车车轮等反走样问题，并且能够改进边缘渲染质量。

想象通过生成一系列图像来 “手动” 执行采样模式，其中每次渲染使用不同的位置进行采样。这种偏移是通过在投影矩阵上附加一个微小的平移来完成的 **[1938]**。生成和取平均的图像越多，结果就越好。这种使用多个偏移图像的概念被用于时间性反走样算法。可能使用 MSAA 或其他方法生成单个图像，然后将之前的图像做混合。通常只有 2 ~ 4 帧被使用 **[382,836,1405]**。较旧的图像被赋予的权重可能呈指数减小 **[862]**，尽管如果观看者和场景不移动，这可能会导致帧闪烁，因此通常只对前一帧和当前帧赋予相同的权重。由于每帧的样本位于不同的子像素位置，因此这些样本的权重总和估计的边缘覆盖率比单帧更好。因此，使用前两帧平均的系统可以提供更好的结果。每帧都不需要额外得样本，这就是此方法如此吸引人的原因。我们甚至可以使用时间性采样来生成较低分辨率的图像，该图像将放大到显示器的分辨率的大小 **[1110]**。此外，需要很多样本才能获得良好结果的照明方法，或者其他的技术，这两者可以用每帧使用更少样本的方法来代替，因为其结果将在多帧中混合 **[1938]**。

在不增加额外采样成本的情况下为静态场景提供反走样功能时，这种类型的算法在用于时间性反走样功能时会遇到一些问题。如果没有对帧进行均等的加权，则静态场景中的对象可能会出现微光（shimmer）。快速移动的物体或快速的摄像机移动会导致鬼影（ghosting），即由于先前帧的影响而在物体后方留下痕迹。鬼影的一种解决方案是仅对缓慢移动的对象执行这种反走样处理 **[1110]**。另一个重要的方法是使用重投影（reprojection）（第 12.2 节）来更好地关联先前和当前帧的对象。在这种方案中，对象生成运动向量，这些运动向量存储在单独的 “速度缓冲区”（velocity buffer）中（第 12.5 节）。这些向量用于将前一帧与当前帧相关联，即从当前像素位置减去该向量，以找到该对象表面位置前一帧的彩色像素。在当前帧中不太可能成为表面一部分的样本将被丢弃 **[1912]**。由于时间性反走样不需要额外的样本，因此也就不需要多少额外的工作，因此近年来人们对这种算法产生了浓厚的兴趣，并且该算法也得到了广泛的应用。对于该算法，有些人的关注是因为延迟着色技术（第 20.1 节）与 MSAA 和其他多采样支持不兼容 **[1486]**。时间性反走样的实现方法各不相同，并且根据应用程序的内容和目标，已经开发了避免伪像（artifacts）和提高质量的一系列技术 **[836，1154，1405，1533，1938]**。以 Wihlidal 的演讲 **[1885]** 为例，它展示了如何将 EQAA，时间性反走样和应用于棋盘采样模式的各种过滤技术结合起来，以保持画面质量，同时减少像素着色器的调用次数。Iglesias-Guitian 等。**[796]** 总结了以前的工作，并提出了他们的方案，以使用像素的历史信息并预测，从而使滤波伪像（filtering artifacts）最小化。Patney 等人 **[1357]** 扩展了 Karis 和 Lottes 在 虚幻 4 引擎的实现中 **[862]** 用于虚拟现实应用程序的 TAA 工作，增加了可变大小的采样以及对眼睛运动的补偿（第 21.3.2 节）。

### **采样模式 Sampling Patterns**

有效的采样模式是减少走样、时间以及其他方面的关键要素。Naiman **[1257]** 表明，在水平和垂直边缘附近的走样对人类视觉的影响最大。斜度接近 45 度的边缘是第二个最令人困扰的地方。旋转栅格超级采样（Rotated grid supersampling，RGSS）使用旋转正方形图案来在像素内提供更多垂直和水平分辨率。图 5.25 显示了此模式的一个示例。

RGSS 模式是一种拉丁超立方体（Latin hypercube）或 N-rooks 采样的形式，其中 n 个采样放置在 n × n 的网格中，每行和每列一个采样 **[1626]**。使用 RGSS 时，这四个样本分别位于 4 × 4 的子像素网格中的单独行和列中。与常规 2 × 2 的采样模式相比，此类模式特别适合捕获几乎水平和垂直的边缘，在常规采样模式下，此类边缘可能覆盖偶数个样本，因此有效程度较低。

N-rooks 是创建良好采样模式的开始，但这还不够。例如这些样本可能都沿着子像素网格的对角线放置，因此对于几乎平行于该对角线的边缘，会得出较差的结果。见图 5.27。

![[a876fe3d5f48dd5eb2bb7d0ed0948715_MD5.png]]

_图 5.27。N-rooks 采样。左侧是一个符合规则的 N-rooks 图案，但是它在捕捉沿对角线的三角形边缘上表现较差。因为随着该三角形的移动，所有采样位置都将位于三角形的内部或外部。右侧是一种图案，它可以更有效地捕获此边缘和其他边缘。_

为了获得更好的采样，我们要避免将两个采样彼此靠近。我们还希望分布均匀，将样本均匀分布在整个区域。为了形成这样的图案，我们会将例如拉丁超立方体采样的分层采样技术，与其他例如抖动、霍尔顿序列和泊松磁盘采样的方法相结合 **[1413，1758]**。

实际上，GPU 制造商通常将此类采样模式硬连接到其硬件中，以进行多重采样反走样。对于时间性反走样，因为样本位置会逐帧变化，所以其覆盖范围是程序员无论如何都想获取的。例如，Karis **[862]** 发现基本的 Halton 序列（Halton sequence）比 GPU 提供的任何 MSAA 模式效果更好。霍尔顿序列会在空间中生成样本，这些样本看起来是随机的，但差异很小，也就是说，它们在空间中分布均匀，并且没有聚集（clustered）的现象 **[1413，1938]**。

虽然子像素网格图案可以更好地近似每个三角形如何覆盖网格单元，但这并不是理想的。场景可以由屏幕上任意小的物体组成，这意味着没有采样率可以完美地捕获它们。如果这些微小的物体或特征形成图案，则以恒定间隔进行采样可能会导致莫尔条纹和其他干涉图案。超级采样中使用的网格图案特别容易产生走样。

一种解决方案是使用随机采样，这样可以提供更加随机的图案。如图 5.28 所示的模式肯定可以使用。想象一下，远处有一个拥有漂亮梳齿的梳子，每个像素覆盖几根梳齿。当采样模式与梳齿频率异相时，规则图案就会产生严重的伪像（artifacts）。具有较少顺序的采样模式可以分解这些图案。随机化倾向于用噪声代替重复的走样效果，因为人类视觉系统对此更为宽容 **[1413]**。结构较少的图案是对此有益的，但当像素间重复时，它仍会出现走样。一种解决方案是在每个像素上使用不同的采样模式，或者随时间更改每个采样位置。在过去的几十年中，偶尔会在硬件中支持交错采样（Interleaved sampling）、索引采样（index sampling），其中一组像素的每个像素都有不同的采样模式。（这句原文乱码了，_Interleaved sampling_indexsampling!interleaved，之后会找其他版本对照并纠正一下）例如，ATI 的 SMOOTHVISION 允许每个像素最多 16 个样本和最多 16 个用户定义的采样模式，这些模式能以重复模式（例如 4 × 4 像素图块）的方式混合在一起。 Molnar **[1234]** 以及 Keller 和 Heidrich **[880]** 发现，对于每个像素使用相同的模式时，使用交错式随机采样可以最大程度地减少走样伪像。

值得注意的是其他一些 GPU 支持的算法。 NVIDIA 的较早的 Quincunx 方法 **[365]** 是一种使样本影响一个以上像素的实时反走样方案。“Quincunx” 是指五个对象的排列，四个在正方形中，第五个在中心，例如在六面模具上的五个点的图案。Quincunx 多重采样反走样使用此模式，将四个外部采样置于像素的角落。见图 5.25 。每个角落的采样值被分发给它相邻的四个像素。与其像其他大多数实时方案一样对每个样本进行平均加权，不如对中心样本赋予 1/2 的权重，对每个角落样本赋予 1/8 的权重。由于这种共享，每个像素平均只需要两个样本，其结果比 two-sample FSAA 方法要好得多 **[1678]**。这种模式近似于二维 tent 过滤器，如上一节所述，该过滤器优于 box 过滤器。

通过每像素使用单个样本的方法，也可以将 Quincunx 采样应用于时间性反走样上 **[836，1677]**。其中每帧在每个轴上都比之前的帧偏移半个像素，偏移方向在帧与帧之间交替。前一帧提供像素角落的点样本，并且使用双线性插值来快速计算每个像素的贡献值。 将结果与当前帧取平均值。将结果与当前帧取平均值。 每个帧的权重相等意味着静态视图没有闪烁的伪像。对齐移动物体的问题仍然存在，但是该方案本身易于用代码编写，并且在每帧每像素仅使用一个样本的情况下具有更好的视觉表现。

当在单帧中使用时，Quincunx 通过在像素边界共享样本而具有仅两样本的低成本消耗。RGSS 模式更适合捕获更多水平和垂直边缘的灰度。FLIPQUAD 模式最初是为移动图形设备开发的，结合了这两个理想的功能 **[22]**。它的优点是成本仅为每像素两样本，并且质量类似于 RGSS（每像素四样本）。 这种采样模式如图 5.29 所示。另外，Hasselgren 等人 **[677]** 探索了其他一些利用样本共享方式的廉价采样模式。

![[024c4ebd0a41ef0a15332918ec1d0f64_MD5.png]]

_图 5.29。 左侧显示了 RGSS 采样模式。 每像素花费四个样本。 通过将这些位置移到像素边缘，可以跨边缘进行样本共享。 但是，要解决此问题，每个其他像素必须具有镜像的采样模式，如右图所示。 所得的样本模式称为 FLIPQUAD，每个像素花费两个样本。_

与 Quincunx 一样，双样本的 FLIPQUAD 模式也可以与时间性反走样一起使用，并分布在两个帧上。Drobot **[382，383，1154]** 解决了在他关于混合重建反走样（hybrid reconstruction antialiasing ，HRAA）的研究工作中哪种双样本模式最好的问题。他探索了用于时间性反走样的不同采样模式，并发现 FLIPQUAD 模式是所测试的五种模式中最好的。 棋盘格图案还可以用于时间性反走样。 El Mansouri **[415]** 讨论了使用两个样本 MSAA 创建棋盘渲染，以减少着色器成本，同时解决走样问题。 Jimenez **[836]** 使用 SMAA，时间性反走样技术以及多种其他技术来提供一种解决方案，其中反走样质量可以根据渲染引擎负载来改变。 Carpentier 和 Ishiyama **[231]** 在边缘采样，将采样网格旋转了 45°。 他们将此时间性反走样方案与 FXAA（稍后讨论）结合在一起，以在更高分辨率的显示器上进行有效的渲染。

### 形态学方法 Morphological Methods

走样通常是由边缘引起的，例如由几何形状，尖锐阴影或明亮高光形成的边缘。 走样具有与边缘相关的结构，可以利用这些知识来提供更好的反走样结果。2009 年，Reshetov **[1483]** 沿着这些思路提出了一种算法，称其为形态学反走样（morphological antialiasing ，MLAA）。其中 “形态” 是指“与结构或形状有关”。早在 1983 年，Bloomenthal **[170]** 就在这一领域做了较早的工作 **[830]**。之后 Reshetov 的论文重新激发了对多采样方法替代方法的研究，强调搜索和重建边缘 **[1486]**。

这种反走样形式是在后处理（post-process）中执行的。 也就是说，以通常的方式进行渲染，然后将结果反馈到生成反走样结果的过程中去。自 2009 年以来，已经开发出了多种技术。那些依赖于其他缓冲区（例如深度和法线）的缓冲区可以提供更好的结果，例如子像素重建反走样（subpixel reconstruction antialiasing ，SRAA）**[43，829]**，但仅适用于对几何边缘进行反走样。诸如几何缓冲区反走样（geometry buffer antialiasing，GBAA）和距离边缘反走样（distance-to-edge antialiasing，DEAA）之类的分析方法，会使渲染器计算有关三角形边缘位于何处的附加信息，例如边缘距像素中心的距离有多少 **[829]**。

最通用的方案只需要颜色缓冲区，这意味着它们还可以从阴影，高光或之前应用的各种后处理技术（如轮廓边缘渲染）中改善边缘（见 15.2.3 节）。 例如，方向局部反走样（directionally localized antialiasing，DLAA）**[52，829]** 是基于以下观察结果：接近垂直的边缘应水平模糊，同样，接近水平的边缘也应与其相邻像素垂直模糊。

边缘检测的更复杂形式尝试寻找可能包含任意角度的边缘的像素并确定其覆盖范围。 检查潜在边缘周围的邻域，目标是尽可能地重建原始边缘所在的位置。 然后可以使用边缘对像素的效果来融合相邻像素的颜色。 有关过程的概念视图，请参见图 5.30。

![[950202652327c9cbf523cebfb2bbf585_MD5.png]]

_图 5.30。 形态学反走样。左侧是走样图像。我们的目的是确定形成边缘的边缘的可能方向。中间，该算法通过检查相邻像素来记录其为边缘的可能性。给定样本后，显示了两个可能的边缘位置。右侧，使用最佳的推测边缘将相邻的颜色与估计的覆盖率成比例地混合到中心像素中。之后对图像中的每个像素重复此过程。_

Iourcha 等人 **[798]** 通过检查像素中的 MSAA 样本来计算更好的结果，从而改善了边缘查找。请注意，边缘预测和融合可以比基于样本的算法提供更高的精度。例如，一种使用每像素四样本的技术只能为对象的边缘提供以下五个混合级别：无样本覆盖，一个样本覆盖，两个样本，三个样本和四个样本。估测出的边缘位置可以具有更多的位置，因此可以提供更好的结果。

基于图像的算法中有几种可能会误入歧途。 首先，如果两个对象之间的色差低于算法的阈值，则可能无法检测到边缘。 具有三个或更多不同表面重叠的像素很难进行转换。颜色在像素间快速变化的，具有高对比度或高频率元素的表面，会导致算法错过边缘。特别地，当对其应用形态学反走样时，文本显示的质量通常会受到影响。 对象的角落部分可能是一个挑战，有些算法可以使它们具有圆润的外观。假设边缘是直的，曲线也会受到其不利影响。单个像素变化可能会导致边缘重建方式发生很大变化，从而在帧与帧之间产生明显的伪像（artifacts）。解决此问题的一种方法是使用 MSAA 覆盖蒙版来改善边缘确定性 **[1484]**。

形态学反走样方案仅使用所提供的信息。例如，宽度小于像素的物体（例如电线或绳索）在屏幕上的任何位置都会出现缝隙，而不会覆盖像素的中心位置。在这种情况下，采集更多的样本可以提高质量； 仅基于图像的反走样不能。此外，执行时间可以根据查看的内容而变化。 例如，一片草地的视野所需的反走样时间是天空的三倍 **[231]**。

综上所述，基于图像的方法可以为较小的内存和处理成本提供反走样支持，因此它们被用于许多应用程序中。仅颜色的版本还与渲染管线分离，使其更容易修改或禁用，并且甚至可以公开为 GPU 驱动程序选项。两种最流行的算法是快速近似反走样（fast approximate antialiasing，FXAA）**[1079、1080、1084]** 和子像素形态反走样（subpixel morphological antialiasing，SMAA）**[828、830、834]**，部分原因是它们都为各种设备提供了可靠的（以及免费的）源代码实现。两种算法都使用仅颜色的输入，SMAA 具有能够访问 MSAA 样本的优势。 每个算法都有自己可用的各种设置，以便在速度和质量之间进行权衡。 每帧消耗通常在 1-2 毫秒的范围内，主要是因为这是视频游戏所愿意花费的时间。 最后，两种算法都可以应用时间性反走样功能 **[1812]**。 Jimenez **[836]** 提出了一种改进的 SMAA 实现，比 FXAA 更快，并描述了一种时间性反走样方案。 总之，我们向读者推荐 Reshetov 和 Jimenez **[1486]** 对形态学技术及其在视频游戏中的使用的广泛评论。

 



## 5.5 透明度，Alpha 值，与合成 Transparency, Alpha, and Compositing

光通过半透明物体的方法有许多种。对于渲染算法而言，这些方法可以大致分为基于光的效果或基于视图的效果。基于光的效果是指对象使光衰减或转移，导致场景中的其他对象被照亮和呈现不同的效果。基于视图的效果是指半透明对象自身的渲染效果。

在本节中，我们将讨论基于视图的透明度的最简单形式，其中半透明对象充当其背后对象颜色的衰减器。在后面的章节中将讨论更详细的基于视图和光的效果，例如毛玻璃（frosted glass），光的弯曲（折射），由于透明物体的厚度导致的光衰减以及由于视角导致的反射率（reflflectivity）和透射率（transmission）变化。

一种制造透明感的方法称为屏幕门透明（screen-door transparency）**[1244]**。其思路是用像素对齐的棋盘格填充图案渲染半透明三角形。通常，屏幕上的像素足够紧凑以至于棋盘格图案本身是不易察觉的。这种方法的一个主要劣势是，通常只有一个半透明的对象可以令人信服地在屏幕的一个区域上渲染出来。举个例子，如果半透明的红色对象和半透明的绿色对象在蓝色对象之上渲染，则三种颜色中只有两种可以出现在棋盘格图案上。此外，50% 的棋盘格效果是很有限的。其他更大的像素蒙版可用于给出其他百分比混合效果，但是这些倾向于创建那些可检测的图案 **[1245]**。

**(?)**（上面这一段有些不好理解，不知翻译准不准确，请各路大神多多指教）

之前说过，这种技术的一个优势是它比较简单。半透明对象可在任意时间，以任何顺序呈现，且不需特殊的硬件支持。通过使所有对象在它覆盖的（棋盘格）像素处变为不透明，便解决了透明度的问题。同样的思路也被用于对剪切纹理的边缘进行反走样处理，但是这是在子像素级别，使用了被称为 Alpha 覆盖（alpha to coverage）的功能（第 6.6 节）。

由 Enderton 等人介绍 **[423]**，随机透明（stochastic transparency）的方法使用子像素屏幕门遮罩与随机采样相结合而成。通过使用随机点画图案表示片元的 Alpha 覆盖，可以创建一个合理但含噪声的图像。见图 5.31。为了看起来更合理，每个像素都需要大量的样本，当然，也需要为所有这些子像素样本准备相当大的内存空间。但此方法很有吸引力的是不需要进行混合操作，并且反走样，透明度，以及任何其他的创建部分覆盖像素的现象都可用此单一机制来处理。

大多数透明度算法会将透明对象的颜色与其后面对象的颜色混合在一起。为此，我们需要 Alpha 混合的概念 **[199，387，1429]**。当在屏幕上渲染对象时，RGB 颜色和 z 缓冲区深度这两者与每个像素都是相关联的。我们还可以为对象覆盖的每个像素定义另一个组件，称为 Alpha（α）。Alpha 是一个值，它用于描述给定像素的对象片元的不透明度和覆盖度。Alpha 为 1.0 表示对象是不透明的，并且完全覆盖了像素的关注区域；0.0 表示完全不隐藏像素，即片元是完全透明的。

像素的 Alpha 值可以表示不透明度或覆盖率，或同时是两者，这具体视情况而定。举个例子，肥皂泡的边缘可能会覆盖像素的四分之三，即 0.75，并且可能几乎是透明的，从而使十分之九的光线直达眼睛，所以它的十分之一是不透明的，即 0.1。那么其 Alpha 将为 0.75 × 0.1 = 0.075。但是，如果我们使用 MSAA 或类似的反走样方案，覆盖率将通过样本自身从而被考虑在内。因此四分之三的样本将受到肥皂泡的影响。然后，在每个样本中，我们将使用 0.1 的不透明度值作为 Alpha 值。

![[b9e1f1a74faff51bf50906fa38e193ca_MD5.png]]

 **图 5.31.** 随机透明。产生的噪声显示在放大区域中。（图片来自 NVIDIA SDK11 [1301] 样本，由 NVIDIA 公司提供。）

### 5.5.1 混合顺序 Blending Order

为了使对象看起来透明，它以小于 1.0 的 Alpha 渲染到现有场景的顶部。对象覆盖的每个像素将从像素着色器接收结果

![[b563f7dec85823efbd9ea169b98bbda2_MD5.gif]]

（也称为 RGBA）。通常使用 **over** 运算符将此片段的值与原始像素颜色混合，如下所示：

![[3f4abfab23e0986322bebb6ff3207f5a_MD5.png]]

其中 

![[14e5002d7c0bf01c8d9c95d2550b35f5_MD5.gif]]

 是半透明对象的颜色（称作来源， source），$\alpha _{s}$ 是对象的 Alpha 值，

![[ec68459e0f97ceac474a69fc0d7aa1ee_MD5.gif]]

 是混合前的像素颜色（称作目标，destination），$\textbf{c}_{o}$ 是将半透明对象放置在现有场景上而产生的最终颜色。在渲染管线传入 

![[14e5002d7c0bf01c8d9c95d2550b35f5_MD5.gif]]

 和 $\alpha _{s}$ 的情况下，像素的原始颜色 

![[ec68459e0f97ceac474a69fc0d7aa1ee_MD5.gif]]

 被结果 $\textbf{c}_{o}$ 所取代。如果传入的

![[b563f7dec85823efbd9ea169b98bbda2_MD5.gif]]

 实际上是不透明的（$\alpha_{s}$ = 1.0），则该公式简化为用对象的颜色完全替换像素的颜色。

**示例：混合。**红色的半透明对象被渲染到蓝色背景上。假设某个像素的对象的 RGB 着色为（0.9，0.2，0.1），背景为（0.1，0.1，0.9），并且对象的不透明度设置为 0.6。然后将这两种颜色混合


![[afce20e0e91b6d2f66b8bdfa53acdd20_MD5.png]]

它的颜色为（0.58,0.16,0.42）。

**over** 运算符为要渲染的对象提供半透明外观。通过这种方式实现的透明性可以正常工作，即只要可以通过它看到后面的对象，我们就会将它视为透明的物体 **[754]**。使用 **over** 模拟薄纱织物的真实效果。织物背后对象的视图被部分遮挡了——织物的线是不透明的。在实践中，宽松的织物具有随角度变化的 Alpha 覆盖率 **[386]**。这里的重点是 Alpha 模拟了材质覆盖像素的程度。

![[4497bf055b920430bf5ca97eb4aff075_MD5.png]]

**图 5.32.** 红色薄纱正方形的织物与红色的塑料过滤器，它们具有不同的透明效果。注意，它们的阴影也不同。（照片由 Morgan McGuire 提供。）

**over** 运算符对于其他类型的半透明效果显得不是很可信，尤其是透过有色玻璃或塑料观看时。在现实世界中，放置在蓝色物体前面的红色滤镜通常会使蓝色物体看起来很暗，因为该物体反射的可以穿过红色滤镜光线很少。参见图 5.32。当使用 **over** 进行混合时，结果是红色和蓝色部分相加在一起。更好的方法应该是将这两种颜色相乘，并增加透明对象本身的反射。第 14.5.1 节和第 14.5.2 节中讨论了这种类型的物理透射率。

在基本的混合阶段运算符中，**over** 是通常用于透明效果的运算符 **[199，1429]**。另一种有用的操作是加法混合（additive blending），即将像素值简单地求和。如下所示，

![[daab9fa46c48c448e064606de28db027_MD5.png]]

这种混合模式能够很好地用于发光效果，例如闪电或火花，这些效果不会使后面的像素衰减，而只会使它们变得更亮 **[1813]**。然而，此模式的透明度看起来不正确，因为不透明的表面似乎没有被过滤 **[1192]**。对于诸如烟或火焰之类的多层分层半透明表面，加法混合具有使半透明现象的颜色更饱和的效果 **[1273]**。

为了正确渲染半透明对象，我们需要在不透明对象之后绘制它们。首先，通过关闭混合以渲染所有不透明对象，然后开启 **over** 以渲染半透明对象。从理论上讲，我们总是可以让 **over** 开启，因为不透明的 Alpha 1.0 会给出源颜色并隐藏目标颜色，但是这样做成本更高，而且没有真正的收益。

z 缓冲区的限制是每个像素只能存储一个对象。如果多个透明对象与同一像素进行重叠，则仅 z 缓冲区无法容纳且无法在之后解决所有可见对象的影响。当使用 **over** 时，任何给定像素处的透明表面通常都需要以从后到前的顺序进行渲染。不这样做的话可能会给出错误的知觉暗示。一种实现这种排序的方法是，按照单个对象的质心沿相机视角的距离对其进行排序。这种粗略的分类可以很好地工作，但是在各种情况下都有许多问题。首先，这里的顺序只是一个近似值，因此分类时较远的对象可能位于较近的对象的前面。互相贯穿的对象无法针对所有视角在每个网格上都进行正确显示，除非将每个网格分解为单独的碎片。相关案例，请参见图 5.33 的左图。甚至具有凹面的单个网格也会在屏幕上重叠的视角上出现排序问题。

![[e9ca1e3fd99769af2ca8692fba19c388_MD5.png]]

**图 5.33.** 在左侧，使用 z 缓冲区以透明方式渲染模型。以任意顺序渲染网格会产生严重的错误。在右侧，深度剥离可提供正确的外观，但要消耗额外的 pass 数。（图片由 NVIDIA Corporation 提供。）

尽管如此，由于其简单性与速度，以及它不需要额外的内存或特殊 GPU 支持，我们仍然经常使用这种对透明度进行粗糙排序的方法。如果应用了这种方法，通常最好在执行透明度时关闭 z 深度替换功能。也就是说，z 缓冲区仍然可以正常测试，但是保留下来的的曲面不会改变存储的 z 深度；最接近的不透明表面的深度保持不变。用这种方法，所有半透明物体都至少会以某种形式出现，而不是在照相机旋转导致的更改排序顺序时造成物体突然出现或消失。其他技术也可以帮助改善外观表现，例如每次绘制两次透明网格，首先渲染背面，然后渲染正面 **[1192，1255]**。

**over** 方程也可进行修改，以使从前到后混合能得到相同的结果。这种混合模式称为 **under** 运算符：

![[cc8cca982b9cb889f426e2c9ec5d801b_MD5.png]]

请注意，**under** 要求目标保持 Alpha 值，而 **over** 则不需要。换句话说，目标——在它之面混合了更近的透明表面——并不是不透明的，因此需要具有 Alpha 值。**under** 的公式和 **over** 相似，但是交换了源和目标。另外需要注意的是，用于计算 Alpha 值的公式与顺序无关，因为源 Alpha 值和目标 Alpha 值可以交换，结果都是相同的最终 Alpha 值。

Alpha 公式来自将片元的 Alpha 作为覆盖率。Porter 和 Duff **[1429]** 注意到，由于我们不知道每个片元覆盖区域的形状，因此我们假设每个片元都按其 Alpha 值比例去覆盖另一个片元。例如，如果 $\alpha _{s} = 0.7$ ，则以某种方式将像素分为两个区域，其中源片元覆盖 0.7，而目标片元覆盖 0.3。除非有其他新的技术，否则目标片元覆盖范围，我们称 $\alpha _{d} = 0.6$ ，会按比例地与源片元进行重叠。该公式具有几何解释，如图 5.34 所示。

![[1a351bad38e4b1e78ef2e8af25b610ab_MD5.png]]

**图 5.34.** 一个像素和两个片元 s 和 d 。通过沿着不同的轴对齐两个片元，每个片元会按一定比例覆盖另一个片元，也就是说，它们是不相关的。两个片元覆盖的面积等于 **under** 输出的 Alpha 值。这意味着将两个面积相加，然后减去它们重叠的面积。

![[6426e06ca668a409e7a45da58a392149_MD5.png]]

**图 5.35.** 每个深度剥离 Pass 都绘制其中一个透明层。左侧是第一遍绘制，显示了直接可见的图层。中间显示的第二层在每个像素处显示了距离第二近的半透明表面，在这种情况下为对象的背面。右边的第三层是一组距离第三近的透明表面。最终结果可以在第 624 页的图 14.33 中找到。（图片由 Louis Bavoil 提供。）

### 5.5.2 与顺序无关的透明度 Order-Independent Transparency

我们通过将所有半透明对象绘制到单独的颜色缓冲区，然后使用 **over** 将该颜色缓冲区合并到场景的不透明视图之上，从而来使用 **under** 方程。**under** 运算符的另一种用途是执行称为深度剥离（depth peeling） **[449，1115]** 的与顺序无关的透明度（order-independent transparency, OIT）算法。顺序无关意味着应用程序不需要执行排序。深度剥离的思路是使用两个 z 缓冲区和多 Pass。首先，渲染一个 Pass，以使所有表面的 z 深度（包括透明表面）都位于第一个 z 缓冲区中。在第二个 Pass 中，将会渲染所有半透明对象。如果对象的 z 深度与第一个 z 缓冲区中的值匹配，则我们就知道这是最近的半透明对象，然后将它的 RGBα 值保存到单独的颜色缓冲区中。我们还通过保存所有半透明对象（如果有）的超出第一个 z 深度并且最接近的 z 深度来 “剥离” 该层。此 z 深度是第二近的透明对象的距离。接下来的一系列 Pass 继续使用 **under** 进行剥离并添加透明层。经过一定数量的 Pass 渲染之后，我们会停下来，然后将半透明图像混合在不透明图像之上。见图 5.35。

该方案的几种变体已经研发出来了。例如，Thibieroz **[1763]** 提供了一种从后到前计算的算法，其优点是能够立即混合透明值，这意味着我们不需要单独的 Alpha 通道。深度剥离的一个问题是需要知道究竟多少 Pass 足以捕获所有透明层。一种硬件上的解决方案是提供一个像素绘制计数器，该计数器可指示渲染过程中写入了多少个像素。当 Pass 未渲染任何像素时，渲染就直接完成了。使用 **under** 的好处是，最重要的半透明层——眼睛首先看到的那些——会在早期就进行渲染。每个半透明表面都会增加其覆盖的像素的 Alpha 值。如果像素的 Alpha 值接近 1.0，则混合的贡献值会使像素几乎是不透明的，因此距离较远的对象的影响可忽略不计 **[394]**。当通过 Pass 渲染的像素数低于某个最小值或可以指定固定数量的 Pass 时，可以减少从前到后的剥离过程。然而这对于从后到前的剥离效果不佳，因为距离最近（并且通常是最重要）的层是最后绘制的，因此可能会因早期过程的终止而丢失片元。

尽管深度剥离是有效的，但它的速度有可能很慢，因为每一层的剥离都是针对所有半透明对象的一个独立的渲染 Pass。Bavoil 和 Myers **[118]** 提出了双重深度剥离技术，其中在每个 Pass 中剥离了两个深度剥离层，分别是最接近的和最远的剩余层，从而将渲染 Pass 的数量减少了一半。Liu 等人 **[1056]** 探索了一种桶排序方法（bucket sort method），该方法一次可捕获多达 32 个层。这种方法的一个缺点是，它需要大量内存才能为所有层保持排序顺序。通过 MSAA 或类似方法进行反走样将极大地增加成本。

以交互速率正确地将半透明对象混合在一起的问题并不是我们缺少算法的问题，而是将这些算法有效地映射到 GPU 的问题之一。1984 年，Carpenter 提出了 A 缓冲区 **[230]**，这是另一种多重采样的形式。在 A 缓冲区中，渲染的每个三角形都会为其完全或部分覆盖的每个屏幕网格创建一个覆盖蒙版（coverage mask）。每个像素存储所有相关片元的列表。不透明的片元可以清除它们后面的片元，类似于 z 缓冲区。所有片元均存储在透明表面上。一旦所有列表形成，就可以通过遍历片元和解析每个样本来产生最终结果。

DirectX 11 **[611，1765]** 中公开的新功能使在 GPU 上创建片元的链表的想法成为可能。第 3.8 节中介绍了用于无序访问视图（UAV）和原子操作的功能。基于 MSAA 的反走样可以通过访问覆盖蒙版和去计算每个样本的像素着色器的方式来实现。该算法通过对每个透明表面进行光栅化，并将生成于长数组中的片元插入从而实现。连同颜色和深度一起，会生成一个单独的指针结构，该结构将每个片元与之前为像素存储的片元相链接。然后执行单独的 Pass，在此渲染屏幕填充四边形，以便在每个像素处计算像素着色器。该着色器通过跟随链接来检索每个像素处的所有透明片元。检索到的每个片元都与先前的片元依次排序。然后将排序后的列表从前向后混合，从而得出最终的像素颜色。由于混合是由像素着色器执行的，因此，如果需要，可以为每个像素指定不同的混合模式。随着 GPU 和 API 的不断发展，性能表现也不断提高，而这是通过减少使用原子运算符的消耗来做到的 **[914]**。

A 缓冲区的优点是，仅分配每个像素所需的片元，GPU 上的链表实现也是如此。从某种意义上讲，这也可能是不利的，因为在开始渲染帧之前所需的存储量是未知的。具有头发，烟雾或其他物体的场景可能具有许多重叠的半透明表面，因此可能会产生大量的片元。Andersson **[46]** 指出，对于复杂的游戏场景，最多可以重叠 50 个物体（例如树叶）的透明网格和最多 200 个半透明粒子。

![[2e1067c44d947e12868daff237e2a1b8_MD5.png]]

**图 5.36.** 在左上方，执行传统的从后到前的 Alpha 混合，由于排序顺序不正确，导致渲染错误。在右上方，A 缓冲区用于提供完美的非交互结果。左下方显示了具有多层 Alpha 混合的渲染。右下方显示了 A 缓冲区和多层图像之间的差异，将其乘以 4 可得到可见度 **[1532]**。（图片由英特尔公司的 Marco Salvi 和 Karthik Vaidyanathan 提供。）

GPU 通常有预先分配好的内存资源，例如缓冲区和数组，并且链表方法也不例外。用户需要决定需要多少内存，而内存不足会导致明显的伪像。Salvi 和 Vaidyanathan **[1532]** 提出了一种使用英特尔引入的，被称为像素同步的 GPU 功能来解决此问题的方法，即多层 Alpha 混合（multi-layer alpha blending）。见图 5.36。该功能可提供可编程混合模式，且开销比原子操作要少。他们的方法重新定义了存储和混合的方式，以便在内存用完的情况下适当降低性能。此外，粗略的排序顺序也有益于该方案。DirectX 11.3 引入了光栅化程序顺序视图（第 3.8 节），这是缓冲区的一种类型，它允许在支持该功能的任何 GPU 上实现该透明方法 **[327，328]**。移动设备也具有类似的技术，我们称为图块本地存储（tile local storage），它允许它们实现多层 Alpha 混合 **[153]**。然而，这种机制具有性能成本，所以这种类型的算法的消耗可能很大 **[1931]**。

这种方法建立在 Bavoil 等人 **[115]** 提出的 k 缓冲区的概念上。其中保存了前几层的可见图层并尽可能地对其进行了排序，而更深的图层则被丢弃并尽可能地进行了合并。Maule 等人  **[1142]** 使用 k 缓冲区，并通过使用加权平均（weighted averaging）来解决这些较远的深层级。加权和（weighted sum） **[1202]** 与加权平均 **[118]** 透明技术都和顺序无关，且都是单 Pass，并且几乎可以在任意 GPU 上运行。但它们的问题在于没有考虑对象的顺序。因此，例如使用 Alpha 表示覆盖率，在一条淡蓝色围巾上的一条淡红色围巾给人一种紫罗兰色的感觉，而不是正确地看到一条带有一些蓝色的红色围巾。虽然对于接近不透明的对象给出的结果会很差，但这类算法对于可视化是有用的，并且对高度透明的表面和粒子可以很好地工作。见图 5.37。


![[45ebb457e842c4aa41461a660075feaa_MD5.png]]

**图 5.37.** 随着不透明度的增加，对象的顺序变得越来越重要。（Dunn 提供图片 **[394]**。）

在加权和透明度中，公式为

![[81e46d134ecc0793b6599293c22d6c7e_MD5.png]]

 其中 $n$ 是透明表面的数目，$\textbf{c}_{i}$ 和 $\alpha _{i}$ 表示透明值的集合，$\textbf{c}_d$ 是场景中不透明部分的颜色。当绘制透明表面时，将两个和累积并分别存储，并在半透明 Pass 结尾，在每个像素处计算该公式。该方法的问题在于，第一个求和是饱和的，即会得到大于（1.0,1.0,1.0）的颜色值，并且因为 Alpha 的总和可能超过 1.0，所以背景颜色可能会产生负面影响。

通常我们首选加权平均公式，因为它避免了这些问题：

![[3330ccf7591a54a99a0e40e0036b26c8_MD5.png]]

第一行表示半透明渲染过程中在两个单独的缓冲区中生成的结果。提供给 $\textbf{c}_{sum}$ 的每个表面都受到一个由其 Alpha 加权的影响； 几乎不透明的表面提供了更多的颜色，几乎透明的表面则几乎没有影响。通过将 $\textbf{c}_{sum}$ 除以 $\alpha _{sum}$，我们得到了加权的平均透明度颜色。值 $\alpha _{avg}$ 是所有 Alpha 值的平均。值 $u$ 是在 $n$ 次透明表面上应用此平均 Alpha 次数 $n$ 次后，目标（不透明场景）的可见度估计值。最后一行实际上是 **over** 运算符，其中 $(1-u)$ 代表源的 Alpha。

加权平均值的一个限制是，对于相同的 Alpha，无论顺序如何，它均等地混合了所有颜色。McGuire 和 Bavoil **[1176，1180]** 引入了加权混合的与顺序无关的半透明方案进行渲染，以提供更具说服力的结果。在进行模拟时，相机到表面的距离也会影响权重，更靠近的表面会受到更大的影响。而且，不是对 Alpha 进行平均，而是通过将 $(1-\alpha _{i})$ 的多个项一起相乘，并用 1 减去它来计算 $u$，从而获得一组表面的真实 Alpha 覆盖率。如图 5.38 所示，该方法产生了更具视觉效果的结果。

![[c7abf0f6425cfd5a6bf5dbae137fb00a_MD5.png]]

**图 5.38.** 查看同一引擎模型的两个不同的摄像头位置，均使用加权混合的与顺序无关的半透明方案进行渲染。按距离加权有助于弄清哪些表面更靠近观察者 **[1185]**。（图片由 Morgan McGuire 提供。）

该方案的缺点是，在较大的环境中，彼此靠近的对象的距离权重几乎是相等的，所以这使结果与加权平均值几乎没有区别。另外，随着相机到透明物体的距离的改变，深度权重实际上可能会发生变化，但是这种变化是逐渐的。

McGuire 和 Mara **[1181，1185]** 扩展了该方法，使其包含了合理的透射颜色效果。如前所述，本节中讨论的所有透明度算法都将各种颜色混合在一起而不是对其进行过滤，从而模仿了像素覆盖率。为了得出滤色器的效果，不透明场景由像素着色器读取，每个半透明表面将它在该场景中覆盖的像素乘以它的颜色，并将结果保存在第三个缓冲区中。这个缓冲区，其中不透明的对象现在被半透明的对象染色，在接下来解析半透明缓冲区时，会用来代替不透明的场景。该方法之所以有效是因为颜色的传输与顺序无关，这与覆盖所造成的透明度是不同的。

还有其他算法用到了这里所介绍的技术中的部分元素。例如，Wyman **[1931]** 通过内存需求，插入和合并方法对之前的这些工作进行了分类，无论是 Alpha 或者几何覆盖率，还是如何处理丢弃的碎片，都有被使用。通过寻找先前研究中的漏洞，他展示了两种被发现的新方法。他的随机分层 Alpha 混合方法使用了 k 缓冲区，加权平均值和随机透明度。他的其他算法是 Salvi 和 Vaidyanathan 方法的一种变体，使用覆盖蒙版而不是 Alpha 值。

尽管我们给出了种类繁多的半透明相关内容、渲染方法和 GPU 功能，但是并没有完美的解决方案来呈现半透明对象。请感兴趣的读者阅读 Wyman 的论文 **[1931]** 和 Maule 等人的关于交互式透明性算法的更详细的研究 **[1141]**。McGuire 的演讲 **[1182]** 提供了该领域的更广阔视野，它融会贯通了其他相关现象，例如体积照明，彩色透射和折射，这些将在本书的后面章节进行更深入的讨论。

### 5.5.3 预乘 Alpha 与合成 Premultiplied Alphas and Compositing

**over** 操作符还用于将照片或对象的合成渲染混合到一起。该过程我们称之为合成（compositing） **[199，1662]**。在这种情况下，每个像素的 Alpha 值将与对象的 RGB 颜色值一起存储。由 Alpha 通道形成的图像有时称为无光粗糙层 **(?)**（matte）。它显示了对象的轮廓形状。相关示例请参见第 203 页的图 6.27。接下来我们可以使用此 $\textrm{RGB}\alpha$ 图像，将其与其他此类元素进行混合，或在背景下进行混合。

使用合成 $\textrm{RGB}\alpha$ 数据的一种方法是使用预乘 Alpha（也称为关联的 Alpha）。即在使用之前，将 RGB 值乘以 Alpha 值。这使合成 **over** 公式的效率更高：：

![[70bae5bb510b5714dd18f3ef0d534745_MD5.png]]

其中 $\textbf{c}^{'}_{s}$ 是预乘的源通道，代替在公式 5.25 中的 $\alpha _{s}\textbf{c}_{s}$  。预乘 Alpha 还可以在不更改混合状态的情况下使用 **over** 和叠加混合，因为现在在混合过程中添加了源颜色 **[394]**。请注意，使用预乘的 $\textrm{RGB}\alpha$ 值，虽然可以将 RGB 分量创建为特别明亮的半透明值，但是它们通常不大于 Alpha 值。

合成图像的渲染很自然地与预乘 Alpha 相吻合。默认情况下，在黑色背景上渲染的反走样不透明对象会提供预乘值。假设白色（1、1、1）三角形沿其边缘覆盖了某些像素的 40％。使用（极精确的）反走样功能，像素值将设置成值为 0.4 的灰色，即我们将为此像素颜色保存为（0.4，0.4，0.4）。如果是存储 Alpha 值，那么也将为 0.4，因为这是三角形覆盖的区域范围。最终 $\textrm{RGB}\alpha$ 值为（0.4、0.4、0.4、0.4），且这是一个预乘值。

图像存储的另一种方式是使用未相乘的（unmultiplied alphas） Alpha，它也被称为未关联的（unassociated alphas） Alpha，甚至是一个令人费解的术语，非预乘的 Alpha（nonpremultiplied alphas）。未相乘的 Alpha 就是它的字面意思：RGB 值不乘以 Alpha 值。对于白色三角形的示例，未相乘的颜色为（1、1、1、0.4）。这种表示形式的优点是可以存储三角形的原始颜色，但是在显示之前，始终需要将该颜色乘以存储的 Alpha 值。最好在执行过滤和混合操作时使用使用预乘数据，因为使用未相乘的 Alpha 并不能正确执行线性插值之类的操作 **[108，164]**。这可能会产生诸如围绕对象边缘的黑色条纹之类的伪像 **[295，648]** 进一步讨论参见 6.6 节的末尾。另外，预乘 Alpha 也可以进行更清晰的 **(?)** 理论处理 **[1662]**。

对于图像处理应用程序来说，未关联的 Alpha 值可用于遮盖照片而不影响基础图像的原始数据。同样，未关联的 Alpha 意味着可以使用颜色通道的整个精度范围。也就是说，必须小心地将未相乘的 $\textrm{RGB}\alpha$ 值正确地转换到用于计算机图形计算的线性空间，或从线性空间转换回来。举个例子，没有浏览器会正确执行此操作，它们也不可能这样做，因为目前估计可能会出现不正确的行为 **(?)** **[649]**。支持 Alpha 的图像文件格式包括 PNG（仅非关联的 Alpha），OpenEXR（仅关联）和 TIFF（两种 Alpha 类型）。

与 alpha 通道相关的概念是色度选择（chroma-keying） **[199]**。这是视频制作中的一个术语，其中演员是在绿色或蓝色屏幕上拍摄并与背景融合在一起的。在电影工业中，此过程称为绿幕（green-screening ）或蓝幕（blue-screening）。这里的思路是，将特定的色相（用于胶卷）或精确值（用于计算机图形）指定为透明；只要检测到绿幕或蓝幕，那么就会显示背景。这样，仅使用 RGB 颜色就可得出图像的轮廓形状；无需存储任何 Alpha。该方案的一个缺点是，对象在任何像素处要么完全不透明，要么完全透明，即，alpha 实际上仅为 1.0 或 0.0。举个例子，GIF 格式图片仅允许将一种颜色指定为透明。

## 5.6 显示编码 Display Encoding

当我们计算照明，纹理或其他操作的效果时，假定使用的值为线性（linear）。非正式情况下，线性意味着加法和乘法按预期执行。但是，为了避免出现各种视觉伪像，显示缓冲区和纹理使用非线性编码，这也是我们必须要考虑的问题。关于该问题，简短而粗略的答案如下：选取 [0，1] 范围内的着色器输出颜色并将其提高 1/2.2 的幂，执行被称为伽马校正（gamma correction）的操作。对传入的纹理和颜色执行相反的操作。在大多数情况下，你可以让 GPU 为你执行这些操作。本节说明了该方案的做法和原因。

我们从阴极射线管（CRT）开始讲起。在数字成像的早期，CRT 显示器是标准规范。这些设备在输入电压和显示辐射率之间表现出幂律关系。随着施加到像素的能级的增加，发出的辐射不会呈现线性增长，而是（令人惊讶地）与该能级成正比地升高，从而达到大于 1 的功率。例如，假设功率为 2。值被设置为 0.5 的一个像素只发出设置为 1.0 的像素的四分之一的光量，即 $0.5^{2}=0.25$**[607]**。虽然 LCD 和其他显示技术具有与 CRT 不同的固有色调响应曲线，但它们是通过转换电路制造的，这使它们能够模仿 CRT 的响应。

该幂函数几乎与人类视觉的亮度灵敏度相反 **[1431]**。这种幸运巧合的结果是，编码是近似感知统一的（perceptually uniform）。也就是说，在可显示范围内，一对编码值 N 和 N + 1 之间的感知差大致恒定。通过测量阈值对比度（threshold contrast），我们可以在各种条件下检测到其亮度差异约为 1％。当颜色存储在精度有限的显示缓冲区中时， 这种近似最优的值分布可以最大程度上地减少条带化现象（banding artifacts）（见第 23.6 节）。同样的优点也适用于纹理，因为它们通常使用相同的编码。

显示传递函数（display transfer function ）描述了显示缓冲区中的数字值与从显示器发出的辐射水平之间的关系。因此，它也被称为电光学传递函数（electrical optical transfer function，EOTF）。显示传输功能是硬件的一部分，并且对于计算机显示器，电视和电影放映机，有着不同的标准。在该过程的另一端，还有图像和视频捕获设备，并且还有一个标准的传递函数，它被称为光电传递函数（optical electric transfer function，OETF）**[672]**。

在对用于显示的线性颜色值进行编码时，我们的目标是要消除显示传递函数的影响，以便我们计算的任何值都将发出相应的辐射亮度级别。例如，如果我们的计算的值加倍，我们希望输出的辐射率也加倍。为了保持这种关系，我们使用了显示传递函数的逆函数来抵消其非线性效应。取消显示响应曲线的过程也称为伽玛校正（gamma correction），关于进行伽马校正的原因很快会在接下来说明。在解码纹理值时，我们需要应用显示传递函数来生成用于着色的线性值。图 5.39 显示了解码和编码在显示过程中的使用。

![[de46998c745374545db65c174b9a8708_MD5.png]]

**图 5.39.** 在左侧，一个 PNG 颜色纹理被 GPU 着色器访问，并且它的非线性编码值被转换（蓝色）到线性值。在着色与色调映射之后（8.2.2 节），最终计算值被编码（绿色）并且存储在帧缓冲区中。该值与显示传递函数决定了发射（红色）的辐射量。绿色和红色功能的组合抵消了，因此发出的辐射与线性计算值成正比。

个人计算机显示器的标准传递函数由被称为 sRGB 的颜色空间规范定义。当从纹理中读取值或将值写入颜色缓冲区时，可以将大多数控制 GPU 的 API 设置为自动应用正确的 sRGB 转换 **[491]**。如 6.2.2 节所述，生成 MipMap 还将考虑 sRGB 编码。通过先转换为线性值，然后执行插值，纹理值之间的双线性插值就可以正确地执行。通过将存储的值解码回线性值，混合新值，然后对结果进行编码，就可以正确完成 Alpha 的混合。

当将值写入显示的帧缓冲区时，在转换的最后阶段应用该转换是很重要的。如果在显示编码之后应用后处理，则将在非线性值上计算此类效果，这通常是不正确的，并且经常会导致伪像。我们可以将显示编码视为一种压缩形式，这可以最好地保留该值的感知效果 **[491]**。解决这一问题的一个好方法是使用线性值来执行物理计算，每当我们要显示结果或访问可显示图像（例如颜色纹理）时，我们需要使用适当的编码或解码转换，将数据转入或转出其显示编码形式。

如果确实需要手动应用 sRGB，则可以使用标准转换公式或一些简化版本。实际上，显示是由每个颜色通道的一些比特位数控制的，例如，对于消费者级别的显示器，该位数为 8，并提供一组在 **[0，255]** 范围内的级别。在这里，我们将显示编码的级别表示为 **[0.0，1.0]** 范围，而忽略位数。线性值也在 **[0.0，1.0]** 范围内，表示浮点数。我们用 x 表示这些线性值，用 y 表示存储在帧缓冲区中的非线性编码值。要将线性值转换为 sRGB 非线性编码值，我们应用 sRGB 显示传递函数的逆函数：

![[7e0be09c95daca12edb22d473a15f86a_MD5.png]]

其中 x 代表线性 RGB 三元组的通道。该公式适用于每个通道，这三个生成的值会用作显示。如果你手动应用转换功能，请当心。产生错误的原因之一是使用编码的颜色而不是其线性形式，另一种原因是将颜色解码或编码两次。

这两个变换表达式的底部是一个简单的乘法，这是由于数字硬件需要使变换完全可逆而产生的 **[1431]**。涉及将值提高到幂的最高表达式几乎适用于输入值 x 的整个范围 **[0.0，1.0]**。考虑到偏移量和比例尺，此函数非常近似于一个更简单的公式 **[491]**：

![[77a38f9cfc029a705e8757b98acb8a60_MD5.png]]

γ= 2.2。希腊字母 γ 是名称 “伽玛校正” 的来源。

正如必须对计算值进行编码以进行显示一样，在进行计算之前，必须将静态相机或摄像机捕获的图像转换为线性值。你在显示器或电视上看到的任何颜色都有一些显示编码的 RGB 三元组，它们可通过屏幕捕获或颜色选择器获得。这些值是以 PNG，JPEG 和 GIF 等文件格式存储的，它们都是可以直接发送到帧缓冲区并在屏幕上显示而不用进行转换的格式。换句话说，你在屏幕上看到的所有内容都是定义为显示编码的数据。在着色计算中使用这些颜色之前，我们必须将这种编码形式转换回线性值。从显示编码到线性值所需的 sRGB 转换是

![[803a6748f519d0707c9a507b310ba863_MD5.png]]

其中 y 代表标准化的显示频道值，即存储在图像或帧缓冲区中的值，表示为 [0.0，1.0] 范围内的值。此解码函数与我们以前的 sRGB 公式相反。这意味着，如果着色器访问纹理并输出纹理而没有更改，则其外观将与预期的一样。解码函数与显示传递函数相同，因为存储在纹理中的值已进行编码以便正确显示。此外，我们没有转换到提供线性响应显示，而是转换到提供线性值。

更简单的伽玛显示传递函数是公式 5.31 的反函数：

![[bfaae9917ac9851a43a8f72cdd4cbe1a_MD5.png]]

有时，你会看到一个更简单的转化对，尤其是在移动应用和浏览器应用中 **[1666]**：

![[4b321d6f6e4193b1d52ad83d69f4af82_MD5.png]]

也就是说，我们取线性值的平方根进行转换以进行显示，而对逆值只需再与自身相乘一次就可以了。虽然是粗略近似，但这种转换比完全忽略该问题要好。

![[cc988f97c430dc48bf1c785930397cb6_MD5.png]]

**图 5.40.** 两个重叠的聚光灯照亮一个平面。在左侧图像中，在将亮度值 0.6 和 0.4 相加后不执行伽马校正。有效地对非线性值执行加法操作，从而导致错误。请注意，左侧的光看起来比右侧的光要明亮得多，重叠部分的亮度显得不够真实。在右图中，相加后的值将进行伽玛校正。灯光本身会成比例地变亮，并且在重叠的地方可以正确组合。

如果我们不注意伽玛，则较低的线性值将在屏幕上显示得太暗。一个与之相关的错误是，如果不执行伽马校正，某些颜色的色相可能会偏移。假设我们的 γ= 2.2。我们要从显示的像素发出与线性计算值成比例的辐射度，这意味着我们必须将线性值提高到（1 / 2.2）次幂。线性值 0.1 给出 0.351，0.2 给出 0.481，而 0.5 给出 0.730。如果未编码，则按原样使用这些值将导致显示器发出的辐射比所需的少。请注意，任何这些转换都始终不会更改 0.0 和 1.0。在使用伽玛校正之前，场景建模人员通常会人为地增加深色表面的颜色，并在逆显示变换中对其进行折叠 **(?)**。

忽略伽玛校正的另一个问题是，在非线性值上执行了对物理线性辐射值正确的着色计算。图 5.40 给出了一个示例。图 5.40 给出了一个示例。

忽略伽玛校正也会影响反走样边缘的质量。例如，假设一个三角形的边缘覆盖了四个屏幕网格单元（图 5.41）。

![[8774d7a937d983b3e0ac00f0e49667bd_MD5.png]]

**图 5.41.** 在左侧，黑色（显示为灰色）背景上的白色三角形边缘覆盖了四个像素，并显示了真实的区域覆盖率。如果不执行伽玛校正，则中间色调的变暗会导致边缘的感知失真，如右图所示。

![[d6a77752ca97a6846488e2e2bb058bbc_MD5.png]]

**图 5.42.** 左侧的一组反走样线经过了伽玛校正； 在中间，该集合被部分校正；在右边，没有伽马校正。（图片由 Scott R. Nelson 提供。）

三角形的标准化辐射率为 1（白色）； 背景为 0（黑色）。从左到右，单元格的覆盖率为 $\frac{1}{8},\frac{3}{8},\frac{5}{8}$ 与 $\frac{7}{8}$ 。因此，如果我们使用 box 滤波器，我们希望将像素的归一化线性辐射度表示为 0.125、0.375、0.625 和 0.875。正确的方法是对线性值执行反走样操作，将编码功能应用于四个结果值。如果不这么做，像素的代表辐射将太暗，从而导致边缘的变形，如图右侧所示。这种伪像被称为扭绳（roping），因为边缘看起来有点像扭曲的绳子 **[167，1265]**。图 5.42 展示了这种效果。

sRGB 标准创建于 1996 年，已经成为大多数计算机显示器的标准。然而，自那时以来，显示技术得到了许多发展。目前已经开发出了更明亮并且可以显示更多颜色的显示器。关于彩色显示和亮度将在 8.1.3 节中讨论，关于高动态范围显示的显示编码将在 8.2.1 节中介绍。Hart 的文章 **[672]** 是了解有关高级显示器更多信息的特别详尽的信息来源。

## **进一步阅读和资源 Further Reading and Resources**

Pharr 等。**[1413]** 更深入地讨论了采样模式和反走样。Teschner 的课程笔记 **[1758]** 展示了各种采样模式的生成方法。Drobot **[382，383]** 提及了先前对实时反走样的研究，解释了各种技术的属性和性能表现。我们可以在相关的 SIGGRAPH 课程 **[829]** 的注释中找到有关各种形态学反走样方法的信息。Reshetov 和 Jimenez **[1486]** 提供了游戏中使用的形态学和相关时间性反走样工作的最新回顾。

对于透明度研究，我们再次将感兴趣的读者推荐给 McGuire 的陈述 **[1182]** 和 Wyman 的著作 **[1931]**。Blinn 的文章 "像素是什么？"(What Is a Pixel?) **[169]** 在讨论不同的定义时，提供了对计算机图形学多个领域的绝佳浏览。Blinn 的书籍 “脏像素 " (_Dirty Pixels_) 和 " 符号，符号，符号” （_Notation, Notation, Notation_）**[166，168]** 包含一些介绍性文章，涉及滤波和反走样，alpha，合成和 gamma 校正。Jimenez 的演讲 **[836]** 详细介绍了用于反走样的最新技术。Jimenez 的演讲 **[836]** 详细介绍了用于反走样的最新技术。

Gritz 和 d'Eon **[607]** 对伽玛校正问题进行了很好的总结。Poynton 的书 **[1431]** 对各种媒体文件中的伽玛校正以及其他与颜色相关的主题进行了详尽的介绍。Selan 的白皮书 **[1602]** 是更新的资料，它解释了显示编码及其在电影行业中的用途，以及许多其他相关的信息。